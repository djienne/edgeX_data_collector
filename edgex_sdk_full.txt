
## README.md
# EdgeX Python SDK

A Python SDK for interacting with the EdgeX Exchange API. This SDK provides a comprehensive interface to the EdgeX API, allowing you to easily integrate EdgeX functionality into your Python applications.

## Features

- **Complete API Coverage**: Access all EdgeX API endpoints
- **WebSocket Support**: Real-time data streaming
- **Async/Await**: Modern Python async interface
- **Type Hints**: Comprehensive type annotations for better IDE support
- **Error Handling**: Proper error handling and validation
- **Pagination**: Support for paginated API endpoints
- **Authentication**: Automatic request signing

## Installation

### From PyPI

```bash
pip install edgex-python-sdk
```

### From Source

```bash
git clone https://github.com/edgex-Tech/edgex-python-sdk.git
cd edgex-python-sdk
pip install -e .
```

### Using Requirements Files

For production use:
```bash
pip install -r requirements.txt
```

For development (includes testing and linting tools):
```bash
pip install -r requirements-dev.txt
```

### Virtual Environment (Recommended)

It's recommended to use a virtual environment:

```bash
# Create virtual environment
python3 -m venv venv

# Activate virtual environment
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Or install in development mode
pip install -e .
```

## Quick Start

```python
import asyncio
import os
from edgex_sdk import Client, OrderSide

async def main():
    # Create a new client
    client = Client(
        base_url="https://pro.edgex.exchange",  # Use https://testnet.edgex.exchange for testnet
        account_id=12345,  # Your account ID
        stark_private_key="your-stark-private-key"  # Your private key
    )

    # Get server time
    server_time = await client.get_server_time()
    print(f"Server Time: {server_time}")

    # Get exchange metadata
    metadata = await client.get_metadata()
    print(f"Available contracts: {len(metadata.get('data', {}).get('contractList', []))}")

    # Get account assets
    assets = await client.get_account_asset()
    print(f"Account Assets: {assets}")

    # Get account positions
    positions = await client.get_account_positions()
    print(f"Account Positions: {positions}")

    # Get 24-hour market data for BNB2USDT (contract ID: 10000004)
    quote = await client.get_24_hour_quote("10000004")
    print(f"BNB2USDT Price: {quote}")

    # Create a limit order (uncomment to place real order)
    # order = await client.create_limit_order(
    #     contract_id="10000004",  # BNB2USDT
    #     size="0.01",
    #     price="600.00",
    #     side=OrderSide.BUY
    # )
    # print(f"Order created: {order}")

# Run the async function
asyncio.run(main())
```

## Architecture

The SDK is organized into modules that correspond to the EdgeX API structure:

```
edgex_sdk/
├── __init__.py
├── client.py           # Main client
├── account/            # Account API
├── asset/              # Asset API
├── funding/            # Funding API
├── internal/           # Internal utilities
├── metadata/           # Metadata API
├── order/              # Order API
├── quote/              # Quote API
├── transfer/           # Transfer API
└── ws/                 # WebSocket API
```

## Available APIs

The SDK currently supports the following API modules:

- **Account API**: Manage account positions, retrieve position transactions, and handle collateral transactions
  - Get account positions
  - Get position by contract ID
  - Get position transaction history
  - Get collateral transaction details
  - Update leverage settings

- **Asset API**: Handle asset management and withdrawals
  - Get asset orders with pagination
  - Get coin rates
  - Manage withdrawals (normal, cross-chain, and fast)
  - Get withdrawal records and sign information
  - Check withdrawable amounts

- **Funding API**: Manage funding operations and account balance
  - Handle funding transactions
  - Manage funding accounts
  - Get funding transaction history

- **Metadata API**: Access exchange system information
  - Get server time
  - Get exchange metadata (trading pairs, contracts, etc.)

- **Order API**: Comprehensive order management
  - Create and cancel orders
  - Get active orders
  - Get order fill transactions
  - Calculate maximum order sizes
  - Manage order history

- **Quote API**: Access market data and pricing
  - Get multi-contract K-line data
  - Get order book depth
  - Access real-time market quotes
  - Get 24-hour ticker data

- **Transfer API**: Handle asset transfers
  - Create transfer out orders
  - Get transfer records (in/out)
  - Check available withdrawal amounts
  - Manage transfer history

- **WebSocket API**: Real-time data streaming
  - Market data (tickers, K-lines, order book, trades)
  - Account updates
  - Order updates
  - Position updates

## WebSocket Support

The SDK provides a WebSocket manager for handling real-time data:

```python
import asyncio
from edgex_sdk import WebSocketManager

async def main():
    # Create a WebSocket manager
    ws_manager = WebSocketManager(
        base_url="wss://quote.edgex.exchange",  # Use wss://quote-testnet.edgex.exchange for testnet
        account_id=12345,
        stark_pri_key="your-stark-private-key"
    )

    # Define message handlers
    def ticker_handler(message):
        print(f"Ticker Update: {message}")

    def kline_handler(message):
        print(f"K-line Update: {message}")

    # Connect to public WebSocket for market data
    ws_manager.connect_public()

    # Subscribe to real-time updates for BNB2USDT (contract ID: 10000004)
    ws_manager.subscribe_ticker("10000004", ticker_handler)
    ws_manager.subscribe_kline("10000004", "1m", kline_handler)

    # Connect to private WebSocket for account updates
    ws_manager.connect_private()

    # Wait for updates
    await asyncio.sleep(30)

    # Disconnect all connections
    ws_manager.disconnect_all()

asyncio.run(main())
```

## Signing Adapters

The SDK provides a flexible signing mechanism through signing adapters. **StarkExSigningAdapter is used by default**, so you don't need to explicitly create one:

```python
from edgex_sdk import Client

# Create a client (uses StarkExSigningAdapter by default)
client = Client(
    base_url="https://pro.edgex.exchange",  # Use https://testnet.edgex.exchange for testnet
    account_id=12345,
    stark_private_key="your-stark-private-key"
)
```

If you need to use a custom signing adapter, you can still provide one:

```python
from edgex_sdk import Client, StarkExSigningAdapter

# Create a custom signing adapter (optional)
signing_adapter = StarkExSigningAdapter()

# Create a client with a custom signing adapter
client = Client(
    base_url="https://pro.edgex.exchange",  # Use https://testnet.edgex.exchange for testnet
    account_id=12345,
    stark_private_key="your-stark-private-key",
    signing_adapter=signing_adapter
)
```

The SDK includes the following signing adapters:

- **StarkExSigningAdapter** (default): Full implementation using StarkWare cryptographic operations for production use

You can also create your own signing adapter by implementing the `SigningAdapter` interface if you need custom cryptographic operations.

## Error Handling

The SDK provides proper error handling for API requests:

```python
import asyncio
from edgex_sdk import Client, OrderSide

async def main():
    client = Client(
        base_url="https://pro.edgex.exchange",  # Use https://testnet.edgex.exchange for testnet
        account_id=12345,
        stark_private_key="your-stark-private-key"
    )

    try:
        # Create a limit order for BNB2USDT
        order = await client.create_limit_order(
            contract_id="10000004",  # BNB2USDT
            size="0.01",
            price="600.00",
            side=OrderSide.BUY
        )
        print(f"Order created: {order}")

        # Cancel the order
        from edgex_sdk import CancelOrderParams
        cancel_params = CancelOrderParams(
            order_id=order.get("data", {}).get("orderId")
        )
        cancel_result = await client.cancel_order(cancel_params)
        print(f"Order cancelled: {cancel_result}")

    except ValueError as e:
        print(f"Failed to create/cancel order: {str(e)}")
    except Exception as e:
        print(f"Unexpected error: {str(e)}")

asyncio.run(main())
```

## Pagination

Many API endpoints support pagination:

```python
import asyncio
from edgex_sdk import Client, GetActiveOrderParams

async def main():
    client = Client(
        base_url="https://pro.edgex.exchange",  # Use https://testnet.edgex.exchange for testnet
        account_id=12345,
        stark_private_key="your-stark-private-key"
    )

    # Create pagination parameters
    params = GetActiveOrderParams(
        size="10",
        offset_data=""
    )

    # Get active orders
    orders = await client.get_active_orders(params)
    print(f"Active orders: {orders}")

    # Get next page if available
    if orders.get("data", {}).get("hasNext"):
        params.offset_data = orders.get("data", {}).get("offsetData")
        next_page = await client.get_active_orders(params)
        print(f"Next page: {next_page}")

asyncio.run(main())
```

## API Examples

### Market Data

```python
from edgex_sdk import Client, GetKLineParams, GetOrderBookDepthParams

# Get 24-hour market quotes for BNB2USDT (contract ID: 10000004)
quote = await client.get_24_hour_quote("10000004")
print(f"Current price: {quote}")

# Get K-line data for BTCUSDT (contract ID: 10000001)
kline_params = GetKLineParams(
    contract_id="10000001",  # BTCUSDT
    interval="1m",
    size="10"
)
klines = await client.quote.get_k_line(kline_params)
print(f"K-lines: {klines}")

# Get order book depth for ETHUSDT (contract ID: 10000002)
depth_params = GetOrderBookDepthParams(
    contract_id="10000002",  # ETHUSDT
    limit=10
)
depth = await client.quote.get_order_book_depth(depth_params)
print(f"Order book: {depth}")
```

### Account Management

```python
# Get account assets
assets = await client.get_account_asset()
print(f"Account assets: {assets}")

# Get account positions
positions = await client.get_account_positions()
print(f"Positions: {positions}")

# Get position transactions
from edgex_sdk import GetPositionTransactionPageParams
tx_params = GetPositionTransactionPageParams(
    size="10",
    offset_data=""
)
transactions = await client.account.get_position_transaction_page(tx_params)
print(f"Transactions: {transactions}")
```

### Order Management

```python
from edgex_sdk import OrderSide, CreateOrderParams, CancelOrderParams

# Create a limit order for BNBUSDT
order = await client.create_limit_order(
    contract_id="10000004",  # BNBUSDT
    size="0.01",
    price="600.00",
    side=OrderSide.BUY
)
print(f"Order created: {order}")

# Get maximum order size for BNBUSDT
max_size = await client.get_max_order_size("10000004", 600.00)
print(f"Max order size: {max_size}")

# Cancel an order
cancel_params = CancelOrderParams(
    order_id=order.get("data", {}).get("orderId")
)
cancel_result = await client.cancel_order(cancel_params)
print(f"Order cancelled: {cancel_result}")
```

### Contract IDs

EdgeX uses numeric contract IDs instead of symbol-based identifiers. Here are some common contract mappings:

| Contract ID | Symbol        | Tick Size |
|-------------|---------------|-----------|
| 10000001    | BTCUSDT       | 0.1       |
| 10000002    | ETHUSDT       | 0.01      |
| 10000003    | SOLUSDT       | 0.01      |

To get the complete list of available contracts:

```python
metadata = await client.get_metadata()
contracts = metadata.get("data", {}).get("contractList", [])
for contract in contracts:
    print(f"ID: {contract['contractId']} - {contract['contractName']}")
```

For more detailed examples, please refer to the [examples](examples) directory.

## Testing

The SDK includes comprehensive test coverage with multiple test suites:

### Unit Tests
```bash
# Run unit tests (no API credentials required)
python -m pytest tests/test_client.py tests/test_starkex_signing_adapter.py -v
```

### Public API Tests
```bash
# Run public endpoint tests (no authentication required)
python run_public_tests.py
```

### Mock Integration Tests
```bash
# Run mock tests (test structure without real API calls)
python run_mock_tests.py
```

### Full Integration Tests
```bash
# Run full integration tests (requires real API credentials)
python run_integration_tests.py
```

### All Tests
```bash
# Run all available tests
python run_tests.py
```

For more testing information, see [TESTING.md](TESTING.md).

## Environment Variables

For testing and development, you can set the following environment variables or create a `.env` file:

```bash
# API Configuration
EDGEX_BASE_URL=https://pro.edgex.exchange  # Use https://testnet.edgex.exchange for testnet
EDGEX_WS_URL=wss://quote.edgex.exchange    # Use wss://quote-testnet.edgex.exchange for testnet

# Account Credentials
EDGEX_ACCOUNT_ID=12345
EDGEX_STARK_PRIVATE_KEY=your-stark-private-key

# Signing Configuration
EDGEX_SIGNING_ADAPTER=starkex
```

Then load them in your code:

```python
import os
from dotenv import load_dotenv
from edgex_sdk import Client

# Load environment variables from .env file
load_dotenv()

client = Client(
    base_url=os.getenv("EDGEX_BASE_URL"),
    account_id=int(os.getenv("EDGEX_ACCOUNT_ID")),
    stark_private_key=os.getenv("EDGEX_STARK_PRIVATE_KEY")
)
```

## Documentation

For detailed API documentation, please refer to the [EdgeX API documentation](https://docs.edgex.exchange).

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin feature/my-new-feature`)
5. Create a new Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## PUBLISHING.md
# Publishing EdgeX Python SDK to PyPI

This guide explains how to publish the EdgeX Python SDK to PyPI without using personal accounts.

## Prerequisites

### 1. Create Organization PyPI Account

1. Go to [PyPI Registration](https://pypi.org/account/register/)
2. Create an account using the organization email (e.g., `info@edgex.exchange`)
3. Verify the email address
4. Enable 2FA for security

### 2. Create API Tokens

For security, use API tokens instead of passwords:

1. Log into the organization PyPI account
2. Go to Account Settings → API tokens
3. Create a new API token:
   - **Name**: `edgex-python-sdk-upload`
   - **Scope**: Limit to specific project (after first upload)
4. Copy and securely store the token (starts with `pypi-`)

### 3. Set up GitHub Secrets

Add the following secrets to your GitHub repository:

1. Go to GitHub repository → Settings → Secrets and variables → Actions
2. Add these secrets:
   - `PYPI_API_TOKEN`: Your PyPI API token
   - `TEST_PYPI_API_TOKEN`: Your Test PyPI API token (optional, for testing)

## Publishing Methods

### Method 1: Automated Publishing via GitHub Actions (Recommended)

This method automatically publishes when you create a GitHub release:

1. **Create a release**:
   ```bash
   git tag v0.1.0
   git push origin v0.1.0
   ```
   
2. **Create GitHub release**:
   - Go to GitHub → Releases → Create a new release
   - Choose the tag you just created
   - Add release notes
   - Publish the release

3. **GitHub Actions will automatically**:
   - Build the package
   - Run quality checks
   - Upload to PyPI

### Method 2: Manual Publishing

If you prefer manual control:

1. **Install build tools**:
   ```bash
   pip install build twine
   ```

2. **Build the package**:
   ```bash
   python scripts/build_and_test_package.py
   ```

3. **Upload to Test PyPI first** (recommended):
   ```bash
   twine upload --repository testpypi dist/*
   ```
   
4. **Test installation from Test PyPI**:
   ```bash
   pip install --index-url https://test.pypi.org/simple/ edgex-python-sdk
   ```

5. **Upload to PyPI**:
   ```bash
   twine upload dist/*
   ```

## Testing Before Publishing

### Local Testing

1. **Build and test locally**:
   ```bash
   python scripts/build_and_test_package.py
   ```

2. **Install locally**:
   ```bash
   pip install dist/edgex_python_sdk-*.whl
   ```

3. **Test basic functionality**:
   ```python
   import edgex_sdk
   print(edgex_sdk.__version__)
   ```

### Test PyPI

Always test on Test PyPI before publishing to the main PyPI:

1. **Upload to Test PyPI**:
   ```bash
   twine upload --repository testpypi dist/*
   ```

2. **Install from Test PyPI**:
   ```bash
   pip install --index-url https://test.pypi.org/simple/ edgex-python-sdk
   ```

## Version Management

Update version numbers in these files before publishing:

1. `setup.py` - line with `version="x.x.x"`
2. `pyproject.toml` - line with `version = "x.x.x"`
3. `edgex_sdk/__init__.py` - add `__version__ = "x.x.x"`

## Security Best Practices

1. **Use API tokens**, not passwords
2. **Enable 2FA** on PyPI account
3. **Limit token scope** to specific projects
4. **Store tokens securely** in GitHub Secrets
5. **Rotate tokens regularly**
6. **Never commit tokens** to version control

## Troubleshooting

### Common Issues

1. **Package name already exists**:
   - Choose a different name in `setup.py` and `pyproject.toml`

2. **Version already exists**:
   - Increment version number
   - You cannot overwrite existing versions on PyPI

3. **Authentication failed**:
   - Check API token is correct
   - Ensure token has proper permissions

4. **Build fails**:
   - Run `python scripts/build_and_test_package.py` locally
   - Check for missing dependencies or syntax errors

### Getting Help

- PyPI Help: https://pypi.org/help/
- Packaging Guide: https://packaging.python.org/
- GitHub Actions: https://docs.github.com/en/actions

## Post-Publishing

After successful publishing:

1. **Test installation**:
   ```bash
   pip install edgex-python-sdk
   ```

2. **Update documentation** if needed

3. **Announce the release** to users

4. **Monitor for issues** and user feedback


## TESTING.md
# EdgeX Python SDK Testing Documentation

This document provides an overview of the testing strategy for the EdgeX Python SDK, including which components are covered by tests and which are not.

## Table of Contents

- [Test Structure](#test-structure)
- [Unit Tests](#unit-tests)
  - [Signing Adapter Tests](#signing-adapter-tests)
  - [Client Tests](#client-tests)
  - [Internal Client Tests](#internal-client-tests)
- [Integration Tests](#integration-tests)
  - [Account API Tests](#account-api-tests)
  - [Metadata API Tests](#metadata-api-tests)
  - [Order API Tests](#order-api-tests)
  - [Quote API Tests](#quote-api-tests)
  - [WebSocket API Tests](#websocket-api-tests)
- [Test Coverage](#test-coverage)
  - [Well-Covered Components](#well-covered-components)
  - [Partially Covered Components](#partially-covered-components)
  - [Components Lacking Coverage](#components-lacking-coverage)
- [Running Tests](#running-tests)
  - [Running Unit Tests](#running-unit-tests)
  - [Running Integration Tests](#running-integration-tests)
  - [Running Mock Tests](#running-mock-tests)
- [Test Environment](#test-environment)
- [Future Test Improvements](#future-test-improvements)

## Test Structure

The EdgeX Python SDK test suite is organized into two main categories:

1. **Unit Tests**: Located in `python_sdk/tests/`, these tests focus on individual components and functions without requiring external API connections.

2. **Integration Tests**: Located in `python_sdk/tests/integration/`, these tests verify the SDK's interaction with the EdgeX API endpoints.

## Unit Tests

### Signing Adapter Tests

File: `tests/test_starkex_signing_adapter.py`

These tests verify the functionality of the StarkEx signing adapter, which is responsible for cryptographic operations using the Stark curve.

**Coverage:**

- ✅ Sign and verify operations
- ✅ Public key derivation
- ✅ Error handling for invalid inputs
- ✅ Edge cases (zero values, large values)
- ✅ Signature verification with different messages and keys

**Test Cases:**
- `test_sign_and_verify`: Tests basic signing and verification
- `test_sign_different_messages`: Ensures different messages produce different signatures
- `test_sign_different_keys`: Ensures different keys produce different signatures
- `test_verify_invalid_signature`: Tests rejection of invalid signatures
- `test_verify_wrong_message`: Tests rejection when verifying with wrong message
- `test_verify_wrong_public_key`: Tests rejection when verifying with wrong public key
- `test_invalid_private_key`: Tests handling of invalid private keys
- `test_invalid_message_hash`: Tests handling of invalid message hashes

### Client Tests

File: `tests/test_client.py`

These tests verify the functionality of the main client class, which serves as the entry point for the SDK.

**Coverage:**

- ✅ Client initialization
- ✅ Parameter validation
- ✅ Method delegation to specialized clients

**Test Cases:**
- `test_init`: Tests client initialization with valid parameters
- `test_init_invalid_params`: Tests client initialization with invalid parameters

### Internal Client Tests

File: `tests/test_internal_client.py`

These tests verify the functionality of the internal client, which handles low-level API communication and signing.

**Coverage:**

- ✅ Request signing
- ✅ Timestamp generation
- ✅ Header construction
- ✅ Parameter validation

**Test Cases:**
- `test_init`: Tests internal client initialization
- `test_get_timestamp`: Tests timestamp generation
- `test_sign`: Tests message signing
- `test_get_stark_pri_key`: Tests private key retrieval

## Integration Tests

Integration tests verify the SDK's interaction with the EdgeX API endpoints. Most of these tests require valid API credentials to pass, except for tests of public endpoints.

> **Note**: For information about public endpoints that can be tested without credentials, see [PUBLIC_ENDPOINTS.md](PUBLIC_ENDPOINTS.md).

### Account API Tests

File: `tests/integration/test_account.py`

**Coverage:**

- ✅ Account retrieval
- ✅ Asset information retrieval
- ✅ Position information retrieval
- ✅ Transaction history retrieval

**Test Cases:**
- `test_get_account_by_id`: Tests retrieving account information
- `test_get_account_asset`: Tests retrieving account asset information
- `test_get_account_positions`: Tests retrieving account positions
- `test_get_position_transaction_page`: Tests retrieving position transaction history
- `test_get_collateral_transaction_page`: Tests retrieving collateral transaction history

### Metadata API Tests

File: `tests/integration/test_metadata.py`

**Coverage:**

- ✅ Contract metadata retrieval
- ✅ Server time retrieval

**Test Cases:**
- `test_get_metadata`: Tests retrieving contract metadata
- `test_get_server_time`: Tests retrieving server time
- `test_contract_exists`: Tests checking if a contract exists

### Order API Tests

File: `tests/integration/test_order.py`

**Coverage:**

- ✅ Order creation
- ✅ Order cancellation
- ✅ Active order retrieval
- ✅ Order fill transaction retrieval
- ✅ Maximum order size retrieval

**Test Cases:**
- `test_create_and_cancel_order`: Tests creating and canceling an order
- `test_get_active_orders`: Tests retrieving active orders
- `test_get_order_fill_transactions`: Tests retrieving order fill transactions
- `test_get_max_order_size`: Tests retrieving maximum order size

### Quote API Tests

File: `tests/integration/test_quote.py`

**Coverage:**

- ✅ 24-hour quote retrieval
- ✅ K-line data retrieval
- ✅ Order book depth retrieval
- ✅ Multi-contract K-line data retrieval

**Test Cases:**
- `test_get_24_hour_quote`: Tests retrieving 24-hour quotes
- `test_get_k_line`: Tests retrieving K-line data
- `test_get_order_book_depth`: Tests retrieving order book depth
- `test_get_multi_contract_k_line`: Tests retrieving multi-contract K-line data

### WebSocket API Tests

File: `tests/integration/test_websocket.py`

**Coverage:**

- ✅ Public WebSocket connection
- ✅ Private WebSocket connection
- ✅ Subscription to various channels
- ✅ Message handling

**Test Cases:**
- `test_public_websocket`: Tests connecting to the public WebSocket
- `test_private_websocket`: Tests connecting to the private WebSocket

## Test Coverage

### Well-Covered Components

The following components have good test coverage:

1. **StarkEx Signing Adapter**: Comprehensive unit tests for all cryptographic operations
2. **Client Initialization**: Thorough testing of parameter validation and initialization
3. **API Endpoint Structure**: Integration tests cover all major API endpoints

### Partially Covered Components

The following components have partial test coverage:

1. **Error Handling**: Some error conditions are tested, but not all possible error scenarios
2. **WebSocket Message Handling**: Basic connection is tested, but not all message types
3. **Response Parsing**: Basic parsing is tested, but not all edge cases

### Components Lacking Coverage

The following components could benefit from additional test coverage:

1. **Reconnection Logic**: WebSocket reconnection logic is not thoroughly tested
2. **Rate Limiting**: Handling of API rate limits is not tested
3. **Long-Running Operations**: Tests for long-running operations or pagination
4. **Concurrency**: Tests for concurrent API calls
5. **Transfer and Asset Clients**: Missing dedicated integration tests

## Running Tests

### Running Unit Tests

To run all unit tests:

```bash
cd python_sdk
python -m unittest discover tests
```

To run a specific test file:

```bash
cd python_sdk
python -m unittest tests/test_starkex_signing_adapter.py
```

### Running Integration Tests

To run integration tests with real API credentials:

```bash
cd python_sdk
python run_integration_tests.py
```

**Note**: This requires setting the following environment variables:
- `EDGEX_BASE_URL`: The base URL for the EdgeX API
- `EDGEX_WS_URL`: The WebSocket URL for the EdgeX API
- `EDGEX_ACCOUNT_ID`: Your EdgeX account ID
- `EDGEX_STARK_PRIVATE_KEY`: Your Stark private key

Example:
```bash
export EDGEX_ACCOUNT_ID="your_account_id_here"
export EDGEX_STARK_PRIVATE_KEY="your_stark_private_key_here"
```

**⚠️ SECURITY WARNING**: Never commit these credentials to version control. Always use environment variables or secure credential management systems.

### Running Public Endpoint Tests

To run only the tests for public endpoints (which don't require authentication):

```bash
cd python_sdk
python run_public_tests.py
```

This script uses dummy values for the required environment variables and only tests endpoints that don't require authentication.

**Note**: Some tests, particularly the WebSocket test, may be skipped due to connection issues or API limitations. This is expected behavior and doesn't indicate a problem with the SDK.

### Running Mock Tests

To run integration tests with mock values (for testing the SDK structure without real API calls):

```bash
cd python_sdk
python run_mock_tests.py
```

## Test Environment

The tests are designed to run in the following environments:

- **Unit Tests**: Can run in any environment with Python 3.7+
- **Integration Tests**: Require access to the EdgeX API
- **Mock Tests**: Can run in any environment with Python 3.7+

## Future Test Improvements

The following improvements could be made to the test suite:

1. **Separate Public and Private Endpoint Tests**: Fully separate tests for public endpoints from those requiring authentication

1. **Increased Unit Test Coverage**: Add tests for edge cases and error conditions
2. **Mocking External Dependencies**: Use mocks for API responses to test more scenarios
3. **Property-Based Testing**: Implement property-based testing for cryptographic operations
4. **Performance Testing**: Add tests for performance and resource usage
5. **Dedicated Transfer and Asset Tests**: Add dedicated integration tests for these clients
6. **WebSocket Message Testing**: Add more tests for different WebSocket message types
7. **Concurrency Testing**: Add tests for concurrent API calls
8. **Long-Running Operation Testing**: Add tests for pagination and long-running operations


## LICENSE
MIT License

Copyright (c) 2024 EdgeX Tech

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


## edgex_sdk/__init__.py
"""
EdgeX Python SDK - A Python SDK for interacting with the EdgeX Exchange API.
"""

from .client import Client
from .internal.signing_adapter import SigningAdapter
from .internal.starkex_signing_adapter import StarkExSigningAdapter
from .order.types import (
    OrderType,
    OrderSide,
    TimeInForce,
    CreateOrderParams,
    CancelOrderParams,
    GetActiveOrderParams,
    OrderFillTransactionParams
)
from .account.client import (
    GetPositionTransactionPageParams,
    GetCollateralTransactionPageParams,
    GetPositionTermPageParams,
    GetAccountAssetSnapshotPageParams
)
from .quote.client import (
    GetKLineParams,
    GetOrderBookDepthParams,
    GetMultiContractKLineParams
)
from .transfer.client import (
    GetTransferOutByIdParams,
    GetTransferInByIdParams,
    GetWithdrawAvailableAmountParams,
    CreateTransferOutParams,
    GetTransferOutPageParams,
    GetTransferInPageParams
)
from .asset.client import (
    GetAssetOrdersParams,
    CreateWithdrawalParams,
    GetWithdrawalRecordsParams
)
from .ws.manager import Manager as WebSocketManager

__version__ = "0.1.0"
__all__ = [
    "Client",
    "OrderType",
    "OrderSide",
    "TimeInForce",
    "CreateOrderParams",
    "CancelOrderParams",
    "GetActiveOrderParams",
    "OrderFillTransactionParams",
    "GetPositionTransactionPageParams",
    "GetCollateralTransactionPageParams",
    "GetPositionTermPageParams",
    "GetAccountAssetSnapshotPageParams",
    "GetKLineParams",
    "GetOrderBookDepthParams",
    "GetMultiContractKLineParams",
    "GetTransferOutByIdParams",
    "GetTransferInByIdParams",
    "GetWithdrawAvailableAmountParams",
    "CreateTransferOutParams",
    "GetTransferOutPageParams",
    "GetTransferInPageParams",
    "GetAssetOrdersParams",
    "CreateWithdrawalParams",
    "GetWithdrawalRecordsParams",
    "WebSocketManager",
    "SigningAdapter",
    "StarkExSigningAdapter"
]

## edgex_sdk/account/__init__.py


## edgex_sdk/account/client.py
from typing import Dict, Any, List, Optional

from ..internal.async_client import AsyncClient


class GetPositionTransactionPageParams:
    """Parameters for getting position transactions with pagination."""

    def __init__(
        self,
        size: str = "",
        offset_data: str = "",
        filter_contract_id_list: List[str] = None,
        filter_start_created_time_inclusive: int = 0,
        filter_end_created_time_exclusive: int = 0
    ):
        self.size = size
        self.offset_data = offset_data
        self.filter_contract_id_list = filter_contract_id_list or []
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class GetCollateralTransactionPageParams:
    """Parameters for getting collateral transactions with pagination."""

    def __init__(
        self,
        size: str = "",
        offset_data: str = "",
        filter_start_created_time_inclusive: int = 0,
        filter_end_created_time_exclusive: int = 0
    ):
        self.size = size
        self.offset_data = offset_data
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class GetPositionTermPageParams:
    """Parameters for getting position terms with pagination."""

    def __init__(
        self,
        size: str = "",
        offset_data: str = "",
        filter_contract_id_list: List[str] = None,
        filter_start_created_time_inclusive: int = 0,
        filter_end_created_time_exclusive: int = 0
    ):
        self.size = size
        self.offset_data = offset_data
        self.filter_contract_id_list = filter_contract_id_list or []
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class GetAccountAssetSnapshotPageParams:
    """Parameters for getting account asset snapshots with pagination."""

    def __init__(
        self,
        size: str = "",
        offset_data: str = "",
        filter_start_created_time_inclusive: int = 0,
        filter_end_created_time_exclusive: int = 0
    ):
        self.size = size
        self.offset_data = offset_data
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class Client:
    """Client for account-related API endpoints."""

    def __init__(self, async_client: AsyncClient):
        """
        Initialize the account client.

        Args:
            async_client: The async client for common functionality
        """
        self.async_client = async_client

    async def get_account_asset(self) -> Dict[str, Any]:
        """
        Get the account asset information.

        Returns:
            Dict[str, Any]: The account asset information

        Raises:
            ValueError: If the request fails
        """
        params = {
            "accountId": str(self.async_client.get_account_id())
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/account/getAccountAsset",
            params=params
        )

    async def get_account_positions(self) -> Dict[str, Any]:
        """
        Get the account positions.

        Note: This calls the same endpoint as get_account_asset, which returns both
        collateral and position data. The position data is in the 'positionAssetList' field.

        Returns:
            Dict[str, Any]: The account positions (same as account asset response)

        Raises:
            ValueError: If the request fails
        """
        # Use the same endpoint as get_account_asset (matching Go SDK behavior)
        return await self.get_account_asset()

    async def get_position_transaction_page(self, params: GetPositionTransactionPageParams) -> Dict[str, Any]:
        """
        Get the position transactions with pagination.

        Args:
            params: Position transaction query parameters

        Returns:
            Dict[str, Any]: The position transactions

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_contract_id_list:
            query_params["filterContractIdList"] = ",".join(params.filter_contract_id_list)

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/account/getPositionTransactionPage",
            params=query_params
        )

    async def get_collateral_transaction_page(self, params: GetCollateralTransactionPageParams) -> Dict[str, Any]:
        """
        Get the collateral transactions with pagination.

        Args:
            params: Collateral transaction query parameters

        Returns:
            Dict[str, Any]: The collateral transactions

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/account/getCollateralTransactionPage",
            params=query_params
        )

    async def get_position_term_page(self, params: GetPositionTermPageParams) -> Dict[str, Any]:
        """
        Get the position terms with pagination.

        Args:
            params: Position term query parameters

        Returns:
            Dict[str, Any]: The position terms

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.base_url}/api/v1/private/account/getPositionTermPage"
        query_params = {
            "accountId": str(self.internal_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_contract_id_list:
            query_params["filterContractIdList"] = ",".join(params.filter_contract_id_list)

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        response = self.session.get(url, params=query_params)

        if response.status_code != 200:
            raise ValueError(f"request failed with status code: {response.status_code}")

        resp_data = response.json()

        if resp_data.get("code") != ResponseCode.SUCCESS:
            error_param = resp_data.get("errorParam")
            if error_param:
                raise ValueError(f"request failed with error params: {error_param}")
            raise ValueError(f"request failed with code: {resp_data.get('code')}")

        return resp_data

    async def get_account_by_id(self) -> Dict[str, Any]:
        """
        Get account information by ID.

        Returns:
            Dict[str, Any]: The account information

        Raises:
            ValueError: If the request fails
        """
        params = {
            "accountId": str(self.async_client.get_account_id())
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/account/getAccountById",
            params=params
        )

    async def get_account_deleverage_light(self) -> Dict[str, Any]:
        """
        Get account deleverage light information.

        Returns:
            Dict[str, Any]: The account deleverage light information

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.base_url}/api/v1/private/account/getAccountDeleverageLight"
        params = {
            "accountId": str(self.internal_client.get_account_id())
        }

        response = self.session.get(url, params=params)

        if response.status_code != 200:
            raise ValueError(f"request failed with status code: {response.status_code}")

        resp_data = response.json()

        if resp_data.get("code") != ResponseCode.SUCCESS:
            error_param = resp_data.get("errorParam")
            if error_param:
                raise ValueError(f"request failed with error params: {error_param}")
            raise ValueError(f"request failed with code: {resp_data.get('code')}")

        return resp_data

    async def get_account_asset_snapshot_page(self, params: GetAccountAssetSnapshotPageParams) -> Dict[str, Any]:
        """
        Get account asset snapshots with pagination.

        Args:
            params: Account asset snapshot query parameters

        Returns:
            Dict[str, Any]: The account asset snapshots

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.base_url}/api/v1/private/account/getAccountAssetSnapshotPage"
        query_params = {
            "accountId": str(self.internal_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        response = self.session.get(url, params=query_params)

        if response.status_code != 200:
            raise ValueError(f"request failed with status code: {response.status_code}")

        resp_data = response.json()

        if resp_data.get("code") != ResponseCode.SUCCESS:
            error_param = resp_data.get("errorParam")
            if error_param:
                raise ValueError(f"request failed with error params: {error_param}")
            raise ValueError(f"request failed with code: {resp_data.get('code')}")

        return resp_data

    async def get_position_transaction_by_id(self, transaction_ids: List[str]) -> Dict[str, Any]:
        """
        Get position transactions by IDs.

        Args:
            transaction_ids: List of transaction IDs

        Returns:
            Dict[str, Any]: The position transactions

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.base_url}/api/v1/private/account/getPositionTransactionById"
        query_params = {
            "accountId": str(self.internal_client.get_account_id()),
            "transactionIdList": ",".join(transaction_ids)
        }

        response = self.session.get(url, params=query_params)

        if response.status_code != 200:
            raise ValueError(f"request failed with status code: {response.status_code}")

        resp_data = response.json()

        if resp_data.get("code") != ResponseCode.SUCCESS:
            error_param = resp_data.get("errorParam")
            if error_param:
                raise ValueError(f"request failed with error params: {error_param}")
            raise ValueError(f"request failed with code: {resp_data.get('code')}")

        return resp_data

    async def get_collateral_transaction_by_id(self, transaction_ids: List[str]) -> Dict[str, Any]:
        """
        Get collateral transactions by IDs.

        Args:
            transaction_ids: List of transaction IDs

        Returns:
            Dict[str, Any]: The collateral transactions

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.base_url}/api/v1/private/account/getCollateralTransactionById"
        query_params = {
            "accountId": str(self.internal_client.get_account_id()),
            "transactionIdList": ",".join(transaction_ids)
        }

        response = self.session.get(url, params=query_params)

        if response.status_code != 200:
            raise ValueError(f"request failed with status code: {response.status_code}")

        resp_data = response.json()

        if resp_data.get("code") != ResponseCode.SUCCESS:
            error_param = resp_data.get("errorParam")
            if error_param:
                raise ValueError(f"request failed with error params: {error_param}")
            raise ValueError(f"request failed with code: {resp_data.get('code')}")

        return resp_data

    async def update_leverage_setting(self, contract_id: str, leverage: str) -> None:
        """
        Update the account leverage settings.

        Args:
            contract_id: The contract ID
            leverage: The leverage value

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.base_url}/api/v1/private/account/updateLeverageSetting"
        data = {
            "accountId": str(self.internal_client.get_account_id()),
            "contractId": contract_id,
            "leverage": leverage
        }

        response = self.session.post(url, json=data)

        if response.status_code != 200:
            raise ValueError(f"request failed with status code: {response.status_code}")

        resp_data = response.json()

        if resp_data.get("code") != ResponseCode.SUCCESS:
            error_param = resp_data.get("errorParam")
            if error_param:
                raise ValueError(f"request failed with error params: {error_param}")
            raise ValueError(f"request failed with code: {resp_data.get('code')}")


## edgex_sdk/asset/__init__.py


## edgex_sdk/asset/client.py
from typing import Dict, Any, List

from ..internal.async_client import AsyncClient


class GetAssetOrdersParams:
    """Parameters for getting asset orders."""

    def __init__(self, size: str = "10", offset_data: str = "", filter_coin_id_list: List[str] = None,
                 filter_start_created_time_inclusive: int = 0, filter_end_created_time_exclusive: int = 0):
        self.size = size
        self.offset_data = offset_data
        self.filter_coin_id_list = filter_coin_id_list or []
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class CreateWithdrawalParams:
    """Parameters for creating a withdrawal."""

    def __init__(self, coin_id: str, amount: str, address: str, tag: str = ""):
        self.coin_id = coin_id
        self.amount = amount
        self.address = address
        self.tag = tag


class GetWithdrawalRecordsParams:
    """Parameters for getting withdrawal records."""

    def __init__(self, size: str = "10", offset_data: str = "", filter_coin_id_list: List[str] = None,
                 filter_status_list: List[str] = None, filter_start_created_time_inclusive: int = 0,
                 filter_end_created_time_exclusive: int = 0):
        self.size = size
        self.offset_data = offset_data
        self.filter_coin_id_list = filter_coin_id_list or []
        self.filter_status_list = filter_status_list or []
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class Client:
    """Client for asset-related API endpoints."""

    def __init__(self, async_client: AsyncClient):
        """
        Initialize the asset client.

        Args:
            async_client: The async client for common functionality
        """
        self.async_client = async_client

    async def get_account_asset(self) -> Dict[str, Any]:
        """
        Get the account asset information.
        Note: This method delegates to the account client since it's an account endpoint.

        Returns:
            Dict[str, Any]: The account asset information

        Raises:
            ValueError: If the request fails
        """
        # This is actually an account endpoint, not an asset endpoint
        # We should delegate to the account client
        raise NotImplementedError("This method should be called from the account client: client.account.get_account_asset()")

    async def get_asset_orders(
        self,
        params: GetAssetOrdersParams
    ) -> Dict[str, Any]:
        """
        Get asset orders with pagination.

        Args:
            params: Parameters for the request

        Returns:
            Dict[str, Any]: The asset orders

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(params.filter_coin_id_list)

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/assets/getAllOrdersPage",
            params=query_params
        )

    async def get_coin_rates(self, chain_id: str = "1", coin: str = "0xdac17f958d2ee523a2206206994597c13d831ec7") -> Dict[str, Any]:
        """
        Get coin rates.

        Args:
            chain_id: Chain ID (default: "1" for Ethereum mainnet)
            coin: Coin contract address (default: USDT)

        Returns:
            Dict[str, Any]: The coin rates

        Raises:
            ValueError: If the request fails
        """
        params = {
            "chainId": chain_id,
            "coin": coin
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/assets/getCoinRate",
            params=params
        )

    async def create_withdrawal(
        self,
        coin_id: str,
        amount: str,
        address: str,
        network: str,
        memo: str = "",
        client_order_id: str = None
    ) -> Dict[str, Any]:
        """
        Create a withdrawal request.

        Args:
            coin_id: The coin ID
            amount: The withdrawal amount
            address: The withdrawal address
            network: The network
            memo: Optional memo
            client_order_id: Optional client order ID

        Returns:
            Dict[str, Any]: The withdrawal result

        Raises:
            ValueError: If the request fails
        """
        data = {
            "accountId": str(self.async_client.get_account_id()),
            "coinId": coin_id,
            "amount": amount,
            "address": address,
            "network": network
        }

        if memo:
            data["memo"] = memo

        if client_order_id:
            data["clientOrderId"] = client_order_id
        else:
            data["clientOrderId"] = self.async_client.generate_uuid()

        return await self.async_client.make_authenticated_request(
            method="POST",
            path="/api/v1/private/assets/createNormalWithdraw",
            data=data
        )

    async def get_withdrawal_records(
        self,
        size: str = "",
        offset_data: str = "",
        filter_coin_id_list: List[str] = None,
        filter_status_list: List[str] = None,
        filter_start_created_time_inclusive: int = 0,
        filter_end_created_time_exclusive: int = 0
    ) -> Dict[str, Any]:
        """
        Get withdrawal records with pagination.

        Args:
            size: Size of the page
            offset_data: Offset data for pagination
            filter_coin_id_list: Filter by coin IDs
            filter_status_list: Filter by status
            filter_start_created_time_inclusive: Filter start time (inclusive)
            filter_end_created_time_exclusive: Filter end time (exclusive)

        Returns:
            Dict[str, Any]: The withdrawal records

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if size:
            query_params["size"] = size
        if offset_data:
            query_params["offsetData"] = offset_data

        # Add filter parameters
        if filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(filter_coin_id_list)
        if filter_status_list:
            query_params["filterStatusList"] = ",".join(filter_status_list)

        # Add time filters
        if filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(filter_start_created_time_inclusive)
        if filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/assets/getNormalWithdrawById",
            params=query_params
        )

    async def get_withdrawable_amount(self, address: str) -> Dict[str, Any]:
        """
        Get the withdrawable amount for a coin.

        Args:
            address: The coin contract address

        Returns:
            Dict[str, Any]: The withdrawable amount information

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "address": address
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/assets/getNormalWithdrawableAmount",
            params=query_params
        )

    async def get_withdrawal_records(self, params: GetWithdrawalRecordsParams) -> Dict[str, Any]:
        """
        Get withdrawal records with pagination.

        Args:
            params: Parameters for the request

        Returns:
            Dict[str, Any]: The withdrawal records

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(params.filter_coin_id_list)
        if params.filter_status_list:
            query_params["filterStatusList"] = ",".join(params.filter_status_list)

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/assets/getNormalWithdrawById",
            params=query_params
        )


## edgex_sdk/client.py
import json
import time
from typing import Dict, Any, Optional, List, Union
from decimal import Decimal

from .internal.async_client import AsyncClient
from .internal.signing_adapter import SigningAdapter
from .internal.starkex_signing_adapter import StarkExSigningAdapter
from .account.client import Client as AccountClient
from .asset.client import Client as AssetClient
from .funding.client import Client as FundingClient
from .metadata.client import Client as MetadataClient
from .order.client import Client as OrderClient
from .quote.client import Client as QuoteClient
from .transfer.client import Client as TransferClient
from .order.types import CreateOrderParams, CancelOrderParams, GetActiveOrderParams, OrderFillTransactionParams


class Client:
    """Main EdgeX SDK client."""

    def __init__(self, base_url: str, account_id: int, stark_private_key: str,
                 signing_adapter: Optional[SigningAdapter] = None, timeout: float = 30.0):
        """
        Initialize the EdgeX SDK client.

        Args:
            base_url: Base URL for API endpoints
            account_id: Account ID for authentication
            stark_private_key: Stark private key for signing
            signing_adapter: Optional signing adapter (defaults to StarkExSigningAdapter)
            timeout: Request timeout in seconds
        """
        # Use StarkExSigningAdapter as default if none provided
        if signing_adapter is None:
            signing_adapter = StarkExSigningAdapter()

        # Create async client
        self.async_client = AsyncClient(
            base_url=base_url,
            account_id=account_id,
            stark_pri_key=stark_private_key,
            signing_adapter=signing_adapter,
            timeout=timeout
        )

        # Initialize API clients
        self.metadata = MetadataClient(self.async_client)
        self.account = AccountClient(self.async_client)
        self.order = OrderClient(self.async_client)
        self.quote = QuoteClient(self.async_client)
        self.funding = FundingClient(self.async_client)
        self.transfer = TransferClient(self.async_client)
        self.asset = AssetClient(self.async_client)

    async def __aenter__(self):
        """Async context manager entry."""
        await self.async_client._ensure_session()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def close(self):
        """Close the client and cleanup resources."""
        await self.async_client.close()

    @property
    def internal_client(self):
        """Backward compatibility property for accessing internal client."""
        return self.async_client

    async def get_metadata(self) -> Dict[str, Any]:
        """Get the exchange metadata."""
        return await self.metadata.get_metadata()

    async def get_server_time(self) -> Dict[str, Any]:
        """Get the current server time."""
        return await self.metadata.get_server_time()

    async def create_order(self, params: CreateOrderParams) -> Dict[str, Any]:
        """
        Create a new order with the given parameters.

        Args:
            params: Order parameters

        Returns:
            Dict[str, Any]: The created order
        """
        # Get metadata first
        metadata = await self.get_metadata()
        if not metadata:
            raise ValueError("failed to get metadata")

        return await self.order.create_order(params, metadata.get("data", {}))

    async def get_max_order_size(self, contract_id: str, price: Decimal) -> Dict[str, Any]:
        """
        Get the maximum order size for a given contract and price.

        Args:
            contract_id: The contract ID
            price: The price

        Returns:
            Dict[str, Any]: The maximum order size information
        """
        return await self.order.get_max_order_size(contract_id, float(price))

    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:
        """
        Cancel a specific order.

        Args:
            params: Cancel order parameters

        Returns:
            Dict[str, Any]: The cancellation result
        """
        return await self.order.cancel_order(params)

    async def get_active_orders(self, params: GetActiveOrderParams) -> Dict[str, Any]:
        """
        Get active orders with pagination and filters.

        Args:
            params: Active order query parameters

        Returns:
            Dict[str, Any]: The active orders
        """
        return await self.order.get_active_orders(params)

    async def get_order_fill_transactions(self, params: OrderFillTransactionParams) -> Dict[str, Any]:
        """
        Get order fill transactions with pagination and filters.

        Args:
            params: Order fill transaction query parameters

        Returns:
            Dict[str, Any]: The order fill transactions
        """
        return await self.order.get_order_fill_transactions(params)

    async def get_account_asset(self) -> Dict[str, Any]:
        """Get the account asset information."""
        return await self.account.get_account_asset()

    async def get_account_positions(self) -> Dict[str, Any]:
        """Get the account positions."""
        return await self.account.get_account_positions()

    async def create_limit_order(
        self,
        contract_id: str,
        size: str,
        price: str,
        side: str,
        client_order_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create a new limit order with the given parameters.

        Args:
            contract_id: The contract ID
            size: The order size
            price: The order price
            side: The order side (BUY or SELL)
            client_order_id: Optional client order ID

        Returns:
            Dict[str, Any]: The created order
        """
        from .order.types import OrderType

        params = CreateOrderParams(
            contract_id=contract_id,
            size=size,
            price=price,
            side=side,
            type=OrderType.LIMIT,
            client_order_id=client_order_id
        )

        return await self.create_order(params)

    async def create_market_order(
        self,
        contract_id: str,
        size: str,
        side: str,
        client_order_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Create a new market order with the given parameters.

        Args:
            contract_id: The contract ID
            size: The order size
            side: The order side (BUY or SELL)
            client_order_id: Optional client order ID

        Returns:
            Dict[str, Any]: The created order
        """
        # Get metadata for contract info
        metadata = await self.get_metadata()
        if not metadata:
            raise ValueError("failed to get metadata")

        # Find the contract
        contract = None
        contract_list = metadata.get("data", {}).get("contractList", [])
        for c in contract_list:
            if c.get("contractId") == contract_id:
                contract = c
                break

        if not contract:
            raise ValueError(f"contract not found: {contract_id}")

        # Calculate price based on side
        from .order.types import OrderSide, OrderType

        if side == OrderSide.BUY:
            # For buy orders: oracle_price * 10, rounded to price precision
            quote = await self.get_24_hour_quote(contract_id)
            if not quote:
                raise ValueError("failed to get 24-hour quotes")

            oracle_price = Decimal(quote.get("data", [])[0].get("oraclePrice", "0"))
            multiplier = Decimal("10")
            tick_size = Decimal(contract.get("tickSize", "0"))
            precision = abs(tick_size.as_tuple().exponent)
            price = str(round(oracle_price * multiplier, precision))
        else:
            # For sell orders: use tick size
            price = contract.get("tickSize", "0")

        params = CreateOrderParams(
            contract_id=contract_id,
            size=size,
            price=price,
            side=side,
            type=OrderType.MARKET,
            client_order_id=client_order_id
        )

        return await self.create_order(params)

    async def get_24_hour_quote(self, contract_id: str) -> Dict[str, Any]:
        """
        Get the 24-hour quotes for a given contract.

        Args:
            contract_id: The contract ID

        Returns:
            Dict[str, Any]: The 24-hour quotes
        """
        return await self.quote.get_24_hour_quote(contract_id)


## edgex_sdk/crypto/__init__.py
"""
Cryptographic utilities for the EdgeX Python SDK.

This module provides cryptographic functions including Pedersen hash
implementation compatible with StarkWare's specifications.
"""

from .pedersen_hash import pedersen_hash, pedersen_hash_as_point

__all__ = [
    'pedersen_hash',
    'pedersen_hash_as_point',
]


## edgex_sdk/crypto/constants.py
"""
Constants for StarkWare cryptographic operations.

This module contains the constant points and parameters used in
Pedersen hash calculations, extracted from the StarkWare specification.

Contains the complete set of 506 constant points for full compatibility
with the Go SDK and StarkWare reference implementation.
"""

# StarkEx curve parameters
FIELD_PRIME = 0x800000000000011000000000000000000000000000000000000000000000001
ALPHA = 1
BETA = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89
EC_ORDER = 0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f

# Number of bits used in hash calculations
N_ELEMENT_BITS_HASH = 252

# Shift point (first constant point) - matches Go SDK cfg.ConstantPoints[0]
SHIFT_POINT = [
    2089986280348253421170679821480865132823066470938446095505822317253594081284,
    1713931329540660377023406109199410414810705867260802078187082345529207694986
]

# Generator point for the Stark curve
EC_GEN = [
    0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca,
    0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f
]

# Full constant points for Pedersen hash - extracted from Go SDK
# This provides the complete set of 506 constant points needed for full compatibility
CONSTANT_POINTS = [
    # Point 0
    [
        2089986280348253421170679821480865132823066470938446095505822317253594081284,
        1713931329540660377023406109199410414810705867260802078187082345529207694986
    ],
    # Point 1
    [
        874739451078007766457464989774322083649278607533249481151382481072868806602,
        152666792071518830868575557812948353041420400780739481342941381225525861407
    ],
    # Point 2
    [
        996781205833008774514500082376783249102396023663454813447423147977397232763,
        1668503676786377725805489344771023921079126552019160156920634619255970485781
    ],
    # Point 3
    [
        100775230685312048816501234355008830851785728808228209380195522984287974518,
        3198314560325546891798262260233968848553481119985289977998522774043088964633
    ],
    # Point 4
    [
        1837189741429329983886833789246131275985545035599091291966623919967841244204,
        469920083884440505232139273974987899994000885911056071194573294589259802432
    ],
    # Point 5
    [
        1337726844298689299569036965005062374791732295462158862097564380968412485659,
        3094702644796621069343809899235459280874613277076424986270525032931210979878
    ],
    # Point 6
    [
        2997390320399291502365701712271136720873363591256030629621859546399086933620,
        2725742381037070528763700586156979930560374472266472382691451570287013862562
    ],
    # Point 7
    [
        3608386523905995279224196894194758246854376991737956048428718275550441491554,
        299638830690759628369563708877422667364443387620215168054000198378323554222
    ],
    # Point 8
    [
        1733017745745290190841058775834438078769759612359153596488000160651631909868,
        1973340172374381850851160588687352250788736199336041450103281811142396650489
    ],
    # Point 9
    [
        855657745844414012325398643860801166203065495756352613799675558543302817038,
        1379036914678019505188657918379814767819231204146554192918997656166330268474
    ],
    # Point 10
    [
        2860710426779608457334569506319606721823380279653117262373857444958848532006,
        1390846552016301495855136360351297463700036202880431397235275981413499580322
    ],
    # Point 11
    [
        2395624363109833935111082867579092089638282063493755655374369403894420657396,
        351237427147755677344067136337758392262982966921757802462075586166198965221
    ],
    # Point 12
    [
        1518817631841006315871038165514435660668372956425694825094659891110110998470,
        2435234811597428668734076452595083530950234466401981561306652881621340269965
    ],
    # Point 13
    [
        2173245854114081430013864960244839145346281378834121479101410821419573677603,
        2546798213917003006819050845641858786968858658397560158974242382076827691040
    ],
    # Point 14
    [
        2842565516483040219247288049386440051275065340592157409909273207335045943247,
        3243970369543480657564144388570283526584293743815525434693286186817417955980
    ],
    # Point 15
    [
        334001339911595275369567085510917903426590364565508070786916614629507192987,
        3111246400312591389547128607242178414610449977696648758380570718520342084022
    ],
    # Point 16
    [
        1524160182224703084171959692156493185929433834577885561910744542328224256855,
        1537801596806048756579645687819844574476915843680990392821821911338917834516
    ],
    # Point 17
    [
        1534228784878613855372285213913393282004680247144707529194564051083323737667,
        3521706376781514787959257460794337508069645724875214092054188903006114926236
    ],
    # Point 18
    [
        2578937995141029655393232141271255572790413762563128577126763729975116228193,
        17390356333795810120168422581001175036590566546824644641783194730252048211
    ],
    # Point 19
    [
        947940612979492942947148169286573131514814097313999984923945564630579515590,
        2308193393705297792974084886503909156992936885451139308263357445074155842124
    ],
    # Point 20
    [
        732404465937527082089939128149870791505934917542321234949662968808570781433,
        143709480454569956048931032102611838633822436488408778496842771196869318906
    ],
    # Point 21
    [
        241248627215637165874725355816367843299343644290443713521922700286140902436,
        3252553440660691138666231381716834106176440363202963142721270080741642531818
    ],
    # Point 22
    [
        3333115552336678637619322993761507811794447605372046548664704236825849321847,
        2074314011440265695926966409849756773065015399410882685131987099183343980472
    ],
    # Point 23
    [
        2828708362623152676836369441327395494506045083356924287447843608221054063061,
        107382801318187992328203770492115828936772008265759480771447426051158848300
    ],
    # Point 24
    [
        3093728769381682918281543022553646237541394965209383769732554106568421526166,
        3204173745255459543321323207111205642245664180117592291733272407863239345733
    ],
    # Point 25
    [
        2408410160653222627937499570601090771762354825212795227033567284727088044150,
        2304538566806563442614047090440785060491938762209719835685218901694719627776
    ],
    # Point 26
    [
        2758360715188072223623539313334284404194065029791792170224299872004682172868,
        1002646182229402950578888347706450598176482335256655665515308125378628073404
    ],
    # Point 27
    [
        2379910339855741683480364155463331175570260120162494489033888506779165916952,
        2649708833736663077287705299849077665696945338155198794587505679066706972556
    ],
    # Point 28
    [
        1176714920396664309204390318351093831295503091238549055894748705033779114462,
        715774545317274898026140714630411642171682270543528864055131586173491427672
    ],
    # Point 29
    [
        2785974441098456234843127330799770200846625265290625972155616950088804499059,
        307863489533861377687037248795744305150392367370243564208692826588510059533
    ],
    # Point 30
    [
        3127903794657845782054923624413460963746108626701051648823597412593664219443,
        2832400994360149010034695923237223654142501296305205824531678157494587069403
    ],
    # Point 31
    [
        1131830029003838132931634271160654858275272609594100638978880153740390535738,
        3607754722674459909791405256520586221653709952825470711876211792388292839610
    ],
    # Point 32
    [
        2759794674261780431984200708995704387783325908768350345798229435903528807938,
        1260417916396710926345525006943606967340884567049582926597956766543273788168
    ],
    # Point 33
    [
        2830057895043497782751868691208958763779500933641414034760294364554584648598,
        3148801330152002136119343944143478481505330324328753740340717562089558415415
    ],
    # Point 34
    [
        2506640265270419609137616465635205683276867684162736282412466285973014171890,
        517183264945713035190384665697926865674306942691511144684578407765174829225
    ],
    # Point 35
    [
        297135274309227547571122074141892368978567606416603548099453251059259457396,
        738308515934554491948011858951484620721581230541917718419817808748771885016
    ],
    # Point 36
    [
        3287710003144516108009450594509223314440628263909148329742349774812346409307,
        225177091586755328705836619671963709040245082813366263262829376695813391167
    ],
    # Point 37
    [
        1902667075164809149654789463437998238417922554649696913795190312096632954124,
        3609476325943007214468624874971854834826753291984136726633316509571578121273
    ],
    # Point 38
    [
        3452217073856686233854377494033704667278961088549888774623466171791636016755,
        2444544408047898094236889539040891081629098003972134793849574953018755818545
    ],
    # Point 39
    [
        2069167537346986671273731269107346759773110422380837126332493778223975152855,
        357269144817598369811221449775153952909196646906055962631273486250245080334
    ],
    # Point 40
    [
        1047243972090526803876529530618926456830431728514494419504365869386003201726,
        493385597033162791196594107722557650629404615534399757351633988473756315396
    ],
    # Point 41
    [
        965109286411904242713728581817485738428793211202426744037474223240067211186,
        2413690664561921424572393647761853376475215279589433231249258838213909974115
    ],
    # Point 42
    [
        1034828486658124322341241159997750207973283714015564270100039839265723642437,
        3320659525509256706388336697822491014651786050898707765488292630053240833630
    ],
    # Point 43
    [
        2924967592602073254569141793533465663326310402870978597207810641466195156731,
        2828397747600941786969312189630745459745605646639868710157419955197341205208
    ],
    # Point 44
    [
        1208329771806436797417016120088886878299172415075658275611114767604464163273,
        2810710693404583496584233908768327740199404051365142000873009254465681789118
    ],
    # Point 45
    [
        2187000042175732773516370724251479381096587891539947053664138571731476871402,
        746498189666538551392041580103908969319041062419800073057943031798594621183
    ],
    # Point 46
    [
        2000452964676707688903182602940959322690781577603915068119089450310903786954,
        866954387631286490641992457358203082174659959202834537990114265745821626191
    ],
    # Point 47
    [
        1296834309098498653963459206815713058813876510889656567958698555814791917906,
        900321515532234476515871433334993494171305935536543684417444011164731278279
    ],
    # Point 48
    [
        1595376832537627540806114085753076669172519984983967639366317789074759898235,
        1219266627855965397760533984052253611682860681989985974389624113620845749733
    ],
    # Point 49
    [
        1823240537897691300512000714094702014772232075125035605123065504505635249040,
        1906261986240090609038909222466712928329872469704972427112770233118685440655
    ],
    # Point 50
    [
        778303663772980866291056760213466667611301230393329301216572062540133184143,
        2984789228888160339109292850517099811453943454548552440328876677370962441196
    ],
    # Point 51
    [
        3543009119282959041814671650391719969699313481882590413207543576117841443934,
        1490213523215199378557197585333711645365263188010733339965078460230935145833
    ],
    # Point 52
    [
        1176236937487751405961855617527764992282992896230256112304717984169523263763,
        327501310716241925530534584357204203311238806558120970999031300336125027957
    ],
    # Point 53
    [
        2406374227501733859839714271591391036982988438954690468147627905682319529429,
        2498960794066678523664440543302013058525262611284856216226688049821146904878
    ],
    # Point 54
    [
        3452133497919418476271423809649290075304287340106989073706651714039300732642,
        1721794031770397703814538822528137647140579794352083932468384744314312603894
    ],
    # Point 55
    [
        1149850245936233973982137051189893468427998957468612707869248329754912343300,
        3458926667343838493950348154788263034977717528749131548957463567618227215963
    ],
    # Point 56
    [
        889697158819326131781010711389595245311511671705340221964679483759691059211,
        2019807322878676390755723975464224869137141739292295209065143377221547630036
    ],
    # Point 57
    [
        1115329342882491971826579323754611049286425400118842701871616630850493708107,
        279298782170669703031554266329450929495785208527313704344065678320374720785
    ],
    # Point 58
    [
        3365519876326833923487050935023315949049714901059255282163633136201965868269,
        1868260280532817409831058300719431634773697469228981331390874154636702517757
    ],
    # Point 59
    [
        2669519052792032403625707785046224942570603898100356640293648365762798392505,
        1740654081939116207510779753054238062700744649382792523869583125748991653229
    ],
    # Point 60
    [
        3121331648294614359396440970780137002689430823241383158647529355695088932901,
        873685066624425351999444458200994077868639460913455806504495956245857350007
    ],
    # Point 61
    [
        1816660828193076969492079690868149793376961857938776531133929200951688539889,
        1617163330180274180907112309026652344859788476549850480902966972316617122251
    ],
    # Point 62
    [
        928998762106806361096934313135623561544110643422813945289044484271228303836,
        464078854784700975668790446344005332658112186605529977536203111266829995975
    ],
    # Point 63
    [
        496484433760448456019075524089809339174015679144397089226817311073355526314,
        656343647912825200827812764729017634457244310809059156122299990679423100787
    ],
    # Point 64
    [
        1973676598953671410920434538501081964242302598763799105681937944844095305545,
        307489436917501023536717840176704363109773690206006513056594461780393179493
    ],
    # Point 65
    [
        518536787018692743767191710241721928752533989539898170372615978836875877432,
        2521626354257053998255710814293449754273786720271901759585107157901808273967
    ],
    # Point 66
    [
        690595468184470683559850269431813912957862648277508592008590933748732173747,
        2414429566032394919031053748274838227119236756361308391916397575422431579532
    ],
    # Point 67
    [
        2501095101472669025652293419986706422252484721018908950115277955062729551801,
        2787294359824056854441860940419185812333861607391901444904784313692077324784
    ],
    # Point 68
    [
        565118044580500186326118761527011487144705745596478022906701885062524158603,
        1799231527053210762358771329838631545632111862410291843983616507220396846052
    ],
    # Point 69
    [
        2037340835455495949556975891561839169602876578929015568690589435716642289270,
        2204387525434065888311157590483645040393870259860783204107223503007512510657
    ],
    # Point 70
    [
        2114937389277866993631127029230629118622631637448671765297876516930885448024,
        2772043872341063054220063825377798998299638741683281348998984204361894484463
    ],
    # Point 71
    [
        2097763236780897995115236415009286780722416534493059040644518024665003224715,
        2246556465712181592290422124919768779861225704408240007042932086214236197576
    ],
    # Point 72
    [
        3612119898822167069923931382556535386023574823466693257258182923730749602297,
        1269484610898538742657592460359658026176515519847024771198089933933954376158
    ],
    # Point 73
    [
        2881403268965266082547256964340568575654154178897275699709021163679539118655,
        1692819601432103623771042884269589390667189502599274435132350636867812310182
    ],
    # Point 74
    [
        750328371578183028452365126719312491229205795053566378454173411358094968605,
        953119186030327873981560224892058145045695472203493861081607133113834466378
    ],
    # Point 75
    [
        1656613311827787565035393466226110392419398195273172946657205368665450125099,
        2599745208280264384426758693760932474903320975443399225749144566172064401743
    ],
    # Point 76
    [
        2103692960985198293421966097241235578982164940176248129325331384077838061492,
        2570917734334329081039835855157625956461983506342767455507599344910133039387
    ],
    # Point 77
    [
        2956028884218562660581192985661469944972780357808337397013249554146206921192,
        408046758724714924414144046633476879802492779243354079741111917699605101737
    ],
    # Point 78
    [
        3295092543885183250245242131201657515391353210344574951962581116320755471573,
        1642807297265426717090166824916187234878363764999511552230372565887780637331
    ],
    # Point 79
    [
        3254747955211938731592559910914052760563649051803026767692046312174361324755,
        2597825541939769956115552787003343561035903289305000309435219987085455364052
    ],
    # Point 80
    [
        3061661576103456171574781131851984681727274357576590194413976242212020548895,
        1440946704104779823819051619396174008908467766221900978049401983321224347705
    ],
    # Point 81
    [
        838962129372725157269649943170983294581294061955271030939039912615696392969,
        2450855656904900531871678154573620082208900269187857841648756800522172293828
    ],
    # Point 82
    [
        623738578803750870859101112646088321855359403665383400994605481921028955581,
        1896987617779463068695767102228909909503881877404532152457554106592081120284
    ],
    # Point 83
    [
        3005336317328034100451063789097066979058288244531776915568829475740707033442,
        589659290793751995469380634546964377934517395448274738900772252627065284531
    ],
    # Point 84
    [
        12756189276497641079437863756137709474617047416617345367587373008165663758,
        1456142055978131072821045695636502275738045623685201320945241755292775664199
    ],
    # Point 85
    [
        1074674018821399880635425421583189259497571069746227839865670725436462244312,
        258858007368753107323242423300483485125794748975129950895267988132082308316
    ],
    # Point 86
    [
        681655034855073789847960596245322342285304909895796912572444021565696961022,
        2638585878119722820634387321875125243576892120356441191562743859796708349183
    ],
    # Point 87
    [
        484275861089119330366419813397313284916585101030604880621077715936286046362,
        2124340832207188633301820498272014794490866326891190193431359618065899307375
    ],
    # Point 88
    [
        405073150800337564971044639647327667948449004749665061152270060911349262451,
        1489771173602690638325396124433593050299556632624187628464627170731054511183
    ],
    # Point 89
    [
        2210274362697653963013276763896406028937726941229800687802476566182252928069,
        107281585620564596853732679859399446219714819235699352412476509704530753455
    ],
    # Point 90
    [
        1574843453768695165378209623495036727403155857878058624836922271817659867629,
        1555661183633642518402202300513733784743599394430116656383692711334768895734
    ],
    # Point 91
    [
        1123478630620218654285047429952065588412730975530361457071991777237712271756,
        2829567770920061439901039508116248775591132699709271161323340183772358690173
    ],
    # Point 92
    [
        1297650053639848975729187455845252204377426797153455899043246280172874099679,
        1368877225005672215217218872501867910626338344551878492763876596080463242259
    ],
    # Point 93
    [
        1370690034945541589206390781179695998551445194688862467131056389583582009970,
        1470539777067742221259042319802797839837448440044303811384116671245122402709
    ],
    # Point 94
    [
        3447187626984579154758815357460309989835728867823525757738362796350869385148,
        1816603979655684111669599224323721980301208636016613170580056711560881185458
    ],
    # Point 95
    [
        1813653163931885994109909806517422543930671118466754170167858925831571853970,
        3512341620174737184060311796746868634824078847254277831432645720920236439319
    ],
    # Point 96
    [
        2837307695083915103816975903131537789416753154015497312646069123780420491714,
        616619065833574133353826959462642204697394233876988991826103321230494864299
    ],
    # Point 97
    [
        594079125176886234216350989657852431152571525526195525372802362637040396383,
        2494644159641327263522333201651180948727022160625648361761185979144016156268
    ],
    # Point 98
    [
        2908396604150117877413275805593843594741970566352971841958566678954509739722,
        2270651079544400929734484036612745055500450526594372099549710701035274374884
    ],
    # Point 99
    [
        2678766929120334020289731872716504689707050034449508844312788171212235149009,
        335161156418784138664067328871308180390826302690183885244799298812600140579
    ],
    # Point 100
    [
        292866251242750359983852405638782648443335655395113648998608114038199112084,
        1929874131411396072089047462553509072816290408149385625319723159940078151305
    ],
    # Point 101
    [
        882230982554387611436849430391722624915254936568405968528170702860016504332,
        212032938028459898975134792582247420939126124794435382098720034240512634047
    ],
    # Point 102
    [
        128726401362994700814735301317860445928097536803417431852613367962589785439,
        3394124118935926464118252583967031473364357246179309645829616988941527947171
    ],
    # Point 103
    [
        677401161940040406778133733501716798305847724216576059351439033320244262845,
        2925999450717968641674678177839015248195288227966544952091044204990727381539
    ],
    # Point 104
    [
        2609307202957921769201454597723184920663265694086171832237331231605229071753,
        801185762689670517839772705471851009753066843170718046248101910206876036095
    ],
    # Point 105
    [
        3164184719276807654208802895852587431370308788690119771658913844464285523544,
        1905779810840212631464048113896329901522020622508861085333684930860131307278
    ],
    # Point 106
    [
        3611134164349757211212839193742321198628214417127680099335976437205997336534,
        2043780132560451089266915016427409559115509465273768103961201197432849551860
    ],
    # Point 107
    [
        674219880578998785256251799630500124321523321851449394348048261225376968813,
        3482911053866603432328977995361936638192865211341332440041477929097847986703
    ],
    # Point 108
    [
        3592898179794583311559546383565181628347625484079136119992096748458485223135,
        1465170880570843353446345695255388397672185811127330686304727767842553737080
    ],
    # Point 109
    [
        3479945591612641094508473900775458017345694655844890750906112888442669167437,
        3101936119331166017640859304880796239643688879875971179134677606262220157899
    ],
    # Point 110
    [
        1109415449398025759620102870831886622665877707210305893342279346428768457000,
        2860907454930708330476655483302818728978205359193672814876717458325223426655
    ],
    # Point 111
    [
        1357688207483205144399854674655145367528198873070486160807161516476844171794,
        2883341787687489538845947867713953817206085374003322509387259371280461173550
    ],
    # Point 112
    [
        2673153466150226365693822405439428986034577351717746967078667507408831331822,
        1711608722888314089357865502727953201489434753448475578858737527005192231458
    ],
    # Point 113
    [
        3399600989769963316575978481506459307955666332477901574428783938231920315833,
        3215591135790328619011904119580811201910745729655431204459208397816583809934
    ],
    # Point 114
    [
        1836471948074401070182493369353230908796463402812051721703561360825727986274,
        2080945706738209357213401773997996954868066166149050730738271792162977075010
    ],
    # Point 115
    [
        3078673344420931157936045314816499193943345153816528362806332351627801597029,
        1525425884468796152026606689861526369646610285280224319617687192867257228599
    ],
    # Point 116
    [
        2722661126018430265331502523339121563282558062510457654064467493725828237046,
        2961950709147303512642570304801930511214999580227551995337732709133755475031
    ],
    # Point 117
    [
        3274644392893639165667150492068461730297126947445956777112794513023991125188,
        2045331969496016255571307687320013551853048491733214352646441341466617604859
    ],
    # Point 118
    [
        112765822376634836986557327486952401905342511371567932656784212360129920193,
        2925784973032974919740053039088226660025084255241123579355659877189527261408
    ],
    # Point 119
    [
        1615139200617101600744409619536119151548135245881789111743749077087127202607,
        928952548463900597431429074097494026341638502402888819595959975139532597586
    ],
    # Point 120
    [
        89110835703618626006281975484745142479630710003689233432269611283359724860,
        215577133560624823939271084084157878843706221683942956847919314607432159969
    ],
    # Point 121
    [
        2365204845648678418296386461366871427710672197784591168077970521383279482418,
        1305956795685348559654727794862561316677393382417655218949059817923691390961
    ],
    # Point 122
    [
        3079404798552502156907780297645909071656015399012681371402409463283987518254,
        21056707131743755971547625076568417377953234492785298586731786122687871587
    ],
    # Point 123
    [
        1774615721844036510130640283396354163953067525827829514432813052928446640946,
        2335149358230730291686085189834918003837685389648150105141235796252419309479
    ],
    # Point 124
    [
        1735808336641971303276438949279976616427622212845904655791080520595464040270,
        1731419497051910986191800745158520013128509429166504524452212426369487243072
    ],
    # Point 125
    [
        225628732048332665517140883504098234968194122687532130198116739739190659914,
        2967548981364742052624681942465301778302189310173531702492567780724033172480
    ],
    # Point 126
    [
        799750724987433962024178782345988625264638811940430837962580781131993819643,
        2706844911451851414869588131946375233343117270234616506423955430971490523817
    ],
    # Point 127
    [
        1369724618979165159567545620227678034464433354639639473366228046556595024708,
        2336720505293481339154253277307615910867992206313138581663759107186258146704
    ],
    # Point 128
    [
        1930319710428527822612172469423758994346239585108798378474140896733181974186,
        3075715260783582884087648822116793974103741019719484227525273088977328650560
    ],
    # Point 129
    [
        3338564282673470966018775402725903223528182579868287010100527892104759349598,
        3420593956586273983490728381161913171223107153319939485895365605089451302873
    ],
    # Point 130
    [
        3555800392979470758767025620764223025989211483193054579480906006330657301837,
        2149899957029896266930433713982567969321434161670385808908337955713550175074
    ],
    # Point 131
    [
        3608545457332454869249792272060591549043786202385519868035962077469064609868,
        2809440208316315053241747840271233428261159310708153434099156262944856645508
    ],
    # Point 132
    [
        3322687396347671973732888070910250198991075315814763746941655084877070735058,
        832722278416792540687431048542953362405174329235971097088928697230453072453
    ],
    # Point 133
    [
        3256622670111196871124104758094097761744096984947383503745643093253708235118,
        978374695622574912744133217293321822318821008760942454268417456141195625584
    ],
    # Point 134
    [
        3410173130373258134073085888536026114751965010082957684030563699696697480724,
        1029778749451237919869173468746897632364581346265567722171293156697958069877
    ],
    # Point 135
    [
        3112433780585229726581053697334217985356658602483885980524816220344484038215,
        2532342168888613388980558686859546650509221859779222781594186523997684356788
    ],
    # Point 136
    [
        2105373184300453833566715269278756869308617438842998862447898598873739219726,
        877369785681960743494801702556244962845285506808792672979162666273085193389
    ],
    # Point 137
    [
        1393232346062500558436496118495653473949473378263920202909352539047530421805,
        2756127133762923853208501814856325859087297216739373809908612188013181865996
    ],
    # Point 138
    [
        2602735208672053198262611186569615211175565049926056251480233572878547833479,
        629329025417775185892796948300727047077553416972749774530835029538350502253
    ],
    # Point 139
    [
        1793674060552460299974233062088263069538015472516735538751555695772239138820,
        3267910293235826685471049883722469455862230494501330393412138559038075359794
    ],
    # Point 140
    [
        86863311610097694600007716574788775452468848027297474155593683107676444091,
        2437707467955141280580805831659061124536906723244797886865002980932492722630
    ],
    # Point 141
    [
        647853547298757687427688341299451732092383134491816678870980494283372695378,
        3617636854438826076469516140770697015113683007543372219324291693845766252558
    ],
    # Point 142
    [
        3334781490544017130581236435947958883590529475501049503331616858692678672100,
        1524104441388820711776621309003922630015731846383839927647934980171536936944
    ],
    # Point 143
    [
        1706920492017425179811478489658749041569247255320747028220786202351882167016,
        3136062931779844207701097197470225751864670973511824570767144629934893764829
    ],
    # Point 144
    [
        149961882640494348338043440935347934018050992098250101342463562074704074105,
        3512185327682078074777552971488882847736861539286017805546782388407073599152
    ],
    # Point 145
    [
        370860151698809780775659878430714854391039795566897134502189484720213964480,
        1238632390866429469777130064298502868565198081327737370254478336416980048965
    ],
    # Point 146
    [
        1282856472050108295483684218758047396436543346709509434400652555424465185837,
        3192157841056717224043634359360155098877589892941349993757962372268962797115
    ],
    # Point 147
    [
        3312829654231446830533616425871987858809512713259532177921343043407846981843,
        1806976906510042164961209222220236480094335196359899499152673663644589005295
    ],
    # Point 148
    [
        2826214476236947463134060188026701900955812519597178470627224598830931756638,
        1580208692732193723402036455390144043645806993218896764366725410799716087870
    ],
    # Point 149
    [
        379282466405240907198946408283110293887947304133389197401888303636683398267,
        2678326696284237155462064013317839501356719176588712513572353629324338176024
    ],
    # Point 150
    [
        523694191683203858486629087773330056719704186407500237062037916699142935895,
        2926557820959194747499923406515961933437184756076777735860240549085691053587
    ],
    # Point 151
    [
        124833202191020085496726895079225667003902078587119506095688146305802394652,
        3363531045637590226091127058344713074476460386293564329053575414302767346399
    ],
    # Point 152
    [
        2143651374532047414518845091756289685497664604612574318922876963772765730070,
        2673827034448835877302891179434422590334329367577351180190722501245625474345
    ],
    # Point 153
    [
        3221138751067425577747344145841964056907436939401545122534796814786108536883,
        235336175612617006468583569743134666841147774340073069013500151038053147462
    ],
    # Point 154
    [
        2555268812438549803835155012590418157639496654385486677760162898546595196513,
        1689750620936872465271905664884810894356966245587199342495604460756806777168
    ],
    # Point 155
    [
        625234954128220194452646182586699463591457452260757480259168774898052708673,
        213161676086201716193087398992571428821719377385651036018131821081133441051
    ],
    # Point 156
    [
        791204612818253360042670315855828265280744396446868065071639490833059389857,
        2903319472504514375570923883911935291656049846866663158923319947614657595965
    ],
    # Point 157
    [
        2454646497469354145786043440836113873410753626627793200029667058037294177092,
        2032912288570051024788875629005185779516597292453270591316074924761292028478
    ],
    # Point 158
    [
        2123337906329005118437052559658178011321855724007242277348144379266185921681,
        1894503378078529242131889602767919022671882244815906977803914704575270961364
    ],
    # Point 159
    [
        3602877859331983834496856242375420741994478431198393391854598373337944528390,
        1390248307806555980791681315101366407220742869690031661994109003230157894293
    ],
    # Point 160
    [
        639878381660983183381027433798087557736798886846049125326586828176785833470,
        3512419367912974372084649665826686824136068377404083433804922599142564888100
    ],
    # Point 161
    [
        1419134474578125103135604337269063811149389272963545586390539000069337598859,
        2235806112698740444007125277529836633381483234992038997663439878202987160165
    ],
    # Point 162
    [
        2778935883893248105666429190432349575416381537333107318387561120528861164061,
        1077278765722002922040368598422352116268480578772186030121792709039469085744
    ],
    # Point 163
    [
        428120812125473710465911539814876147732404851270862105382572167865288414733,
        311433631492674653227552598028197969484982737235311408621797869297871619494
    ],
    # Point 164
    [
        2952060790673513881810338872881675262252364545105524564508325071871367391468,
        3582199809541312286609332154241682748678754599041344486017973240874423950806
    ],
    # Point 165
    [
        1594461313084220822848406979098581830091616974334911374972620995310916825614,
        2807125397722833979284621487977999302186252215199452982876117209095859541679
    ],
    # Point 166
    [
        2043845413859332839989544551581949027414436310630598302726839258465898602603,
        1493460761394315567854883351837738680253927509880345067100858649883130457048
    ],
    # Point 167
    [
        910520306205610055407037560562219297599712042011958124271729124108713600122,
        1227332044591912072232756174484900317585931037443282067667157281800895006658
    ],
    # Point 168
    [
        1356322905904034407802797063629117404975010366322135572201704229186917875805,
        3062811278605169224008088325523606193685397687377873754697372903028059871958
    ],
    # Point 169
    [
        2651699680375521157731474794703697878196552894539932179312542308190248741615,
        1374999585439430684113300998459982464172009456194373596393318069525504982141
    ],
    # Point 170
    [
        2478956707907870604028063666882128463565422187569850243079631251653021026113,
        3484420957530723200820826205205389208856700316444106810018542093549855044781
    ],
    # Point 171
    [
        2745165789654622430617796031383732860380537410258722201878555322390065895409,
        1389786264162289064932319984048404041828181018706839586582409596900469763316
    ],
    # Point 172
    [
        792291068607630837524967871082697288161825884871154205347723150298096233265,
        1595885520235983259847467303703354388143203603602941324268342974672349807911
    ],
    # Point 173
    [
        1112766696158267198974840537128095637678660084973877593826070735478819877428,
        76854025577946938851193238773961903814332442336300641590764677722879845665
    ],
    # Point 174
    [
        3075088147214758449280318679771364592694228314680731955170139149431172226453,
        2631464825354322427832325664266556982858783834009349057603625173618876560686
    ],
    # Point 175
    [
        1946952991061874087036397224151139450490763292883750208451596293164980017180,
        1671486844817988227846350440864329091397847162425205354534975696550529649006
    ],
    # Point 176
    [
        447922002514491195056340638904274303849743543434622916451489369322819570022,
        481989665314939062190810517257104327416911189393567287995442516666694890745
    ],
    # Point 177
    [
        278768424991728679375985793004023299002069942702077846697446381167229872879,
        2117939832550233574127330090850877444733498561141023361942969078992294709841
    ],
    # Point 178
    [
        3216273780587845885344648641198104357960391646838456530374473185745790254775,
        3606237386675957259713749411947060068172141797816584221362457562749070134457
    ],
    # Point 179
    [
        888490252135075821787230358754699355629649708262317489940736076372880196421,
        2243899191640238208431440104126936619623401575061085948377697882800556601532
    ],
    # Point 180
    [
        1748762228708691375443278014066210232528543730943854135660867476022163374357,
        299810809101280072373711346937892828549469075660577914238588790523849116964
    ],
    # Point 181
    [
        21800463980443581727936921323539002523916110909487141095813330024439604509,
        3239991592162948599965263758537867210199504881270279333333530879723254864285
    ],
    # Point 182
    [
        1945649262091085266248324326387300230209483523911852369537103537534602188669,
        937547850790372496342721899405171497997439341142225383636485893081045476840
    ],
    # Point 183
    [
        95187198852190497553925369717104578448538072022660253488035756790745062479,
        3284691659350683572361562338651440251050266476442725062173141352883841793890
    ],
    # Point 184
    [
        396966715395293979183022035167233963473677021753099328784772352776439798275,
        1613322234499535439350563907086596802838800251144492804438492852751836971863
    ],
    # Point 185
    [
        1705843197146248589209974041619858441399461896194255757072890762703413482026,
        2709234803093296173390529287307769438552461179797518815269401286400797214943
    ],
    # Point 186
    [
        965896257227883986820160011629505229958129089095279852981573428580834882124,
        3222878455111086494470662906288505024631219103956585024274050126506278071618
    ],
    # Point 187
    [
        1711062768895650467512736187912681238407905324392544748841566987114959619940,
        2037166002293356114375846587992164902616900087753130705770148512236761109532
    ],
    # Point 188
    [
        306929171824313514409556697011428394218011837518848517597157431560368406919,
        2733907887575749650664983471979960087709811489243842872308868788028064963544
    ],
    # Point 189
    [
        1589132075979748817708848065945386431745143428233530475552120730272187989177,
        3479574566456289934918449243936076329515058364276769923171744108995406563734
    ],
    # Point 190
    [
        535088375724656896741944948092293887713409890408387277644439471611811707698,
        3084839991780046496389632054225148955101489706660124944353740712683200220129
    ],
    # Point 191
    [
        1108714469400502294909191174424037717245383586375174474928489701713698780203,
        344696096736515166863459054453204973598183407079213029580530012456358476055
    ],
    # Point 192
    [
        1896541196944951993777265586048099398652846183460110390523151621587553084390,
        1356944636529832014079353150870395726873584547194854259003641654476043751831
    ],
    # Point 193
    [
        2129740212445659709473295068445927295211143686808997136843204790705829600051,
        2784093412242244048858451658511978494505560368170364505963748965317959330652
    ],
    # Point 194
    [
        1164682312446525913981569213875150029132760939832308651498251601400403129032,
        860011516352836343688401715896426496333552023448545234232950198907527747215
    ],
    # Point 195
    [
        403381603306414312665420204496598046512017134030800187206579847445734886844,
        156710329648174386978898329138661964114318418114565494873287202679709752521
    ],
    # Point 196
    [
        3612709524322508414252878964415432233546157461869758422797096779080105910197,
        3298597797713539922720249912653326762917459398002362406667649739024691730641
    ],
    # Point 197
    [
        2788472028266807168790808585452088947945831098822807970786023663768554965883,
        780984533356516602828788864429847085423068302018929746266555371946539918101
    ],
    # Point 198
    [
        765015221711443098273066494715116075624315673921356068577773696969663768888,
        121864134634742875401471744901077698759842590065938894637311780483786803739
    ],
    # Point 199
    [
        3420458059929261250134488209708428351089317850483628650712157545902459535082,
        2753073224523413466263788479220930266258909876418753081552150110011967761473
    ],
    # Point 200
    [
        2435788601301668445647253094872163056944118800775256416712610409880768679053,
        600038247016283378097972299409314284965737590535869850167688589980357128171
    ],
    # Point 201
    [
        2791234127851217827076638673185921990434565258934782489657649399234080946948,
        3019532625505810270756207292319968517034464214472035802893765165728566407791
    ],
    # Point 202
    [
        2175512767988966931157181387193147869682253002700484615343260272758293076239,
        16356925783563920024655061104076219675967060212474163352137306664035714196
    ],
    # Point 203
    [
        2346289056582359849501003989438672266264448907419687867675159268542148069281,
        269429309748271385175467663457270641975914217681440684037010041835530573698
    ],
    # Point 204
    [
        481679002404926691230990214906065876613510532429501667509718578731645569407,
        1609976879746739928846288345159176310170130379856291476257183396230103110555
    ],
    # Point 205
    [
        2127782061956380596600761098774414382531840909564578638354721422890231607858,
        3522660228464874209807741153414518456209790498657511195587886434205303653276
    ],
    # Point 206
    [
        2990749966959304578563050621982841125682975201749885210174805380941485460083,
        295197603441351883186074553477194964532333406546643184464952640061744781463
    ],
    # Point 207
    [
        322299859114885008311771586431338392030172898629995798709098486233393241698,
        1023285551085384033485966778701460844235475326250602612915962425374866217237
    ],
    # Point 208
    [
        2679886206461898569320731641611496876582297592825799115233896892980598546123,
        3099565537546363902378775008459983997262715254411954165424270988571981464521
    ],
    # Point 209
    [
        853528159824941445672647399048964399831359191507493106790462832690982526176,
        1009640753029626140011297690792696405115462988587033910421277684043461588633
    ],
    # Point 210
    [
        1303674320335969124745880365084447847319437106063642511200542633107159295205,
        862053741658449155711084470286087651524720201941852653377417774320602998882
    ],
    # Point 211
    [
        371784976647836509603140476112794524387140033126839183825485397106022337443,
        1481126947243599849498136670060476522501192641446886664638431717153471858730
    ],
    # Point 212
    [
        256524228763970643322523560381608580385109852183329255389135850583181280611,
        406062519770964392170499110443173965524033961539587233636744514155485982986
    ],
    # Point 213
    [
        889909761640899390466461648537512393214660407373609451150870536404743826631,
        3579579432590016439918468051553122806010260839218529712227712227008716479453
    ],
    # Point 214
    [
        2181687776535382366933204874050926043644394510983340241902960182125931413775,
        125591469249575554746765789850870005842434420699124766244689384267560349454
    ],
    # Point 215
    [
        1698011648746714871368937594549801676987990963546029514109897028714017239145,
        2032238188811755521211420251330988300583305301151292725000783151183349336764
    ],
    # Point 216
    [
        207686199415566734810376310722982179068617367123996792470313948717972567639,
        1457942055660330932304294699096717861622662715626699977446009835743129689987
    ],
    # Point 217
    [
        732258411798183046441278957122759122697038828507788948928154704288224686840,
        2612299176220286719934749375400756907183274870137646747294920834312868644617
    ],
    # Point 218
    [
        1131610047798062548492567521656272602549897300746434874306725974344582031445,
        592276015836506844762700749171355258254203250155822561654862572344939966418
    ],
    # Point 219
    [
        1683203479448902722167828838268483614879733285176640956474769817134838920079,
        2990934852576563000604264577641206566403815930150479384314858100664762791309
    ],
    # Point 220
    [
        3379046363093840121427219819819164110884408212445336400953102193400631404907,
        3581767823598790218171818955173138326266037759069958949236204540729167542495
    ],
    # Point 221
    [
        267147147550523725868561003543093307186644052136871409944613118661005584614,
        1306549083362239169609006162611383775071361663461903546405449470601023271459
    ],
    # Point 222
    [
        296975912955049993838036596802334313092629826214334467025699377929310754375,
        1563707217733470474074970856533625421700727823760061087588764083345926207730
    ],
    # Point 223
    [
        409930698864338128894354352383270205190831536703476012076004429065058122460,
        810813209917474447569624498205572650260997215620628649252215243057189717098
    ],
    # Point 224
    [
        1244080118151222628554430592856097691345343883216811606005263269357031069918,
        3112961342564635769384393489844295061472524432493301559668801711930497029521
    ],
    # Point 225
    [
        3287905561524106163037657312076054800525947413789669708058413492038554328847,
        2950266460046239577741220775173597014955783375111361479081038783371923101261
    ],
    # Point 226
    [
        1834667074444753359896291977244884324984125181165619220523638440982002878973,
        1028938841439025536907121844571940895060940730436245288628559554616030756654
    ],
    # Point 227
    [
        2696579144808608214357559333220835033277874753649087677547926288655864862396,
        1205667596625326964488748126939548850792621845142605787353435428502428194722
    ],
    # Point 228
    [
        2681502303973249854884858344399536104286034851010362500805472440066210957701,
        2090624297500029615299510863468795665118802449870439334493020091696427901315
    ],
    # Point 229
    [
        1353314499186573664458206377062562808249080943135426913783009658343962961481,
        2765083962822990885404819840064727313062737767044627137615530427213920746301
    ],
    # Point 230
    [
        418493206714369123577433462079076010029158131200185602134250755432510923649,
        707998386543299716720343491204719022813222859618895609544390001004782644320
    ],
    # Point 231
    [
        994749436490026363483216765171719719813756635373513071896945407046466009916,
        3542023359278349542922434792313919575183783573969934645527389879728870323439
    ],
    # Point 232
    [
        1890008117079085184019219906457544800392678580280084811260498224586609070286,
        530233764155506684122011374141421351751148778529665626269052967779624308325
    ],
    # Point 233
    [
        1380484666773413147984807138259355829485624671596401959499503325097178446404,
        2703143567161792821055257608672826415980743659971254233408855036509811875962
    ],
    # Point 234
    [
        2143881856351418759124748482049358565778910428733836748398777699149555891034,
        2186504045350479968631256614333785165240148508469904761831572298072325147795
    ],
    # Point 235
    [
        2794147613012298673104841054632587797837325721650333247952170883643570500710,
        2613093490820907283519815366146280477230890436771830509953858178043843459008
    ],
    # Point 236
    [
        2625979094712716243539648580331695634041650060241725094563615224537054056479,
        145143322058807873791926380354826174760141531075716146087195666113341406100
    ],
    # Point 237
    [
        2912042742810958222559628370002186243459717464446177149380721928196350211880,
        1095311779741249761721276459609161253222688862762095992035499286908387724976
    ],
    # Point 238
    [
        1779688139950750136680613010527778524901137919784933323807835083178662865397,
        2443673470483539351187560062972650745287069240410986822268053157528350814229
    ],
    # Point 239
    [
        2131257578483960220347030216154712350782825143774667810440672905625819556803,
        868491622632592338574614600558827126185061061280839427086037749491272636942
    ],
    # Point 240
    [
        2219005280109778946483442325473674751018277532855518690831693876689847358912,
        268228073082292114390894552479318098546823436290210690954657472261887508233
    ],
    # Point 241
    [
        2467777871565605588821089206361725030593121231139954405293743820019316429337,
        2069991336503010889436721322920702620510647146193316568814112316083040831176
    ],
    # Point 242
    [
        3577501695097063979000880929536422727582550178446643147830010270693854635348,
        2035294884291881522017348441414523234930446764971044277218808172917534058938
    ],
    # Point 243
    [
        2916007638012715951040881085223392656327753091743451984926427831539302440694,
        101999113634064710169079402836107323839592545174054596535848670931124794072
    ],
    # Point 244
    [
        2824482828379328312126109430912691348039395134484392469690037535472985287979,
        170123149569960330410734287368175015043768931496132108203420592659991682297
    ],
    # Point 245
    [
        1722717317273017311710033441508078253294103515222910371014974460548425614659,
        2455794982320624552496521720819953146480298894982220570859668985011878438440
    ],
    # Point 246
    [
        3323332844428319232630841298737492488606773387534937061908049192786445054249,
        2775452603532873679877923100539353685218185462328621498382613902225794012998
    ],
    # Point 247
    [
        1608012153975591201510431671483571431120513181059080848126129285407754084748,
        575592304166370707508545110070168578909474113291472127326388774685581172878
    ],
    # Point 248
    [
        916809345825028426832118427347317839178426151786124666474024597549724310957,
        3069555112506328035675763181932227894553434381085323151827207060709357462248
    ],
    # Point 249
    [
        153560760075250381766471501226441998688409013753252062800770032940893580349,
        2329038724186047986576327612748573076822768420981449905843361105210433443270
    ],
    # Point 250
    [
        2251563274489750535117886426533222435294046428347329203627021249169616184184,
        1798716007562728905295480679789526322175868328062420237419143593021674992973
    ],
    # Point 251
    [
        1952032427782133959985228051054870623876234309599006856796795466237953231448,
        744413679445899225088843138289996934867918835619653321950444531036817070023
    ],
    # Point 252
    [
        3162883296795762041497700357918312017339509549159370543230518526626437112653,
        1148816493574468887215135074549621724232310091624566542087195747872792868322
    ],
    # Point 253
    [
        786950607934610388520508637842877731308927224203614303759337398330090790623,
        444134697710380413360573180457740543414390667171294106626775858829645857259
    ],
    # Point 254
    [
        2138414695194151160943305727036575959195309218611738193261179310511854807447,
        113410276730064486255102093846540133784865286929052426931474106396135072156
    ],
    # Point 255
    [
        955835104121335308947276399583596848959851821452355864667907221325383590383,
        1935683370537209806184243406809646867168041420482463925534831987536519170687
    ],
    # Point 256
    [
        1499611007946205543199170798196098786940176368383871138867689500928607330374,
        2662008410012406974490205380527854666032675717377005780162761284021647432331
    ],
    # Point 257
    [
        2335197826477933983066242217922654955176345813321200025173943441365679314150,
        86799141726517067858463816876244730494086420214168736349361077938664862865
    ],
    # Point 258
    [
        2426305297748003258516448191982872419574201776532744568583614742711471397997,
        611146900843862661160935598912412637915904741887617221933114742269852367033
    ],
    # Point 259
    [
        1819742747902080962279305391799448622733402573848283520339621821028260796959,
        1894241144684539746894260685967399165405614901992249187163143950195275701901
    ],
    # Point 260
    [
        1566900754533300858179807012858131246327928750222566819288909586499451206334,
        2323811598271524355017219639060977623543930469383254150460465078663134678714
    ],
    # Point 261
    [
        1338097767250711433700785616700918851742529208514529951106274243527927831096,
        3601290097662913510540208850467494388944371519879253105483940917906091319433
    ],
    # Point 262
    [
        1683076217460316609061101548674917172577600596732354862732552514637488814573,
        2586296790559369551539502725860235780473467857462493373020086667442440193461
    ],
    # Point 263
    [
        3470075416984304553645258515396988848402044843556043814143694549291509194436,
        1666299363887708992239894153878840011200424023864139235605837090808931067390
    ],
    # Point 264
    [
        129884650079435408471813606095297277059523238954518094473826756223429238429,
        913031838387203882010246435451325905809656720680281880669305438372695953289
    ],
    # Point 265
    [
        3445652480962486836667659474432628384578750077745289335336644514805586651762,
        1741653654983215120166402497338863916929176017304303902363120840611844416235
    ],
    # Point 266
    [
        1173074699967858342716736787366933102436976281324119440358211746283473098092,
        3075964035581410146694612776964161590283242001470153540218734715257792166291
    ],
    # Point 267
    [
        1948864707183825487572530934859230839519236819821721157111541446530257224135,
        798780108424505404488913172014962400148988458061505603829909122085722968572
    ],
    # Point 268
    [
        3165333849798411161138142302194551326502959074734249886012073955960267320358,
        2854077232678939262337800847761960471531706329482426572081757005793264065021
    ],
    # Point 269
    [
        584219684922011437746073096716853840728059302768805720402293458731947997988,
        2691605392627141392945611586058726186445966055416403501891746673585009447073
    ],
    # Point 270
    [
        264865088823397344079537851791331047852344700250947641609789815815437187715,
        856557814156118883640651140266045634237123586226962432863642966399740605873
    ],
    # Point 271
    [
        1212105529543873848411369707567547187480526619270372944387195134251016552437,
        2552579868998151139055870387891260255591250119487805856658511804923635744103
    ],
    # Point 272
    [
        2759929251220121311757096521396321905172783069804137943187241377410890848589,
        1013388642776766405334075600441854256934688539631486641630323046104523794325
    ],
    # Point 273
    [
        3435662243060467637677279408549422366191108299439077218684237876763341810879,
        1206100200764686560370450625743787352415337337047308087134628700539206972086
    ],
    # Point 274
    [
        1977901254287550894956728572957134897985203087357872251941076511047285452123,
        1346842642356348816775497637530312996348462152604627197529080983616576235485
    ],
    # Point 275
    [
        1581907638985290987975047412112008678916597048367684526184099730550194065415,
        2288246533671252346247687962179397967163408912494860510981460961024159618572
    ],
    # Point 276
    [
        3215377452673680185835021004830688268079390648010676635220128902519168416923,
        1674957009593589739638616939189211577318542927235942161494800623173476894918
    ],
    # Point 277
    [
        3396057617195027713159897957858092093258826926757827467732086865786377444102,
        2403568170323924513104032431512050355627094479417158474914772545814875796054
    ],
    # Point 278
    [
        325310856310207888841271598900176645709547071516271373679357299878055669525,
        2861677118910432905996905108378731982262901938718390134034663016688312343427
    ],
    # Point 279
    [
        1925427404573041560549638633971822727278056640694873177265388259055141273564,
        2149185931265263003264629477521934555446245963141224065368283592107464297049
    ],
    # Point 280
    [
        1057655004272797062633705695597766087036831552982842977913880603549380151466,
        2130130885627581719544847915036196574607634081790527579681856058518350163936
    ],
    # Point 281
    [
        1786242059890666469307365196518174814453782118901787482186686744245818012463,
        2172680482993759140271167348144713503721696709986572085951066664839388293484
    ],
    # Point 282
    [
        2592525455921742135918400168106149306210970009440868747852006912674191605906,
        2550305630907505809534995587257079662509793820536464892848197484572098781014
    ],
    # Point 283
    [
        111752568734708072011137681957171091740064310210630952635788677462490949489,
        1966538689680059826741582906363349945575114015419692615822155104740977191321
    ],
    # Point 284
    [
        2324264192758669920944928844116594735168711655659168025211571634463212989215,
        2453209181874565651016960427707879723586882840596638134526741863234420038217
    ],
    # Point 285
    [
        818792252748214652222203568101444114842946877275244081137505104552993989249,
        2471135473251293858404864644674805198948427457640609601515835463680395027066
    ],
    # Point 286
    [
        776167224210253175836285301928858826524230272765386107941590743597167238720,
        3044593275856778999572277625341930135050598088363464944610781758478552167560
    ],
    # Point 287
    [
        2767418361596469194389897577063980781767359707916121685125519618739970163355,
        1124183356341334924855702050560569148670124301541230516023323823985404910253
    ],
    # Point 288
    [
        3513158900447819618700445228863547036694626890925843610953740962149603482734,
        2038286698090839235054970774714871346106378670221757061557885786099548421055
    ],
    # Point 289
    [
        517681831514430710817158481088000571456636089484182444914961386383717794582,
        1459737506190708125961565377404508114648445797956698177580320945537417189767
    ],
    # Point 290
    [
        2764450063359771480330846034975350106048674448417446553801535244886068866892,
        2500955915434901122019038304617790171097079017113487693837548584032628559083
    ],
    # Point 291
    [
        3184601066099193053823632069416872853499121524829816523443698520118638972221,
        111399286855641690694757616558822271075634785548525857820633539322287438076
    ],
    # Point 292
    [
        1861764219607632476451968430680705159045765477029736548085454909942815526303,
        3542081125583459227861063385092240523576730790188055012978461087647652048846
    ],
    # Point 293
    [
        10925555246854055743289295413923076326390541878672074284471241830391529976,
        810379063403665716239985697021625834252465819699617633253170927366131373937
    ],
    # Point 294
    [
        1925469472110966024666451107813057200428670133173573112269655451746350245386,
        1187189363484828103108277567024110279560050728332792104397849042655830458502
    ],
    # Point 295
    [
        1257234032480175630185580604439948675879173824493927714083831311549585046766,
        482591378023150470327639933521764621888328430410377343971291074047537101431
    ],
    # Point 296
    [
        2334319993908953455700110484178707117214967972232088939662977870360647156970,
        2818056499399790981578195943345246458116384474394556164088380917912187593212
    ],
    # Point 297
    [
        1453145677148250112321822321443172335864030607730961070308740138762391252935,
        3617981792798631412887889951712686522258702128207981768326584469873932484754
    ],
    # Point 298
    [
        264643236147417159992044802699391039945632102423375233223220671619422214434,
        610904689309149986363589451581676922381464434446910426922817060056083567097
    ],
    # Point 299
    [
        2773555644105234303846021450759411618679442176305095821653566380427481880668,
        2878405667973852006171581845359598408350517329366546879570244783921286317021
    ],
    # Point 300
    [
        2380074631138752101437386328647668302433161481157298955599519485146473998414,
        2940162033501039253058405622329360778854888527422589401316007987697096499987
    ],
    # Point 301
    [
        59923324335814857005652966889729706976632643533439489239403033851211490829,
        3181196819190011787131540430610930324408745638588775047528706552833472475080
    ],
    # Point 302
    [
        1571134397970145634572604253962346713191790104259693653437624133884723196915,
        511309416166810662427969443722895543878733742083314900009440861143766415361
    ],
    # Point 303
    [
        21090530989878836908367190554625378531500191692603997969723554269923877778,
        2771500794785272828011587832172996564585508124740321638858260733779070073032
    ],
    # Point 304
    [
        621303564182234060808181503818404204870407855544326969616228975404966772646,
        1381758119149546152274589114806432955337739448745667222869629159555498152415
    ],
    # Point 305
    [
        1603367875109750844401808777605019545782079142993759227560886400939494569928,
        3404233473008527201696274593235213333767802823633271526617525914604458121747
    ],
    # Point 306
    [
        3064432839007969661251145008088305693584410819966794512614368597856219962482,
        783256745930834086288610539747908078655069214006352981421868494072213571354
    ],
    # Point 307
    [
        2573509260611834641929601495624663326040450806493971688424856342734838037808,
        489632329414366712473800098158402333281555035744201997032862455100685111530
    ],
    # Point 308
    [
        1373013110025567380060459077575726370083805340382038749245013725221282327457,
        2271658983436031571764113689216829854166985975189230813662757962593273370705
    ],
    # Point 309
    [
        243466876262712870310499646879826213360676861126171299065326838396697300684,
        891923608292171984769797750319491387015995834783589731015608767716778489152
    ],
    # Point 310
    [
        2035465927594189567864787276274121052811830838707542644166137070067107322500,
        2293243214098049976425980695256140756537564052456935637846524530699635529072
    ],
    # Point 311
    [
        1715507122267435124880907385699722499007841543359383748906967432836714601915,
        2065683622001523424317888964929493250974883654939917054448293842930286201120
    ],
    # Point 312
    [
        2906653642813167415863836383642871880050990532175816005542735996509246708445,
        2101103582375172516655999605681405804159432128657161521495199065707274548843
    ],
    # Point 313
    [
        1560478280364678701345899621740888632653158026800096320697331299727453323955,
        2502904681091262932533150924633878024793617322541538974642118205130709004124
    ],
    # Point 314
    [
        1088825136235742041556075285669369753699521218552343596173215811771470309575,
        607071558939135607706029375168245965172230512282049740495005044883485254652
    ],
    # Point 315
    [
        416480930348830698091647060484670913532953382502409400899099946640850762655,
        2303434329028515556374106529351629273202094072128674875449835104642893549223
    ],
    # Point 316
    [
        1059226326329269227798760274851746346121838934144866840722833084379215695718,
        455998255867283640545200132173274853754233138086189946906020858549998434504
    ],
    # Point 317
    [
        1024559718945017260657672873923464530437289768440141950557818820996778411842,
        525500033723589597309036453730301911712422803406229661029628208639589866511
    ],
    # Point 318
    [
        2056028306188984024699016201885443563164872865972667060670091877117616276834,
        1419412493706512914027360568510428136300835377049697326470468114560769950308
    ],
    # Point 319
    [
        2521038744059190227863027780309672155134248925803510182471085885871826328010,
        2055664921579551707407017847075753140537141245184993747243302270696485943484
    ],
    # Point 320
    [
        1408309654797092197568389828883985051397496347829594535681640019995307652445,
        295921513421790144469734685069951228414338437813405505294106756210992032229
    ],
    # Point 321
    [
        1987857595984681386153299845716030466354725651174836127615155461210837869564,
        2293923060372667346124288305276256569940238390418855305479173407955750665287
    ],
    # Point 322
    [
        1074973828105956295697455820943040985586724095278707830076756602555601108444,
        3326765437245957223406988059616777659852354773867298474672160569379624598430
    ],
    # Point 323
    [
        1401862061794147305806657568952279890802547970381675217693442582127912005310,
        910058274349373118447954573574441457656632333180366570053619401133150262813
    ],
    # Point 324
    [
        2040966475187373851921668684777109791068677257197750053913982531497273133975,
        1167958332666304570814202030094477634345363022473150543742806601986529818461
    ],
    # Point 325
    [
        2881780782119017791457583552000797082603415839437706575588805401515980505801,
        2436105237174666086889653702042028393653105027534224748338553775980791489395
    ],
    # Point 326
    [
        1138781660141971412207137170011812332951155719283266572057616562955205995829,
        2657768812194147024915418195050409322486415583242017023943729410483676474626
    ],
    # Point 327
    [
        88581112279530612334542943009705636136002388463681106693549082166685838725,
        3496134215297708121790719225608456452574651558469594407547800088961881026765
    ],
    # Point 328
    [
        866718519953191029204822844477480603275933535155329865978768093814160529674,
        2022882774094084071548678749116103222489874860976240925473298660635212244802
    ],
    # Point 329
    [
        1103918207045639319456460136379598726437052653753960546349780312287131158223,
        1656811459960430943611479537236804458740132078453755963357596576700576629867
    ],
    # Point 330
    [
        2975764785119134105842544511285384981490365867343400021422469912399500877645,
        2687980107817591862475555961986751017099827078208385723645417765552791682099
    ],
    # Point 331
    [
        2054447365318177209738241671190147649701574355450360479017715224292009927393,
        1227206940403531159772964107232373497220530020193348767638035040017379885984
    ],
    # Point 332
    [
        402275007431361887464920597581616397711484740464854159502779178788056390885,
        1547405786479003871142635515616266099578579586990668594451288428801472362903
    ],
    # Point 333
    [
        2669324117696876754084336282080783960314916540857113798726442554388023656184,
        3074286759765067223595900394644532377637168990646921851127828180794850850636
    ],
    # Point 334
    [
        611932396022950536967338459506782836623876614969030243077175645873783092390,
        2986433254570022449958119232739190557250941610456904564848292348906028792067
    ],
    # Point 335
    [
        1110995377995699045828083953623434494450657345505392977032896710538879544144,
        3071470793346350302357608763590610007478960895381257765814531991563057030742
    ],
    # Point 336
    [
        2191168535074842056167853224940102773478321048031820308130136731344529117475,
        492617323352024208418412531798559543092874332708570994021422823607454559418
    ],
    # Point 337
    [
        1818759115593575585308068448791508192789866090941451793170759417890828490762,
        1305353903124550364838683686338031038285043137449345518795766390174337151903
    ],
    # Point 338
    [
        2631013586413722723014078756848572110540232554858227410413816548047325168051,
        2105417412111265728359541491742019675861543959418319743611117424131871073867
    ],
    # Point 339
    [
        494722738667200879981866755759016615873180216451714847099458992922362500227,
        1539404447578224883291548288433633968332223396361092124453992010526489574088
    ],
    # Point 340
    [
        1894316435470914382555165707375744683572341270069865836107052559173764639667,
        401287370121559774698743821124544382770349508247396498174321596110198582372
    ],
    # Point 341
    [
        1339247525522496394127023115420380868431447741930632224270989291600289579235,
        2330930519705316142879600410372647788413471043363313385713997026124191817517
    ],
    # Point 342
    [
        2320587088454453474461645476206103420492539243459981382841070259500342411471,
        707303545980793210971675132996162637283200017126206538680628878370110521153
    ],
    # Point 343
    [
        2377659897024221375470644518744478788982138263672700674443630590978849683809,
        3419989952269036538781036113174387172326270380530270982346793780460729200034
    ],
    # Point 344
    [
        2687585515362755421896341880578567868284030156693703993329134509207013359293,
        550674138339341111775701426337380778844351792663711912206724163064378058172
    ],
    # Point 345
    [
        619785501193479957534515714310017569776352132000912157061487205381157886132,
        1961366910419378396302827972401933597848792446727660497590498798601343853897
    ],
    # Point 346
    [
        2960597928226130798805429646261618976240340007412692237798738046399566677924,
        3508695180344311906202946672427154710274134142520774461776498819979015518079
    ],
    # Point 347
    [
        2926849849449158589418504157622781316761588577631946629896933307400237548255,
        3579904677936943713540587614497052174139389714845927197988064028772422409729
    ],
    # Point 348
    [
        2528266877173878010055911786705258188545546534139599446181068037003246641972,
        2090593124885859667054468890302718556366617309852711480847196828672489780384
    ],
    # Point 349
    [
        2444375104485440204606531945078810145038148666393834678853843328800784491413,
        2715725794432857257355582195062001572910526811270194737205485553709223325149
    ],
    # Point 350
    [
        22830464908174189828089916657865484119153417213263588787115884234394820551,
        2144656372197073668726998695697011727390449826738494763726208492934675687351
    ],
    # Point 351
    [
        2160911736065509245304608365930348966695110267270046309451656634373627649798,
        1163682116033125825657519424156769471044453229066709940373641637423931934054
    ],
    # Point 352
    [
        3337375727076925923347860860990507186997043901018925752183704995009780982617,
        789849303430659746633537234664825369690245855962498730835768457501816445262
    ],
    # Point 353
    [
        2716386435720211080341482697862373973972358535390181213762877306777737012402,
        1694833211852186945995412154030088403536183890500755705683031155572812198349
    ],
    # Point 354
    [
        2068303401887779893147375033717840031634024130559056428854775490478246923099,
        1302558735633136858997628501160702103360976241643583615145118788605800501823
    ],
    # Point 355
    [
        2528669114399089536204487719847492540160633221112006566613245017377953815975,
        3355482321728480378876070603715444548564989647597270339584107783929482403385
    ],
    # Point 356
    [
        1261599618177618962793920186597687295419265824130061936332619302494768478919,
        2783617516834130711477034905360493329011706287809097673216506817763076782638
    ],
    # Point 357
    [
        2296010137652334615076906848600702206420819604705598933314103330038064507904,
        593137988508667983800537181778974626700843711375991890922024569808180330689
    ],
    # Point 358
    [
        3550068663997426488921976653382588625011435366616319009448120503817895378028,
        333410037907206817306890788780367628702748092247180262748072669817226553712
    ],
    # Point 359
    [
        1578244233650262393441190533726865755228496176869169339972883019206417143875,
        2916675240291132751272523072177820169167325640678555998767122677068069504203
    ],
    # Point 360
    [
        2578708307946151727285356080366654771256622596667386016883098096024764936468,
        3547149991717605187248264974055140267141465574101933313814496584854066409070
    ],
    # Point 361
    [
        1067242594064079501648168388172061910333397472745655832282853323030820063843,
        108409220808480307369448490727067533487994293376444700684037781053298403259
    ],
    # Point 362
    [
        1438879968873284678993516485008080871992105419269026450500135928583384168688,
        333856453999414929392413408589358932084193824353874579187651515313020359769
    ],
    # Point 363
    [
        2085247683945044480852971266898030909967072967111091473808832254928660354607,
        2485835628881711191910958556160457454778996828420985267633930125611726115768
    ],
    # Point 364
    [
        477210647966136763919276861800763093178095337893692383194424592690231940061,
        249607430987277999234526517540164575126654109544108544480054797746736570800
    ],
    # Point 365
    [
        3439303457066047146897968415062046665605853275226669283725228224973410585910,
        576124419653395914968187737099874519814103127209134795696921745172483058236
    ],
    # Point 366
    [
        3028687819239678122848199946542573863395992135514552484651611678970005763129,
        2961643823025691121513520662201781259179479037567198808346912150041025760642
    ],
    # Point 367
    [
        3217248534103588798939334232631337032410025788470581973981396764231465681047,
        2382487873308676654385098962584563887276844064402347832716704744043722784812
    ],
    # Point 368
    [
        70223145378785170243702578121178644986245368450401326703486231450287863627,
        566197969536520322901287947074318556204558945230303949390810423446802406323
    ],
    # Point 369
    [
        3028144136397350722039435806065376945342224221363467830775872476071042099596,
        167098690867154485139002287996988541908068352838119188548912894969546326088
    ],
    # Point 370
    [
        1424858530411014835161893358951895950005600021438253129735780882682252689593,
        2305727793424806539572292293130051301594968780927626275319782923070998204084
    ],
    # Point 371
    [
        2137513716516327603808109201538743935930903413061745351331773762548511760158,
        1642530299556920094344308735995008094003081457462443723760327041776469019076
    ],
    # Point 372
    [
        2170444911584390774802338541806841054793712556211735475250435550223474552592,
        925789261675057834371037875523035088704965828465840628994713637520457333016
    ],
    # Point 373
    [
        239299595833165228919005931278081722748571104921165506568868902567605074538,
        485001543376876278371961680415603784960370504830892419674368813289405424875
    ],
    # Point 374
    [
        3080380062043844759018736411849858262358110468668995639984779021951968636078,
        2402265611218391177266008066876605247210502592712781467199097469773462678225
    ],
    # Point 375
    [
        726523175548388386261502324171774291430220813407320118077006064537560392330,
        786330320941681238670628195289980168691286367143496676979339036480301999376
    ],
    # Point 376
    [
        527181411328890981971052946489613295601720332326053123212209359114463976205,
        2153641849366054831187204654204168306183349514724183599886856681068048360647
    ],
    # Point 377
    [
        548403912567710249138395852931702442214070304260935779684833978128636533986,
        1820119432165084967589110130985988930607430366654346658826186881340393135345
    ],
    # Point 378
    [
        1055707400443116102787479640936967686027177253722371245083270825233659393085,
        1529404944427212407459549740446357844894249706911152782301314430602619804108
    ],
    # Point 379
    [
        3604699563774018613013478662139866299897364136688436784910471089709564771121,
        1877420639173665439817870412707771026257151154196414247016132896387470215862
    ],
    # Point 380
    [
        1334227623025169197188407571635794051283637310231760303667085410581915700021,
        1949877078010470778680860969498171171122335730952599024624803418631307495103
    ],
    # Point 381
    [
        3308762084022080981421381628996649710517264452719086435874478919169368804715,
        2402101985509711398701847117755018203425777675996940000965112623957330145868
    ],
    # Point 382
    [
        1665881871958289138802712383541734953129067055326286239727041865486531283570,
        3616247644667366899175075134655397038478794588048970408476914992988017251161
    ],
    # Point 383
    [
        2112164335316897143532032199025725867588905166012009239598709182355280065515,
        2825402900866689367007140167090188180425426910788355395313762834688260248117
    ],
    # Point 384
    [
        634951525865404702868066023611980901349684561467873427882470721637495099919,
        2178647893306834053326446190201725650048611097288227403773599186740980976285
    ],
    # Point 385
    [
        1341178436815612054719172387245100541421209962514061177862693819245929984135,
        1326643103813011222249037873591741605099080649257821474786188634904101413693
    ],
    # Point 386
    [
        1928710057077228449920040314271488497108943704097705502064531376997670270931,
        2266181469128837281287656381761672050739367882500404480638892977272852366881
    ],
    # Point 387
    [
        969218608841843132346322324841729971529593954176078767277133720598489668357,
        606900183168454040777559974758602149603502324650244544303079399500690042393
    ],
    # Point 388
    [
        2013350832011494097843192023013584600183073420263235866273101164869312611708,
        90712660236563155479754789398598402903732977477056735001011271430022436372
    ],
    # Point 389
    [
        3396976507268771940572242446745957441443927281190120339106378150765794683243,
        2412741837818252081470894623640222254809923360460175760983381510548136273698
    ],
    # Point 390
    [
        3606409001635563285156761927226165887070229114178147857036216526058311335249,
        1092396833411428890667907446500502751825053988217814009934347833612745642070
    ],
    # Point 391
    [
        1544923824473254019116239003129558626125362616742425500116394033599505254529,
        1465349443371708061238467795142261954743713344644799596216285990321977000373
    ],
    # Point 392
    [
        113491804090467857612125750322844575213787440679203395630526874638303077885,
        2028057101479207102461777655354995420997496563459354054546268475793811643845
    ],
    # Point 393
    [
        1652495545845371778467883968680026022222422089600601509520876233591221298667,
        1257512680478734992352959448953843834930888651298716349936596227713642044718
    ],
    # Point 394
    [
        1735132339493184243340725542423753987254833174769560101474361526571946583351,
        27330540439335548628321946448059137005887875330678118281933391074303528644
    ],
    # Point 395
    [
        999589601024651596708840623565818878499651672244526787051482333844246243941,
        1556707544224102520772713942483754928174646286011090264336584778980967757013
    ],
    # Point 396
    [
        1681312560856804229526683984753830811943700510863269888887897515341932766251,
        2065757756192665992865056781757244443742379869237378116242523960469865631998
    ],
    # Point 397
    [
        2058951870735992982026605733702307208101813514180467857318656495202383185176,
        3268996299695136959341188422640393244547564085474313632107392993963324140014
    ],
    # Point 398
    [
        2056960676848885737798371134589584163780497279931334671919866051948581811168,
        1741359147160041371302807510240561900995865771279421888187249838945794238723
    ],
    # Point 399
    [
        1167002070266749840825005896490956016236165528302729567545471999112944906391,
        724716405138963198014997547695908810889048549156514080027596147160291370305
    ],
    # Point 400
    [
        717433242268160049163784137690479364638414455354853503549047874912074602102,
        1548748206365927633434472413810887260565959748266730133832127499425371516599
    ],
    # Point 401
    [
        1113770395880110291540688660582111108167550152891676896388447618267044770699,
        225614903467949057887693353344008462684737622787852941160491287904124662539
    ],
    # Point 402
    [
        1485058593675291436770632813229171213081600725926085342541850536046844108938,
        1793621954142096162709529585852653649155672217087744074142012644930653464937
    ],
    # Point 403
    [
        3476670695984120275482827092638881388770060638684248848714588194147006700081,
        1886524232365250879956678425943479251575532912879489640410209691903853633501
    ],
    # Point 404
    [
        78942502761918568770028495237440346726648682399909104284710887733399086106,
        2352329060006211734866796061368085624251562468004096360671974444953215839619
    ],
    # Point 405
    [
        813411306209308549231686755344288448950826770557611647490856063401538266082,
        388260357229176651922921451505223699462456291090208287248038895703757789197
    ],
    # Point 406
    [
        2400377653395741560762585517571389386824872672242294297839787377212513042206,
        625963574857112775116550276725479329998557438550085741821320481021022314633
    ],
    # Point 407
    [
        2328311306030212189043981540771838515808167713931548944984202663139515716155,
        2492267419179473373149177460543961766435995439950143787911026640253198630634
    ],
    # Point 408
    [
        2387278462118275663019682655223568758817746496473668610784380666316276847549,
        2366392912056517351075178537570019722508034279024404671859228940369425653110
    ],
    # Point 409
    [
        2114043901163989266960550512790503188352140805965143750858598214845925650606,
        1263535257267454609784459072919175411484521178579707297022413088083025242903
    ],
    # Point 410
    [
        59742145227906406483850036502479681434689473008676866553687016399244912392,
        2542708853923609004067985135730679808561712875491472740521746862583772210812
    ],
    # Point 411
    [
        636010637932045133320800908704730609314370804715286131693312911610589568614,
        961184011917051478754418596971670071602153673068923576248721877819369343802
    ],
    # Point 412
    [
        1385321288061225556756217710115128107797163633073592537851457891527164069955,
        884133458066727093516473175829774361048238638693699012568518768170315343692
    ],
    # Point 413
    [
        758367055389438625364170431009355773885665422613428814074753204465381568635,
        1297727568042288931569138891121976026502156814623013130863114577102812764955
    ],
    # Point 414
    [
        347250288556045883174524792293804631653970133899259158293492482097831569584,
        1961316292966031207016509998947408765986081794211886403901120755246344327975
    ],
    # Point 415
    [
        1618690143706255801807773941554549190817935595982010405820190876061657720006,
        869166062594354289846899813362309895350435099932527145815122092397979607037
    ],
    # Point 416
    [
        1838634315648320098377933813041132543577219555069642930639820023291216325415,
        1529983605494771676066515349178506396294249260663468133203781588859819007226
    ],
    # Point 417
    [
        1605761809110472849967286703249646269449262088256390507097425667304759998260,
        2778705695237273113564800057362189513234607857754067598956643514325456052945
    ],
    # Point 418
    [
        3411908887615707635377666445857046055873541270252857286357865762696431003144,
        731871578063282896385513070338640294885089868946599519285295305156675019160
    ],
    # Point 419
    [
        3087826179342245618253320870694339144383060104280990174148199503867526625383,
        3491370412646223145431588455284304413010853471815192082926914611232193577659
    ],
    # Point 420
    [
        1436482751270429389743178806038120026461471807922309148229447715029903414786,
        1666868445318653269944338633661851246179662160526363040276638175667354338167
    ],
    # Point 421
    [
        2083331818739824497741363579518842947887353398223338451239015909684569222581,
        803732308089347618300580814078570019393110433387113056533917045601819866173
    ],
    # Point 422
    [
        1333165738767294811324643473740459024513360282013848003638568328453569807861,
        3324872774354633383424936425649606578793830970593411555017483797025902771350
    ],
    # Point 423
    [
        1701353517399938600269579188937389421636718828509341624534004474699861544304,
        982045252370486712463601150815912589800926352240648829942255288306435594694
    ],
    # Point 424
    [
        154403491180633257693040438747387470378033364863415878175486169393433469355,
        3204938488959824048546277939996603027140231747699901842459271581175521669368
    ],
    # Point 425
    [
        723459534533890816489433777735842913898349668429456824296910758117461179034,
        242799587564906089500242560200906533162881507520621156475321851862194708981
    ],
    # Point 426
    [
        2753553332546729968386491500304817162737325726065761497175967890302687642812,
        1607942131855693595003166153590488091960419143993462584570217492975562129656
    ],
    # Point 427
    [
        1318380449900940858865061333131606747009833602974109493687016869645480407519,
        824831465625011385685225132275899244334146133266851046834317903702436443339
    ],
    # Point 428
    [
        3406605858133553361333265720938744225870879664771897953784469453809670221140,
        951771439755520751413184037659273661906475899204291367776225253586492726939
    ],
    # Point 429
    [
        322881185844437667428941222631269048437916337535492466690110884912942662893,
        2408973683372380251710642884281850709418801321112976394586138388159314573007
    ],
    # Point 430
    [
        405651299272338889177305609117326577035390334272323319632791541534976007116,
        2403189350929802616202215631814070933678092854541380504903809068323291560762
    ],
    # Point 431
    [
        224362689432001608162440684107608338550077679080690583663897253625637368804,
        1089475930411433192334001657654788489125032803526758217361824123802939165263
    ],
    # Point 432
    [
        3427005033874860450481529297496326414099998098069008018777339291027217607772,
        1838523767315535107424920135038015356690704952046462913411177863052889918094
    ],
    # Point 433
    [
        971265369167429416740822747897568727646706124584943344118217646401474769333,
        1841017974237665428880957941884047733042022771551566493876831131552515616862
    ],
    # Point 434
    [
        593870383382776876660279010014844606756390978498220975404532129561707141345,
        1686799834245885653972636115594234495471835994524713453126028613189622517928
    ],
    # Point 435
    [
        158526420068961916859457596090914564342752702816639997380569526445580395317,
        829117473118004491391038359292216575457137041347974965494549565557957856696
    ],
    # Point 436
    [
        1145779849055685339419364615770769333393499278335670275163049680913140509683,
        2788919154400397863209918313477978879516215345298341199550275309881538159925
    ],
    # Point 437
    [
        3116362794833038183976492329109547313095843900691440633169686540582464014059,
        3493161563205582068593545591027301392887053692389997071622408416554079460959
    ],
    # Point 438
    [
        1484626752109997960148427439402147978447920625565926552692192513400801032840,
        106197164952655019784492783946283241349642545386756801239606388396528838557
    ],
    # Point 439
    [
        1905886704700624859591161108842694006068401527337545253689518506514368311453,
        2930319791340393503878111037261975689788636509301758506631633748789105811524
    ],
    # Point 440
    [
        2520975745491353699235764487116637116999082965127347369976279028452140192996,
        1121629571053704096076618751099836481664435087676492791791464786738401934277
    ],
    # Point 441
    [
        243197297174950489047429059272755382647269925832357483684904121385442353161,
        2417007034799146494310932386003928951978739444041601103686030150489540099099
    ],
    # Point 442
    [
        808704503940529633042533527196170354739879165235854099335954018048090166094,
        3250069164566476474875427019235306310423414676070245668865855537758860899226
    ],
    # Point 443
    [
        154229390082782874040656704404635500870072484057583506571360633170672994819,
        2702580522127958238752043600053843204107536082922189692357192526470020183763
    ],
    # Point 444
    [
        2296876062395150663198655775945704456626070946553449162794630784785525562017,
        2954047352783324167659477602480890942097095078541501369002104009282407983605
    ],
    # Point 445
    [
        2369843936932443670822535910120393374869045918271657278773939763527759009977,
        1504523220772650882417075434754212591932774780940943124208852030753505106366
    ],
    # Point 446
    [
        939818528450006271533633387575035651098636084551955010694000346778607054148,
        3288036962429189904257974342922419507417520404552917887258043999949243251337
    ],
    # Point 447
    [
        3261482392020733556192001297773623607067547108643955544388526649674482826812,
        3591646574338256506691865028073929692592246225874807859597509821099836701353
    ],
    # Point 448
    [
        1787025500314509707209621873912066561653490978360118110526034359358411964417,
        3421109838181987883898563834025345980326698037134918112926105203592921164968
    ],
    # Point 449
    [
        2311067462891595099991833582046690970468764702035366824733716384542858538356,
        470591103372156288650571624843786296549423881481598013229606695835762897581
    ],
    # Point 450
    [
        342559482224571965025189023541087083168706464251790471061097523992515769052,
        2368202754453331817392255123704696636258753331639084720511390832405023708522
    ],
    # Point 451
    [
        2572444430230869831563822697183525106374829659556462575156759807443152314062,
        1629527166738200666038465328035159152469458766421654684492365855846947518815
    ],
    # Point 452
    [
        1737389803319738463977618408470915902963778725702701713925657991380950954649,
        607082767712049126327196794168950822631607164722155751481706035333917604213
    ],
    # Point 453
    [
        2871556558000552242893836092551691122481664492915647218631883507493547887264,
        500384672074954803514661117946887054859762315512424468765642494189718439748
    ],
    # Point 454
    [
        3461109898461294404913712148331642005392308171104928758316008253448940997221,
        1749611977268851605988230236285965166361721258988901681470546570063157256891
    ],
    # Point 455
    [
        78615564253467413638171585726207276986620474184921384429093571227531830518,
        1981471018460691817560093727855711117339515783816308036046814473313844294189
    ],
    # Point 456
    [
        1474473102515930508594064469182212180992913337870765723235685741540431041359,
        1469840572053747949720853289796099707562318378077626046833147818685776895044
    ],
    # Point 457
    [
        2774277348282328170085742674659971495571500392161601753293416467112865068097,
        3137849475565620656681313987560185334413793189698703604034985791122356336275
    ],
    # Point 458
    [
        672166412479844650342747861081472852496472428762577522054587528815692740558,
        1663866879616164274903483340205017481052054060286752355521506181082184021495
    ],
    # Point 459
    [
        3180945697595716737370693680466484191429900897946060952610697010699886591271,
        370261256417300103212360232751326303498788243730491970857436044670395786744
    ],
    # Point 460
    [
        1201682462650513594149029305106730482154241597912555054934133306913124052927,
        2702519627582077982048055809065014719130205668704469328908061241215382284753
    ],
    # Point 461
    [
        2573098232031718801548737595348908190100964683270928802802545310591952021697,
        421880381247280215923854338509978900130125935079274502459764130391391089799
    ],
    # Point 462
    [
        3080354619128885268149548971617703089581818473398812557354479708280835955809,
        256390985131798172675848658065159234227830929883285189158702397702435740036
    ],
    # Point 463
    [
        3305006433068254197629607860194494003641107593674801290918966761186348868243,
        3339026583930460592461023889277320373514761589020084302062859793412730118034
    ],
    # Point 464
    [
        1923241940978623629561560707497295652725232345651095835780507541645042579369,
        1034987404476549078390013964157937064176009291357135198452850234267991254512
    ],
    # Point 465
    [
        1242878056067701165715334664693705019638823755244701687487484225344981621708,
        2778020811088591142544537894197696376781458923989081525073574174237563505877
    ],
    # Point 466
    [
        103159350300766901891674139940778235823347527941771255048984655353665811131,
        2998408586900586528158477448701326671048806329090729531148457644075161991659
    ],
    # Point 467
    [
        71218614431436475107665191107448218056096758969742620338129750710339397239,
        2301542035924343190515686028267024414404475677263930511758245534549493426119
    ],
    # Point 468
    [
        1192223060475270158246514565467403478627193592812213292121865811070708026418,
        3208674842884877565377729626392486507374130037365033772947426862394273679084
    ],
    # Point 469
    [
        2701994874964587709938210915198043688526355413043491003913483399075336026535,
        2886333482965974313702782452985415254520267819631653595494065556318924996302
    ],
    # Point 470
    [
        3306009714468475346677294651301864623371911173285781201209240934162798592783,
        605466198613255313875059832114128899690381126611676641778478133738267702577
    ],
    # Point 471
    [
        1450098270166428194278914193816868101013739489893607935042066987079292018245,
        60254834310937851613452000117427371272748499709961477924319944539270878930
    ],
    # Point 472
    [
        3472634693037182832142729498155218303319113785483118130849719300023909673520,
        1641508292869191604146734378916767617013327049910565729753281855691648138118
    ],
    # Point 473
    [
        1894817968472977732589643163725633598408826498334595898528746877517402007256,
        193046947184625502016096786396456839948351998258967537298275688147378157385
    ],
    # Point 474
    [
        798518742331453195093601874576575285888369661705098199469223675278431898599,
        107377575629504498627957848614396996685294283100119805971247351789316564355
    ],
    # Point 475
    [
        72958015465538907944252844948497831886498059248823205873862483987609118945,
        382019162223291772579736282379325284805025953290359275955015292364404489133
    ],
    # Point 476
    [
        3314147563388677609583640640385513143694481753397403848688825124581323140921,
        3133015892701145825892878874198767217439365812782859844688129544070997319541
    ],
    # Point 477
    [
        2444095071507078967491725470181706633826193926858202958437137361403432629390,
        3611326330343873710939978620686319096878621369582121415988028359537867630792
    ],
    # Point 478
    [
        2107740367200683219354058003519333570583941271011338026730935614636775950367,
        953104025671531038979165726896993106119997272237926795749220750824852831326
    ],
    # Point 479
    [
        3234656093348684616411954956071945712517868853923240328793520762092030352104,
        593797219275153872348854593022027262920747808515266478952508298984248786194
    ],
    # Point 480
    [
        1602095369325252473599793473477096021341779224145909730627015015569257565602,
        3272207934512491788245765497830881358513949839139669547034252308088069134971
    ],
    # Point 481
    [
        3149982146511124605253586861983261220008132001764223357617600582721741955729,
        2095033709871635786785037791315376486221829475125386227641672208905379085173
    ],
    # Point 482
    [
        3001928273494873166012582714776651165587585607934603548408913923445707516447,
        1090266449665582127890982346068170500195143341692394417827957481874850148101
    ],
    # Point 483
    [
        1200188694803418163698740652082064619102559508865389996854547617715365179733,
        2701249247866363010207334776256734312390753341409567681725083482804664533572
    ],
    # Point 484
    [
        2181535855195652401374211290838795366238299923929423873085735410894622521047,
        2376412857416063533601832417302250911062085318826783757605801470091451365057
    ],
    # Point 485
    [
        482216227882593950837484293882738923170227555670484160841935409522897080275,
        3568625956076637648484022304136932386854238480511347282187445648692365982275
    ],
    # Point 486
    [
        2597799669063340267995599892195854202917996255210920411104497198234262573206,
        3599688873496047961188179975715306136394737017927100659789000949688648352738
    ],
    # Point 487
    [
        1074803073878259665128704812644508804681887514658526880458531694790041080733,
        2797007314237358398853761880558407828488654212157591536243300688627270327611
    ],
    # Point 488
    [
        468516314257643341712703808920275922572701541039900608201362821198817231181,
        1374527914917866113032496762177078616084751647116110264806150108724834406388
    ],
    # Point 489
    [
        1208295021405021769918747031548141820393186404250802478605705170489054454157,
        1808650369660257850053512198148641736021245568921649705336796845945032764079
    ],
    # Point 490
    [
        1565766387634045687737221757815822397332528241094852872444435795933964809539,
        3012257951756551767601579252037773433674622118381097513581891561867035592007
    ],
    # Point 491
    [
        296854483963576847362550837105567519963678928320906132062353506063381160038,
        2997621846549637009998526882695309289938245125374301351844169021609166074993
    ],
    # Point 492
    [
        967192065183772403576792198824105189328662921952353748318585728895552782317,
        343259257621685032456419166732348373845783852374756662051672936363788935338
    ],
    # Point 493
    [
        456199991075423266290193634515181612721738873753897142916892886319728411618,
        3009804764464949268795409945347301690744692042792259709767667423717478448229
    ],
    # Point 494
    [
        242210936510534966601707881924518098930470912600217515366037129037143259602,
        2698396953115175496998177800235267214917400761768300598355994305287141321271
    ],
    # Point 495
    [
        943070145114606420402378547694273832277173459266557776382587828687889744387,
        463274201648439487604179878678549669204059390508994779482933722127905403494
    ],
    # Point 496
    [
        958740504301613688526614902955971923282735882762427544770668882582144756278,
        1648715733425449195104866742590789175535499260400395501324113794510596751843
    ],
    # Point 497
    [
        2738467504442851843676882768027062309179245908086784030957627999641833602734,
        403058158250173068725971433188527745485878446592356816888847490041658726521
    ],
    # Point 498
    [
        851584175891221844656684173543344216725376446573878021753176795750916050165,
        2989949954698892115645230865442980084822288702406021287339635187958555345139
    ],
    # Point 499
    [
        2648599427528401936572004779373684054684563511138695864967500218937169746782,
        545540526832939914359571382575431287745621956136188859527645452849687661804
    ],
    # Point 500
    [
        2781909713387830233242081629088160756893816968845366829353355409163126437112,
        3474066345655056798683792894555452083305620276965763551620554269294421970656
    ],
    # Point 501
    [
        62007937137219837991330947293062511223089197148302827535260096716770644685,
        3537197938414984401398955238628360208832764753222288521326061893140886724271
    ],
    # Point 502
    [
        2379962749567351885752724891227938183011949129833673362440656643086021394946,
        776496453633298175483985398648758586525933812536653089401905292063708816422
    ],
    # Point 503
    [
        553697491755753712548822408932664734674730150084063981046477343718694621804,
        2797798649021537247229237999331435556632872779265479409612091247299955463913
    ],
    # Point 504
    [
        2026114267613810970244390071397350467776533880677809710454617259260017487512,
        3330593270696197494966018967263043594632970418364498628573044882141635806155
    ],
    # Point 505
    [
        1254733481274108825174693797237617285863727098996450904398879255272288617861,
        2644890941682394074696857415419096381561354281743803087373802494123523779468
    ]
]


## edgex_sdk/crypto/pedersen_hash.py
"""
Pedersen hash implementation for StarkWare cryptography.

This module provides a full implementation of the Pedersen hash function
as specified by StarkWare, compatible with the reference implementation.
"""

from typing import List, Tuple, Union

# Handle both relative and absolute imports
try:
    from .constants import (
        FIELD_PRIME, ALPHA, BETA, N_ELEMENT_BITS_HASH,
        SHIFT_POINT, CONSTANT_POINTS
    )
except ImportError:
    from constants import (
        FIELD_PRIME, ALPHA, BETA, N_ELEMENT_BITS_HASH,
        SHIFT_POINT, CONSTANT_POINTS
    )


def _div_mod(n: int, m: int, p: int) -> int:
    """
    Calculate (n / m) mod p.
    
    Args:
        n: The numerator
        m: The denominator  
        p: The modulus
        
    Returns:
        int: The result of the division modulo p
    """
    return (n * pow(m, -1, p)) % p


def _ec_add(p1: Tuple[int, int], p2: Tuple[int, int]) -> Tuple[int, int]:
    """
    Add two points on the elliptic curve.
    
    Args:
        p1: The first point as (x, y) coordinates
        p2: The second point as (x, y) coordinates
        
    Returns:
        Tuple[int, int]: The resulting point as (x, y) coordinates
    """
    if p1[0] == p2[0]:
        if (p1[1] + p2[1]) % FIELD_PRIME == 0:
            # The points are negatives of each other, return the point at infinity
            # We represent the point at infinity as None, but this should never happen
            # in our use case, so we raise an exception instead
            raise ValueError("Points are negatives of each other")
        
        # The points are the same, so we're doubling
        return _ec_double(p1)
    
    # Calculate the slope
    slope = _div_mod(p2[1] - p1[1], p2[0] - p1[0], FIELD_PRIME)
    
    # Calculate the new point
    x3 = (slope * slope - p1[0] - p2[0]) % FIELD_PRIME
    y3 = (slope * (p1[0] - x3) - p1[1]) % FIELD_PRIME
    
    return (x3, y3)


def _ec_double(p: Tuple[int, int]) -> Tuple[int, int]:
    """
    Double a point on the elliptic curve.
    
    Args:
        p: The point to double as (x, y) coordinates
        
    Returns:
        Tuple[int, int]: The resulting point as (x, y) coordinates
    """
    # Calculate the slope
    slope = _div_mod(3 * p[0] * p[0] + ALPHA, 2 * p[1], FIELD_PRIME)
    
    # Calculate the new point
    x3 = (slope * slope - 2 * p[0]) % FIELD_PRIME
    y3 = (slope * (p[0] - x3) - p[1]) % FIELD_PRIME
    
    return (x3, y3)


def _ec_mult(m: int, p: Tuple[int, int]) -> Tuple[int, int]:
    """
    Multiply a point on the elliptic curve by a scalar.
    
    Args:
        m: The scalar
        p: The point as (x, y) coordinates
        
    Returns:
        Tuple[int, int]: The resulting point as (x, y) coordinates
    """
    if m == 0:
        raise ValueError("Cannot multiply by 0")
    
    if m == 1:
        return p
    
    if m % 2 == 0:
        return _ec_mult(m // 2, _ec_double(p))
    else:
        return _ec_add(p, _ec_mult(m - 1, p))


def pedersen_hash_as_point(*elements: int) -> Tuple[int, int]:
    """
    Calculate the Pedersen hash of a list of integers and return the full EC point.

    This is the full implementation following StarkWare's specification:
    For each element, iterate through its 252 bits and add corresponding
    constant points based on the bit values.

    Args:
        *elements: Variable number of integers to hash

    Returns:
        Tuple[int, int]: The resulting EC point as (x, y) coordinates

    Raises:
        ValueError: If any element is out of range or if there are insufficient constant points
    """
    # Start with the shift point
    point = tuple(SHIFT_POINT)

    for i, element in enumerate(elements):
        # Validate element is in valid range
        if not (0 <= element < FIELD_PRIME):
            raise ValueError(f"Element {element} is out of range [0, {FIELD_PRIME})")

        # Calculate the starting index for this element's constant points
        start_idx = 2 + i * N_ELEMENT_BITS_HASH

        # Check if we have enough constant points
        if start_idx + N_ELEMENT_BITS_HASH > len(CONSTANT_POINTS):
            raise ValueError(f"Insufficient constant points for element {i}. Need {start_idx + N_ELEMENT_BITS_HASH}, have {len(CONSTANT_POINTS)}")

        # Full implementation using all 252 bits
        for j in range(N_ELEMENT_BITS_HASH):
            pt = tuple(CONSTANT_POINTS[start_idx + j])

            # Check for unhashable input (same x coordinate)
            if point[0] == pt[0]:
                raise ValueError('Unhashable input: point collision detected')

            if element & 1:
                point = _ec_add(point, pt)
            element >>= 1

        # Ensure all bits have been processed
        if element != 0:
            raise ValueError(f"Element too large: remaining bits {element}")

    return point


def pedersen_hash(*elements: int) -> int:
    """
    Calculate the Pedersen hash of a list of integers.
    
    This function returns only the x-coordinate of the resulting EC point,
    which is the standard Pedersen hash value.
    
    Args:
        *elements: Variable number of integers to hash
        
    Returns:
        int: The Pedersen hash as an integer (x-coordinate of the EC point)
        
    Raises:
        ValueError: If any element is out of range
    """
    point = pedersen_hash_as_point(*elements)
    return point[0]


def pedersen_hash_bytes(*elements: Union[int, bytes]) -> bytes:
    """
    Calculate the Pedersen hash and return as bytes.
    
    Args:
        *elements: Variable number of integers or bytes to hash
        
    Returns:
        bytes: The hash result as 32 bytes (big-endian)
        
    Raises:
        ValueError: If any element is invalid
    """
    # Convert bytes to integers if needed
    int_elements = []
    for element in elements:
        if isinstance(element, bytes):
            if len(element) > 32:
                raise ValueError(f"Bytes element too long: {len(element)} > 32")
            int_elements.append(int.from_bytes(element, byteorder='big'))
        elif isinstance(element, int):
            int_elements.append(element)
        else:
            raise ValueError(f"Invalid element type: {type(element)}")
    
    hash_result = pedersen_hash(*int_elements)
    return hash_result.to_bytes(32, byteorder='big')


## edgex_sdk/funding/__init__.py


## edgex_sdk/funding/client.py
from typing import Dict, Any, List

from ..internal.async_client import AsyncClient


class Client:
    """Client for funding-related API endpoints."""

    def __init__(self, async_client: AsyncClient):
        """
        Initialize the funding client.

        Args:
            async_client: The async client for common functionality
        """
        self.async_client = async_client

    async def get_funding_transactions(
        self,
        size: str = "",
        offset_data: str = "",
        filter_coin_id_list: List[str] = None,
        filter_type_list: List[str] = None,
        filter_start_created_time_inclusive: int = 0,
        filter_end_created_time_exclusive: int = 0
    ) -> Dict[str, Any]:
        """
        Get funding transactions with pagination.

        Args:
            size: Size of the page
            offset_data: Offset data for pagination
            filter_coin_id_list: Filter by coin IDs
            filter_type_list: Filter by transaction types
            filter_start_created_time_inclusive: Filter start time (inclusive)
            filter_end_created_time_exclusive: Filter end time (exclusive)

        Returns:
            Dict[str, Any]: The funding transactions

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if size:
            query_params["size"] = size
        if offset_data:
            query_params["offsetData"] = offset_data

        # Add filter parameters
        if filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(filter_coin_id_list)
        if filter_type_list:
            query_params["filterTypeList"] = ",".join(filter_type_list)

        # Add time filters
        if filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(filter_start_created_time_inclusive)
        if filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/public/funding/getFundingRatePage",
            params=query_params
        )

    async def get_funding_account(self) -> Dict[str, Any]:
        """
        Get funding account information.

        Returns:
            Dict[str, Any]: The funding account information

        Raises:
            ValueError: If the request fails
        """
        params = {
            "accountId": str(self.async_client.get_account_id())
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/account/getAccountAsset",
            params=params
        )

    async def get_funding_transaction_by_id(self, transaction_ids: List[str]) -> Dict[str, Any]:
        """
        Get funding transactions by IDs.

        Args:
            transaction_ids: List of transaction IDs

        Returns:
            Dict[str, Any]: The funding transactions

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id()),
            "transactionIdList": ",".join(transaction_ids)
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/public/funding/getLatestFundingRate",
            params=query_params
        )


## edgex_sdk/internal/__init__.py


## edgex_sdk/internal/async_client.py
import asyncio
import binascii
import hashlib
import time
import uuid
from typing import Dict, Any, Optional, Tuple, List, Union
import json

import aiohttp
from Crypto.Hash import keccak

from .signing_adapter import SigningAdapter

# Import field prime for modular arithmetic
try:
    from ..crypto.constants import FIELD_PRIME
except ImportError:
    # Fallback if crypto module is not available
    FIELD_PRIME = 0x800000000000011000000000000000000000000000000000000000000000001

# Constants
LIMIT_ORDER_WITH_FEE_TYPE = 3


class L2Signature:
    """Represents a signature for L2 operations."""

    def __init__(self, r: str, s: str, v: str = ""):
        self.r = r
        self.s = s
        self.v = v


class AsyncClient:
    """Async base client with common functionality."""

    def __init__(self, base_url: str, account_id: int, stark_pri_key: str, 
                 signing_adapter: Optional[SigningAdapter] = None,
                 timeout: float = 30.0, connector_limit: int = 100):
        """
        Initialize the async internal client.

        Args:
            base_url: Base URL for API endpoints
            account_id: Account ID for authentication
            stark_pri_key: Stark private key for signing
            signing_adapter: Optional signing adapter to use for cryptographic operations
            timeout: Request timeout in seconds
            connector_limit: Maximum number of connections in the pool
        """
        self.base_url = base_url
        self.account_id = account_id
        self.stark_pri_key = stark_pri_key
        
        # Use the provided signing adapter (required)
        if signing_adapter is None:
            raise ValueError("signing_adapter is required")
        self.signing_adapter = signing_adapter
        
        # Store configuration for later session creation
        self._session = None
        self._timeout = timeout
        self._connector_limit = connector_limit
        self._closed = False

    async def __aenter__(self):
        """Async context manager entry."""
        await self._ensure_session()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        await self.close()

    async def _ensure_session(self):
        """Ensure the aiohttp session is created."""
        if self._session is None or self._session.closed:
            # Create connector and session when needed (inside event loop)
            timeout_config = aiohttp.ClientTimeout(total=self._timeout)
            connector = aiohttp.TCPConnector(
                limit=self._connector_limit,
                limit_per_host=30,
                keepalive_timeout=30,
                enable_cleanup_closed=True
            )

            self._session = aiohttp.ClientSession(
                timeout=timeout_config,
                connector=connector,
                headers={
                    "Content-Type": "application/json",
                    "Accept": "application/json"
                }
            )

    async def close(self):
        """Close the HTTP session and cleanup resources."""
        if self._session and not self._session.closed:
            await self._session.close()
        self._closed = True

    @property
    def session(self) -> aiohttp.ClientSession:
        """Get the HTTP session, ensuring it's created."""
        if self._session is None or self._session.closed:
            raise RuntimeError("Session not initialized. Use 'async with client:' or call '_ensure_session()'")
        return self._session

    def get_account_id(self) -> int:
        """Get the account ID."""
        return self.account_id

    def get_stark_pri_key(self) -> str:
        """Get the stark private key."""
        return self.stark_pri_key

    def sign(self, message_hash: bytes) -> L2Signature:
        """
        Sign a message hash using the client's Stark private key.

        Args:
            message_hash: The hash of the message to sign

        Returns:
            L2Signature: The signature components

        Raises:
            ValueError: If the stark private key is not set or invalid
        """
        private_key = self.get_stark_pri_key()
        if not private_key:
            raise ValueError("stark private key not set")

        # Sign the message using the signing adapter
        try:
            r, s = self.signing_adapter.sign(message_hash, private_key)
            return L2Signature(r=r, s=s, v="")
        except Exception as e:
            raise ValueError(f"failed to sign message: {str(e)}")

    def generate_uuid(self) -> str:
        """Generate a UUID for client order IDs."""
        return str(uuid.uuid4())

    def calc_nonce(self, client_order_id: str) -> int:
        """
        Calculate a nonce from a client order ID.

        Args:
            client_order_id: The client order ID

        Returns:
            int: The calculated nonce
        """
        # Use SHA256 like the Go SDK (not Keccak256)
        h = hashlib.sha256()
        h.update(client_order_id.encode())
        hash_hex = h.hexdigest()
        return int(hash_hex[:8], 16)

    async def make_authenticated_request(
        self, 
        method: str, 
        path: str, 
        data: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Make an authenticated HTTP request.

        Args:
            method: HTTP method (GET, POST, etc.)
            path: API path (e.g., '/api/v1/private/order/createOrder')
            data: JSON data for POST requests
            params: Query parameters for GET requests

        Returns:
            Dict[str, Any]: Response JSON data

        Raises:
            ValueError: If the request fails
        """
        await self._ensure_session()
        
        # Generate timestamp
        timestamp = int(time.time() * 1000)
        
        # Build full URL
        url = f"{self.base_url}{path}"
        
        # Generate signature content
        sign_content = self._build_signature_content(timestamp, method, path, data, params)
        
        # Sign the content
        keccak_hash = keccak.new(digest_bits=256)
        keccak_hash.update(sign_content.encode())
        content_hash = keccak_hash.digest()
        
        sig = self.sign(content_hash)
        
        # Prepare headers
        headers = {
            "X-edgeX-Api-Timestamp": str(timestamp),
            "X-edgeX-Api-Signature": f"{sig.r}{sig.s}"
        }
        
        # Make the request
        try:
            async with self.session.request(
                method=method,
                url=url,
                json=data,
                params=params,
                headers=headers
            ) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except (aiohttp.ContentTypeError, json.JSONDecodeError):
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")
                
                resp_data = await response.json()
                
                # Check response code
                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")
                
                return resp_data
                
        except aiohttp.ClientError as e:
            raise ValueError(f"HTTP request failed: {str(e)}")

    def _build_signature_content(
        self, 
        timestamp: int, 
        method: str, 
        path: str, 
        data: Optional[Dict[str, Any]], 
        params: Optional[Dict[str, Any]]
    ) -> str:
        """Build the content string for signature generation."""
        if data:
            # Convert body to sorted string format
            body_str = self.get_value(data)
            sign_content = f"{timestamp}{method}{path}{body_str}"
        else:
            # For requests without body, use query parameters if present
            if params:
                # Sort query parameters as strings (matching Go SDK exactly)
                param_pairs = []
                for key, value in sorted(params.items()):
                    param_pairs.append(f"{key}={value}")
                query_string = "&".join(param_pairs)
                sign_content = f"{timestamp}{method}{path}{query_string}"
            else:
                sign_content = f"{timestamp}{method}{path}"
        
        return sign_content

    def get_value(self, data: Union[Dict[str, Any], List[Any], str, int, float, None]) -> str:
        """
        Convert a value to a string representation for signing.
        This function recursively processes dictionaries, lists, and primitive types.

        Args:
            data: The value to convert

        Returns:
            str: The string representation
        """
        if data is None:
            return ""

        if isinstance(data, str):
            return data

        if isinstance(data, bool):
            # Convert boolean to lowercase string to match Go SDK
            return str(data).lower()

        if isinstance(data, (int, float)):
            return str(data)

        if isinstance(data, list):
            if len(data) == 0:
                return ""
            values = [self.get_value(item) for item in data]
            return "&".join(values)

        if isinstance(data, dict):
            # Convert all values to strings and sort by keys
            sorted_map = {}
            for key, val in data.items():
                sorted_map[key] = self.get_value(val)

            # Get sorted keys
            keys = sorted(sorted_map.keys())

            # Build key=value pairs
            pairs = [f"{key}={sorted_map[key]}" for key in keys]
            return "&".join(pairs)

        # Handle other types by converting to string
        return str(data)

    def calc_limit_order_hash(
        self,
        synthetic_asset_id: str,
        collateral_asset_id: str,
        fee_asset_id: str,
        is_buy: bool,
        amount_synthetic: int,
        amount_collateral: int,
        amount_fee: int,
        nonce: int,
        account_id: int,
        expire_time: int
    ) -> bytes:
        """
        Calculate the hash for a limit order using StarkEx protocol.

        Args:
            synthetic_asset_id: The synthetic asset ID (hex string)
            collateral_asset_id: The collateral asset ID (hex string)
            fee_asset_id: The fee asset ID (hex string)
            is_buy: Whether the order is a buy order
            amount_synthetic: The synthetic amount
            amount_collateral: The collateral amount
            amount_fee: The fee amount
            nonce: The nonce
            account_id: The account ID (position ID)
            expire_time: The expiration time

        Returns:
            bytes: The calculated hash
        """
        # Remove 0x prefix if present
        if synthetic_asset_id.startswith('0x'):
            synthetic_asset_id = synthetic_asset_id[2:]
        if collateral_asset_id.startswith('0x'):
            collateral_asset_id = collateral_asset_id[2:]
        if fee_asset_id.startswith('0x'):
            fee_asset_id = fee_asset_id[2:]

        # Convert hex strings to integers and ensure they're within the field
        asset_id_synthetic = int(synthetic_asset_id, 16) % FIELD_PRIME
        asset_id_collateral = int(collateral_asset_id, 16) % FIELD_PRIME
        asset_id_fee = int(fee_asset_id, 16) % FIELD_PRIME

        # Determine buy/sell assets based on order direction
        if is_buy:
            asset_id_sell = asset_id_collateral
            asset_id_buy = asset_id_synthetic
            amount_sell = amount_collateral
            amount_buy = amount_synthetic
        else:
            asset_id_sell = asset_id_synthetic
            asset_id_buy = asset_id_collateral
            amount_sell = amount_synthetic
            amount_buy = amount_collateral

        # Use the signing adapter to calculate the Pedersen hash
        # First hash: hash(asset_id_sell, asset_id_buy)
        msg = self.signing_adapter.pedersen_hash([asset_id_sell, asset_id_buy])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Second hash: hash(msg, asset_id_fee)
        msg = self.signing_adapter.pedersen_hash([msg_int, asset_id_fee])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 0
        # packed_message0 = amount_sell * 2^64 + amount_buy * 2^64 + max_amount_fee * 2^32 + nonce
        packed_message0 = amount_sell
        packed_message0 = (packed_message0 << 64) + amount_buy
        packed_message0 = (packed_message0 << 64) + amount_fee
        packed_message0 = (packed_message0 << 32) + nonce
        packed_message0 = packed_message0 % FIELD_PRIME  # Ensure within field

        # Third hash: hash(msg, packed_message0)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_message0])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 1
        # packed_message1 = LIMIT_ORDER_WITH_FEES * 2^64 + position_id * 2^64 + position_id * 2^64 + position_id * 2^32 + expiration_timestamp * 2^17
        packed_message1 = LIMIT_ORDER_WITH_FEE_TYPE
        packed_message1 = (packed_message1 << 64) + account_id
        packed_message1 = (packed_message1 << 64) + account_id
        packed_message1 = (packed_message1 << 64) + account_id
        packed_message1 = (packed_message1 << 32) + expire_time
        packed_message1 = packed_message1 << 17  # Padding
        packed_message1 = packed_message1 % FIELD_PRIME  # Ensure within field

        # Final hash: hash(msg, packed_message1)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_message1])

        return msg

    def calc_transfer_hash(
        self,
        asset_id: int,
        asset_id_fee: int,
        receiver_public_key: int,
        sender_position_id: int,
        receiver_position_id: int,
        fee_position_id: int,
        nonce: int,
        amount: int,
        max_amount_fee: int,
        expiration_timestamp: int
    ) -> bytes:
        """
        Calculate the hash for a transfer using StarkEx protocol.

        Args:
            asset_id: The asset ID
            asset_id_fee: The fee asset ID
            receiver_public_key: The receiver's public key
            sender_position_id: The sender's position ID
            receiver_position_id: The receiver's position ID
            fee_position_id: The fee position ID
            nonce: The nonce
            amount: The transfer amount
            max_amount_fee: The maximum fee amount
            expiration_timestamp: The expiration timestamp

        Returns:
            bytes: The calculated hash
        """
        # First hash: hash(asset_id, asset_id_fee)
        msg = self.signing_adapter.pedersen_hash([asset_id, asset_id_fee])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Second hash: hash(msg, receiver_public_key)
        msg = self.signing_adapter.pedersen_hash([msg_int, receiver_public_key])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 0
        # packed_msg0 = sender_position_id * 2^64 + receiver_position_id * 2^64 + fee_position_id * 2^32 + nonce
        packed_msg0 = sender_position_id
        packed_msg0 = (packed_msg0 << 64) + receiver_position_id
        packed_msg0 = (packed_msg0 << 64) + fee_position_id
        packed_msg0 = (packed_msg0 << 32) + nonce
        packed_msg0 = packed_msg0 % FIELD_PRIME  # Ensure within field

        # Third hash: hash(msg, packed_msg0)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_msg0])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 1
        # packed_msg1 = 4 * 2^64 + amount * 2^64 + max_amount_fee * 2^32 + expiration_timestamp * 2^81
        packed_msg1 = 4  # Transfer type
        packed_msg1 = (packed_msg1 << 64) + amount
        packed_msg1 = (packed_msg1 << 64) + max_amount_fee
        packed_msg1 = (packed_msg1 << 32) + expiration_timestamp
        packed_msg1 = packed_msg1 << 81  # Padding
        packed_msg1 = packed_msg1 % FIELD_PRIME  # Ensure within field

        # Final hash: hash(msg, packed_msg1)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_msg1])

        return msg


## edgex_sdk/internal/client.py
import binascii
import hashlib
import time
import uuid
from typing import Dict, Any, Optional, Tuple, List, Union

import requests
from Crypto.Hash import keccak

from .signing_adapter import SigningAdapter

# Import field prime for modular arithmetic
try:
    from ..crypto.constants import FIELD_PRIME
except ImportError:
    # Fallback if crypto module is not available
    FIELD_PRIME = 0x800000000000011000000000000000000000000000000000000000000000001

# Constants
LIMIT_ORDER_WITH_FEE_TYPE = 3


class L2Signature:
    """Represents a signature for L2 operations."""

    def __init__(self, r: str, s: str, v: str = ""):
        self.r = r
        self.s = s
        self.v = v


class Client:
    """Base client with common functionality."""

    def __init__(self, base_url: str, account_id: int, stark_pri_key: str, signing_adapter: Optional[SigningAdapter] = None):
        """
        Initialize the internal client.

        Args:
            base_url: Base URL for API endpoints
            account_id: Account ID for authentication
            stark_pri_key: Stark private key for signing
            signing_adapter: Optional signing adapter to use for cryptographic operations
        """
        self.http_client = requests.Session()
        self.http_client.headers.update({
            "Content-Type": "application/json",
            "Accept": "application/json"
        })
        self.base_url = base_url
        self.account_id = account_id
        self.stark_pri_key = stark_pri_key

        # Use the provided signing adapter (required)
        if signing_adapter is None:
            raise ValueError("signing_adapter is required")
        self.signing_adapter = signing_adapter

    def get_account_id(self) -> int:
        """Get the account ID."""
        return self.account_id

    def get_stark_pri_key(self) -> str:
        """Get the stark private key."""
        return self.stark_pri_key

    def sign(self, message_hash: bytes) -> L2Signature:
        """
        Sign a message hash using the client's Stark private key.

        Args:
            message_hash: The hash of the message to sign

        Returns:
            L2Signature: The signature components

        Raises:
            ValueError: If the stark private key is not set or invalid
        """
        private_key = self.get_stark_pri_key()
        if not private_key:
            raise ValueError("stark private key not set")

        # Sign the message using the signing adapter
        try:
            r, s = self.signing_adapter.sign(message_hash, private_key)
            return L2Signature(r=r, s=s, v="")
        except Exception as e:
            raise ValueError(f"failed to sign message: {str(e)}")

    def generate_uuid(self) -> str:
        """Generate a UUID for client order IDs."""
        return str(uuid.uuid4())

    def calc_nonce(self, client_order_id: str) -> int:
        """
        Calculate a nonce from a client order ID.

        Args:
            client_order_id: The client order ID

        Returns:
            int: The calculated nonce
        """
        # Use SHA256 like the Go SDK (not Keccak256)
        h = hashlib.sha256()
        h.update(client_order_id.encode())
        hash_hex = h.hexdigest()
        return int(hash_hex[:8], 16)

    def calc_limit_order_hash(
        self,
        synthetic_asset_id: str,
        collateral_asset_id: str,
        fee_asset_id: str,
        is_buy: bool,
        amount_synthetic: int,
        amount_collateral: int,
        amount_fee: int,
        nonce: int,
        account_id: int,
        expire_time: int
    ) -> bytes:
        """
        Calculate the hash for a limit order using StarkEx protocol.

        Args:
            synthetic_asset_id: The synthetic asset ID (hex string)
            collateral_asset_id: The collateral asset ID (hex string)
            fee_asset_id: The fee asset ID (hex string)
            is_buy: Whether the order is a buy order
            amount_synthetic: The synthetic amount
            amount_collateral: The collateral amount
            amount_fee: The fee amount
            nonce: The nonce
            account_id: The account ID (position ID)
            expire_time: The expiration time

        Returns:
            bytes: The calculated hash
        """
        # Remove 0x prefix if present
        if synthetic_asset_id.startswith('0x'):
            synthetic_asset_id = synthetic_asset_id[2:]
        if collateral_asset_id.startswith('0x'):
            collateral_asset_id = collateral_asset_id[2:]
        if fee_asset_id.startswith('0x'):
            fee_asset_id = fee_asset_id[2:]

        # Convert hex strings to integers and ensure they're within the field
        asset_id_synthetic = int(synthetic_asset_id, 16) % FIELD_PRIME
        asset_id_collateral = int(collateral_asset_id, 16) % FIELD_PRIME
        asset_id_fee = int(fee_asset_id, 16) % FIELD_PRIME

        # Determine buy/sell assets based on order direction
        if is_buy:
            asset_id_sell = asset_id_collateral
            asset_id_buy = asset_id_synthetic
            amount_sell = amount_collateral
            amount_buy = amount_synthetic
        else:
            asset_id_sell = asset_id_synthetic
            asset_id_buy = asset_id_collateral
            amount_sell = amount_synthetic
            amount_buy = amount_collateral

        # Use the signing adapter to calculate the Pedersen hash
        # First hash: hash(asset_id_sell, asset_id_buy)
        msg = self.signing_adapter.pedersen_hash([asset_id_sell, asset_id_buy])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Second hash: hash(msg, asset_id_fee)
        msg = self.signing_adapter.pedersen_hash([msg_int, asset_id_fee])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 0
        # packed_message0 = amount_sell * 2^64 + amount_buy * 2^64 + max_amount_fee * 2^32 + nonce
        packed_message0 = amount_sell
        packed_message0 = (packed_message0 << 64) + amount_buy
        packed_message0 = (packed_message0 << 64) + amount_fee
        packed_message0 = (packed_message0 << 32) + nonce
        packed_message0 = packed_message0 % FIELD_PRIME  # Ensure within field

        # Third hash: hash(msg, packed_message0)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_message0])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 1
        # packed_message1 = LIMIT_ORDER_WITH_FEES * 2^64 + position_id * 2^64 + position_id * 2^64 + position_id * 2^32 + expiration_timestamp * 2^17
        packed_message1 = LIMIT_ORDER_WITH_FEE_TYPE
        packed_message1 = (packed_message1 << 64) + account_id
        packed_message1 = (packed_message1 << 64) + account_id
        packed_message1 = (packed_message1 << 64) + account_id
        packed_message1 = (packed_message1 << 32) + expire_time
        packed_message1 = packed_message1 << 17  # Padding
        packed_message1 = packed_message1 % FIELD_PRIME  # Ensure within field

        # Final hash: hash(msg, packed_message1)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_message1])

        return msg

    def calc_transfer_hash(
        self,
        asset_id: int,
        asset_id_fee: int,
        receiver_public_key: int,
        sender_position_id: int,
        receiver_position_id: int,
        fee_position_id: int,
        nonce: int,
        amount: int,
        max_amount_fee: int,
        expiration_timestamp: int
    ) -> bytes:
        """
        Calculate the hash for a transfer using StarkEx protocol.

        Args:
            asset_id: The asset ID
            asset_id_fee: The fee asset ID
            receiver_public_key: The receiver's public key
            sender_position_id: The sender's position ID
            receiver_position_id: The receiver's position ID
            fee_position_id: The fee position ID
            nonce: The nonce
            amount: The transfer amount
            max_amount_fee: The maximum fee amount
            expiration_timestamp: The expiration timestamp

        Returns:
            bytes: The calculated hash
        """
        # First hash: hash(asset_id, asset_id_fee)
        msg = self.signing_adapter.pedersen_hash([asset_id, asset_id_fee])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Second hash: hash(msg, receiver_public_key)
        msg = self.signing_adapter.pedersen_hash([msg_int, receiver_public_key])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 0
        # packed_msg0 = sender_position_id * 2^64 + receiver_position_id * 2^64 + fee_position_id * 2^32 + nonce
        packed_msg0 = sender_position_id
        packed_msg0 = (packed_msg0 << 64) + receiver_position_id
        packed_msg0 = (packed_msg0 << 64) + fee_position_id
        packed_msg0 = (packed_msg0 << 32) + nonce
        packed_msg0 = packed_msg0 % FIELD_PRIME  # Ensure within field

        # Third hash: hash(msg, packed_msg0)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_msg0])
        msg_int = int.from_bytes(msg, byteorder='big')

        # Pack message 1
        # packed_msg1 = 4 * 2^64 + amount * 2^64 + max_amount_fee * 2^32 + expiration_timestamp * 2^81
        packed_msg1 = 4  # Transfer type
        packed_msg1 = (packed_msg1 << 64) + amount
        packed_msg1 = (packed_msg1 << 64) + max_amount_fee
        packed_msg1 = (packed_msg1 << 32) + expiration_timestamp
        packed_msg1 = packed_msg1 << 81  # Padding
        packed_msg1 = packed_msg1 % FIELD_PRIME  # Ensure within field

        # Final hash: hash(msg, packed_msg1)
        msg = self.signing_adapter.pedersen_hash([msg_int, packed_msg1])

        return msg

    def get_value(self, data: Union[Dict[str, Any], List[Any], str, int, float, None]) -> str:
        """
        Convert a value to a string representation for signing.
        This function recursively processes dictionaries, lists, and primitive types.

        Args:
            data: The value to convert

        Returns:
            str: The string representation
        """
        if data is None:
            return ""

        if isinstance(data, str):
            return data

        if isinstance(data, bool):
            # Convert boolean to lowercase string to match Go SDK
            return str(data).lower()

        if isinstance(data, (int, float)):
            return str(data)

        if isinstance(data, list):
            if len(data) == 0:
                return ""
            values = [self.get_value(item) for item in data]
            return "&".join(values)

        if isinstance(data, dict):
            # Convert all values to strings and sort by keys
            sorted_map = {}
            for key, val in data.items():
                sorted_map[key] = self.get_value(val)

            # Get sorted keys
            keys = sorted(sorted_map.keys())

            # Build key=value pairs
            pairs = [f"{key}={sorted_map[key]}" for key in keys]
            return "&".join(pairs)

        # Handle other types by converting to string
        return str(data)


## edgex_sdk/internal/signing_adapter.py
"""
Signing adapter interface for the EdgeX Python SDK.

This module defines the interface for signing adapters that can be used with the SDK.
Different implementations can be provided for different environments (development, testing, production).
"""

from abc import ABC, abstractmethod
from typing import Tuple, List


class SigningAdapter(ABC):
    """Interface for signing adapters."""

    @abstractmethod
    def sign(self, message_hash: bytes, private_key: str) -> Tuple[str, str]:
        """
        Sign a message hash using a private key.

        Args:
            message_hash: The hash of the message to sign
            private_key: The private key as a hex string

        Returns:
            Tuple[str, str]: The signature as (r, s) hex strings

        Raises:
            ValueError: If the private key is invalid or the signing fails
        """
        pass

    @abstractmethod
    def get_public_key(self, private_key: str) -> str:
        """
        Get the public key from a private key.

        Args:
            private_key: The private key as a hex string

        Returns:
            str: The public key as a hex string

        Raises:
            ValueError: If the private key is invalid
        """
        pass

    @abstractmethod
    def verify(self, message_hash: bytes, signature: Tuple[str, str], public_key: str) -> bool:
        """
        Verify a signature using a public key.

        Args:
            message_hash: The hash of the message
            signature: The signature as (r, s) hex strings
            public_key: The public key as a hex string

        Returns:
            bool: Whether the signature is valid
        """
        pass

    @abstractmethod
    def pedersen_hash(self, elements: List[int]) -> bytes:
        """
        Calculate the Pedersen hash of a list of integers.

        Args:
            elements: List of integers to hash

        Returns:
            bytes: The hash result

        Raises:
            ValueError: If the calculation fails
        """
        pass


## edgex_sdk/internal/starkex_signing_adapter.py
"""
StarkEx signing adapter for the EdgeX Python SDK.

This module provides an implementation of the signing adapter interface
that uses the StarkWare cryptographic primitives for signing operations.
"""

import binascii
import math
import secrets
from typing import List, Tuple

from .signing_adapter import SigningAdapter
from ..crypto.pedersen_hash import pedersen_hash_bytes


# StarkEx curve parameters
FIELD_PRIME = 0x800000000000011000000000000000000000000000000000000000000000001
ALPHA = 1
BETA = 0x6f21413efbe40de150e596d72f7a8c5609ad26c15c915c1f4cdfcb99cee9e89
EC_ORDER = 0x800000000000010ffffffffffffffffb781126dcae7b2321e66a241adc64d2f
N_ELEMENT_BITS_ECDSA = math.floor(math.log(FIELD_PRIME, 2))
assert N_ELEMENT_BITS_ECDSA == 251

# Generator point for the Stark curve
EC_GEN = (
    0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca,
    0x5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f
)


class StarkExSigningAdapter(SigningAdapter):
    """StarkEx implementation of the signing adapter interface."""

    def sign(self, message_hash: bytes, private_key: str) -> Tuple[str, str]:
        """
        Sign a message hash using a private key.

        Args:
            message_hash: The hash of the message to sign
            private_key: The private key as a hex string

        Returns:
            Tuple[str, str]: The signature as (r, s) hex strings

        Raises:
            ValueError: If the private key is invalid or the signing fails
        """
        try:
            # Validate private key format
            binascii.unhexlify(private_key)
        except binascii.Error:
            raise ValueError("Invalid private key hex string")

        # Convert message hash to integer
        msg_hash_int = int.from_bytes(message_hash, byteorder='big')

        # Ensure the message hash is in the valid range
        # Use the same modulus as the Golang SDK (EC_ORDER, which is starkcurve.N)
        msg_hash_int = msg_hash_int % EC_ORDER

        # Convert private key to integer
        priv_key_int = int(private_key, 16)

        # Ensure the private key is in the valid range
        # For testing purposes, we'll just take the modulus
        priv_key_int = priv_key_int % EC_ORDER
        if priv_key_int == 0:
            priv_key_int = 1

        # Sign the message
        r, s = self._sign(msg_hash_int, priv_key_int)

        # Convert r and s to hex strings
        r_hex = format(r, '064x')
        s_hex = format(s, '064x')

        return r_hex, s_hex

    def get_public_key(self, private_key: str) -> str:
        """
        Get the public key from a private key.

        Args:
            private_key: The private key as a hex string

        Returns:
            str: The public key as a hex string

        Raises:
            ValueError: If the private key is invalid
        """
        try:
            # Validate private key format
            binascii.unhexlify(private_key)
        except binascii.Error:
            raise ValueError("Invalid private key hex string")

        # Convert private key to integer
        priv_key_int = int(private_key, 16)

        # Ensure the private key is in the valid range
        # For testing purposes, we'll just take the modulus
        priv_key_int = priv_key_int % EC_ORDER
        if priv_key_int == 0:
            priv_key_int = 1

        # Get the public key
        public_key = self._private_to_stark_key(priv_key_int)

        # Convert public key to hex string
        public_key_hex = format(public_key, '064x')

        return public_key_hex

    def verify(self, message_hash: bytes, signature: Tuple[str, str], public_key: str) -> bool:
        """
        Verify a signature using a public key.

        Args:
            message_hash: The hash of the message
            signature: The signature as (r, s) hex strings
            public_key: The public key as a hex string

        Returns:
            bool: Whether the signature is valid
        """
        try:
            # Convert message hash to integer
            msg_hash_int = int.from_bytes(message_hash, byteorder='big')

            # Ensure the message hash is in the valid range
            # Use the same modulus as the sign method (EC_ORDER)
            msg_hash_int = msg_hash_int % EC_ORDER

            # Convert signature components to integers
            r_int = int(signature[0], 16)
            s_int = int(signature[1], 16)

            # Ensure r and s are in the valid range
            if not (1 <= r_int < 2**N_ELEMENT_BITS_ECDSA and 1 <= s_int < EC_ORDER):
                return False

            # Convert public key to integer
            pub_key_int = int(public_key, 16)

            # Verify the signature
            return self._verify(msg_hash_int, r_int, s_int, pub_key_int)
        except Exception:
            return False

    def pedersen_hash(self, elements: List[int]) -> bytes:
        """
        Calculate the Pedersen hash of a list of integers.

        This method now uses the full Pedersen hash implementation
        that follows StarkWare's specification.

        Args:
            elements: List of integers to hash

        Returns:
            bytes: The hash result

        Raises:
            ValueError: If the calculation fails
        """
        try:
            # Use the full Pedersen hash implementation
            return pedersen_hash_bytes(*elements)
        except Exception as e:
            raise ValueError(f"Failed to calculate Pedersen hash: {str(e)}")

    def _sign(self, msg_hash: int, priv_key: int) -> Tuple[int, int]:
        """
        Sign a message hash using a private key.

        Args:
            msg_hash: The hash of the message to sign as an integer
            priv_key: The private key as an integer

        Returns:
            Tuple[int, int]: The signature as (r, s) integers
        """
        # Choose a valid k. In our version of ECDSA not every k value is valid,
        # and there is a negligible probability a drawn k cannot be used for signing.
        # This is why we have this loop.
        while True:
            # Use random nonce generation like the Go SDK
            k = self._generate_random_k()

            # Cannot fail because 0 < k < EC_ORDER and EC_ORDER is prime.
            x = self._ec_mult(k, EC_GEN)[0]

            # DIFF: in classic ECDSA, we take int(x) % n.
            r = int(x)
            if not (1 <= r < 2**N_ELEMENT_BITS_ECDSA):
                # Bad value. This fails with negligible probability.
                continue

            if (msg_hash + r * priv_key) % EC_ORDER == 0:
                # Bad value. This fails with negligible probability.
                continue

            w = self._div_mod(k, msg_hash + r * priv_key, EC_ORDER)
            if not (1 <= w < 2**N_ELEMENT_BITS_ECDSA):
                # Bad value. This fails with negligible probability.
                continue

            s = self._inv_mod_curve_size(w)
            return r, s

    def _verify(self, msg_hash: int, r: int, s: int, public_key: int) -> bool:
        """
        Verify a signature using a public key.

        Args:
            msg_hash: The hash of the message as an integer
            r: The r component of the signature as an integer
            s: The s component of the signature as an integer
            public_key: The public key as an integer

        Returns:
            bool: Whether the signature is valid
        """
        # Compute w = s^-1 (mod EC_ORDER).
        if not (1 <= s < EC_ORDER):
            return False

        w = self._inv_mod_curve_size(s)

        # Preassumptions:
        # DIFF: in classic ECDSA, we assert 1 <= r, w <= EC_ORDER-1.
        # Since r, w < 2**N_ELEMENT_BITS_ECDSA < EC_ORDER, we only need to verify r, w != 0.
        if not (1 <= r < 2**N_ELEMENT_BITS_ECDSA and 1 <= w < 2**N_ELEMENT_BITS_ECDSA):
            return False

        if not (0 <= msg_hash < 2**N_ELEMENT_BITS_ECDSA):
            return False

        # Only the x coordinate of the point is given, check the two possibilities for the y
        # coordinate.
        try:
            y = self._get_y_coordinate(public_key)
        except ValueError:
            return False

        # Verify it is on the curve.
        if (y**2 - (public_key**3 + ALPHA * public_key + BETA)) % FIELD_PRIME != 0:
            return False

        # Try both possible y coordinates.
        for y_candidate in [y, (-y) % FIELD_PRIME]:
            public_key_point = (public_key, y_candidate)

            # Signature validation.
            try:
                # Calculate u1 = msg_hash * w mod n
                u1 = (msg_hash * w) % EC_ORDER

                # Calculate u2 = r * w mod n
                u2 = (r * w) % EC_ORDER

                # Calculate u1*G + u2*Q
                point1 = self._ec_mult(u1, EC_GEN)
                point2 = self._ec_mult(u2, public_key_point)
                point = self._ec_add(point1, point2)

                # The signature is valid if the x-coordinate of the resulting point equals r
                if point[0] == r:
                    return True
            except Exception:
                continue

        return False

    def _generate_random_k(self) -> int:
        """
        Generate a cryptographically secure random k value.

        Returns:
            int: The generated k value in range [1, EC_ORDER)
        """
        # Generate a cryptographically secure random number in the range [1, EC_ORDER)
        # This matches the Go implementation's approach of using random nonces
        return secrets.randbelow(EC_ORDER - 1) + 1

    def _private_to_stark_key(self, priv_key: int) -> int:
        """
        Convert a private key to a Stark public key.

        Args:
            priv_key: The private key as an integer

        Returns:
            int: The public key as an integer
        """
        return self._private_key_to_ec_point_on_stark_curve(priv_key)[0]

    def _private_key_to_ec_point_on_stark_curve(self, priv_key: int) -> Tuple[int, int]:
        """
        Convert a private key to an EC point on the Stark curve.

        Args:
            priv_key: The private key as an integer

        Returns:
            Tuple[int, int]: The EC point as (x, y) coordinates
        """
        # Ensure the private key is in the valid range
        # For testing purposes, we'll just take the modulus
        priv_key = priv_key % EC_ORDER
        if priv_key == 0:
            priv_key = 1

        return self._ec_mult(priv_key, EC_GEN)

    def _inv_mod_curve_size(self, x: int) -> int:
        """
        Calculate the modular inverse of x modulo the curve order.

        Args:
            x: The value to invert

        Returns:
            int: The modular inverse
        """
        return self._div_mod(1, x, EC_ORDER)

    def _div_mod(self, n: int, m: int, p: int) -> int:
        """
        Calculate (n / m) mod p.

        Args:
            n: The numerator
            m: The denominator
            p: The modulus

        Returns:
            int: The result of the division modulo p
        """
        return (n * pow(m, -1, p)) % p

    def _is_quad_residue(self, n: int, p: int) -> bool:
        """
        Check if n is a quadratic residue modulo p.

        Args:
            n: The number to check
            p: The modulus

        Returns:
            bool: True if n is a quadratic residue modulo p, False otherwise
        """
        return pow(n, (p - 1) // 2, p) == 1

    def _sqrt_mod(self, n: int, p: int) -> int:
        """
        Calculate the square root of n modulo p.

        Args:
            n: The number to take the square root of
            p: The modulus

        Returns:
            int: The square root of n modulo p
        """
        # Handle the case where p = 3 mod 4
        if p % 4 == 3:
            return pow(n, (p + 1) // 4, p)

        # Handle the general case using the Tonelli-Shanks algorithm
        q = p - 1
        s = 0
        while q % 2 == 0:
            q //= 2
            s += 1

        # Find a non-residue
        z = 2
        while self._is_quad_residue(z, p):
            z += 1

        m = s
        c = pow(z, q, p)
        t = pow(n, q, p)
        r = pow(n, (q + 1) // 2, p)

        while t != 1:
            # Find the least i, 0 < i < m, such that t^(2^i) = 1
            i = 0
            t_sq = t
            while t_sq != 1 and i < m - 1:
                t_sq = (t_sq * t_sq) % p
                i += 1

            # Calculate b = c^(2^(m-i-1))
            b = pow(c, 2**(m - i - 1), p)

            m = i
            c = (b * b) % p
            t = (t * b * b) % p
            r = (r * b) % p

        return r

    def _get_y_coordinate(self, x: int) -> int:
        """
        Given the x coordinate of a point, returns a possible y coordinate such that
        together the point (x,y) is on the curve.

        Args:
            x: The x coordinate

        Returns:
            int: A possible y coordinate

        Raises:
            ValueError: If x is not a valid x coordinate on the curve
        """
        y_squared = (x * x * x + ALPHA * x + BETA) % FIELD_PRIME
        if not self._is_quad_residue(y_squared, FIELD_PRIME):
            raise ValueError("Given x coordinate does not represent any point on the elliptic curve.")

        return self._sqrt_mod(y_squared, FIELD_PRIME)

    def _ec_add(self, p1: Tuple[int, int], p2: Tuple[int, int]) -> Tuple[int, int]:
        """
        Add two points on the elliptic curve.

        Args:
            p1: The first point as (x, y) coordinates
            p2: The second point as (x, y) coordinates

        Returns:
            Tuple[int, int]: The resulting point as (x, y) coordinates
        """
        if p1[0] == p2[0]:
            if (p1[1] + p2[1]) % FIELD_PRIME == 0:
                # The points are negatives of each other, return the point at infinity
                # We represent the point at infinity as None, but this should never happen
                # in our use case, so we raise an exception instead
                raise ValueError("Points are negatives of each other")

            # The points are the same, so we're doubling
            return self._ec_double(p1)

        # Calculate the slope
        slope = self._div_mod(p2[1] - p1[1], p2[0] - p1[0], FIELD_PRIME)

        # Calculate the new point
        x3 = (slope * slope - p1[0] - p2[0]) % FIELD_PRIME
        y3 = (slope * (p1[0] - x3) - p1[1]) % FIELD_PRIME

        return (x3, y3)

    def _ec_double(self, p: Tuple[int, int]) -> Tuple[int, int]:
        """
        Double a point on the elliptic curve.

        Args:
            p: The point to double as (x, y) coordinates

        Returns:
            Tuple[int, int]: The resulting point as (x, y) coordinates
        """
        # Calculate the slope
        slope = self._div_mod(3 * p[0] * p[0] + ALPHA, 2 * p[1], FIELD_PRIME)

        # Calculate the new point
        x3 = (slope * slope - 2 * p[0]) % FIELD_PRIME
        y3 = (slope * (p[0] - x3) - p[1]) % FIELD_PRIME

        return (x3, y3)

    def _ec_mult(self, m: int, p: Tuple[int, int]) -> Tuple[int, int]:
        """
        Multiply a point on the elliptic curve by a scalar.

        Args:
            m: The scalar
            p: The point as (x, y) coordinates

        Returns:
            Tuple[int, int]: The resulting point as (x, y) coordinates
        """
        if m == 0:
            raise ValueError("Cannot multiply by 0")

        if m == 1:
            return p

        if m % 2 == 0:
            return self._ec_mult(m // 2, self._ec_double(p))
        else:
            return self._ec_add(p, self._ec_mult(m - 1, p))


## edgex_sdk/metadata/__init__.py


## edgex_sdk/metadata/client.py
from typing import Dict, Any

from ..internal.async_client import AsyncClient


class Client:
    """Client for metadata-related API endpoints."""

    def __init__(self, async_client: AsyncClient):
        """
        Initialize the metadata client.

        Args:
            async_client: The async client for common functionality
        """
        self.async_client = async_client

    async def get_metadata(self) -> Dict[str, Any]:
        """
        Get the exchange metadata.

        Returns:
            Dict[str, Any]: The exchange metadata

        Raises:
            ValueError: If the request fails
        """
        # Public endpoint - use simple GET request
        await self.async_client._ensure_session()

        url = f"{self.async_client.base_url}/api/v1/public/meta/getMetaData"

        try:
            async with self.async_client.session.get(url) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except:
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")

                resp_data = await response.json()

                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")

                return resp_data

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise ValueError(f"request failed: {str(e)}")

    async def get_server_time(self) -> Dict[str, Any]:
        """
        Get the current server time.

        Returns:
            Dict[str, Any]: The server time information

        Raises:
            ValueError: If the request fails
        """
        # Public endpoint - use simple GET request
        await self.async_client._ensure_session()

        url = f"{self.async_client.base_url}/api/v1/public/meta/getServerTime"

        try:
            async with self.async_client.session.get(url) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except:
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")

                resp_data = await response.json()

                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")

                return resp_data

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise ValueError(f"request failed: {str(e)}")


## edgex_sdk/order/__init__.py


## edgex_sdk/order/client.py
import time
from decimal import Decimal
from typing import Dict, Any, Optional, List

from ..internal.async_client import AsyncClient
from .types import (
    CreateOrderParams,
    CancelOrderParams,
    GetActiveOrderParams,
    OrderFillTransactionParams,
    TimeInForce,
    OrderType
)


class Client:
    """Client for order-related API endpoints."""

    def __init__(self, async_client: AsyncClient):
        """
        Initialize the order client.

        Args:
            async_client: The async client for common functionality
        """
        self.async_client = async_client

    async def create_order(self, params: CreateOrderParams, metadata: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a new order with the given parameters.

        Args:
            params: Order parameters
            metadata: Exchange metadata

        Returns:
            Dict[str, Any]: The created order

        Raises:
            ValueError: If required parameters are missing or invalid
        """
        # Set default TimeInForce based on order type if not specified
        if not params.time_in_force:
            if params.type == OrderType.MARKET:
                params.time_in_force = TimeInForce.IMMEDIATE_OR_CANCEL
            elif params.type == OrderType.LIMIT:
                params.time_in_force = TimeInForce.GOOD_TIL_CANCEL

        # Find the contract from metadata
        contract = None
        contract_list = metadata.get("contractList", [])
        for c in contract_list:
            if c.get("contractId") == params.contract_id:
                contract = c
                break

        if not contract:
            raise ValueError(f"contract not found: {params.contract_id}")

        # Get collateral coin from metadata
        global_data = metadata.get("global", {})
        collateral_coin = global_data.get("starkExCollateralCoin", {})

        # Parse decimal values
        try:
            size = Decimal(params.size)
            price = Decimal(params.price)
        except (ValueError, TypeError):
            raise ValueError("failed to parse size or price")

        # Convert hex resolution to decimal
        hex_resolution = contract.get("starkExResolution", "0x0")
        # Remove "0x" prefix if present
        hex_resolution = hex_resolution.replace("0x", "")
        # Parse hex string to int
        try:
            resolution_int = int(hex_resolution, 16)
            resolution = Decimal(resolution_int)
        except (ValueError, TypeError):
            raise ValueError("failed to parse hex resolution")

        client_order_id = params.client_order_id or self.async_client.generate_uuid()

        # Calculate values
        value_dm = price * size
        amount_synthetic = int(size * resolution)
        amount_collateral = int(value_dm * Decimal("1000000"))  # Shift 6 decimal places

        # Calculate fee based on order type (maker/taker)
        try:
            fee_rate = Decimal(contract.get("defaultTakerFeeRate", "0"))
        except (ValueError, TypeError):
            raise ValueError("failed to parse fee rate")

        # Calculate fee amount in decimal with 6 decimal places
        amount_fee_dm = (value_dm * fee_rate).quantize(Decimal("0.000001"))
        amount_fee_str = str(amount_fee_dm)

        # Convert to the required integer format for the protocol
        amount_fee = int(amount_fee_dm * Decimal("1000000"))  # Shift 6 decimal places

        nonce = self.async_client.calc_nonce(client_order_id)
        l2_expire_time = int(time.time() * 1000) + (14 * 24 * 60 * 60 * 1000)  # 14 days

        # Calculate signature using asset IDs from metadata
        expire_time_unix = l2_expire_time // (60 * 60 * 1000)

        sig_hash = self.async_client.calc_limit_order_hash(
            contract.get("starkExSyntheticAssetId", ""),
            collateral_coin.get("starkExAssetId", ""),
            collateral_coin.get("starkExAssetId", ""),
            params.side.value == "BUY",
            amount_synthetic,
            amount_collateral,
            amount_fee,
            nonce,
            self.async_client.get_account_id(),
            expire_time_unix
        )

        # Sign the order
        sig = self.async_client.sign(sig_hash)

        # Convert signature to string (include v component like Go SDK, even though it's empty)
        sig_str = f"{sig.r}{sig.s}{sig.v if hasattr(sig, 'v') and sig.v else ''}"



        # Create order request
        account_id = str(self.async_client.get_account_id())
        nonce_str = str(nonce)
        l2_expire_time_str = str(l2_expire_time)
        expire_time_str = str(l2_expire_time - 864000000)  # 10 days earlier
        value_str = str(value_dm)

        price_str = params.price if params.type == OrderType.LIMIT else "0"

        # Prepare request data
        request_data = {
            "accountId": account_id,
            "contractId": params.contract_id,
            "price": price_str,
            "size": params.size,
            "type": params.type.value,  # Use .value to get the string value
            "timeInForce": params.time_in_force.value,  # Use .value to get the string value
            "side": params.side.value,  # Use .value to get the string value
            "l2Signature": sig_str,
            "l2Nonce": nonce_str,
            "l2ExpireTime": l2_expire_time_str,
            "l2Value": value_str,
            "l2Size": params.size,
            "l2LimitFee": amount_fee_str,
            "clientOrderId": client_order_id,
            "expireTime": expire_time_str,
            "reduceOnly": params.reduce_only
        }

        # Execute request using async client
        return await self.async_client.make_authenticated_request(
            method="POST",
            path="/api/v1/private/order/createOrder",
            data=request_data
        )

    async def cancel_order(self, params: CancelOrderParams) -> Dict[str, Any]:
        """
        Cancel a specific order.

        Args:
            params: Cancel order parameters

        Returns:
            Dict[str, Any]: The cancellation result

        Raises:
            ValueError: If required parameters are missing or invalid
        """
        account_id = str(self.async_client.get_account_id())

        if params.order_id:
            path = "/api/v1/private/order/cancelOrderById"
            request_data = {
                "accountId": account_id,
                "orderIdList": [params.order_id]
            }
        elif params.client_id:
            path = "/api/v1/private/order/cancelOrderByClientOrderId"
            request_data = {
                "accountId": account_id,
                "clientOrderIdList": [params.client_id]
            }
        elif params.contract_id:
            path = "/api/v1/private/order/cancelAllOrder"
            request_data = {
                "accountId": account_id,
                "filterContractIdList": [params.contract_id]
            }
        else:
            raise ValueError("must provide either order_id, client_id, or contract_id")

        # Execute request using async client
        return await self.async_client.make_authenticated_request(
            method="POST",
            path=path,
            data=request_data
        )

    async def get_active_orders(self, params: GetActiveOrderParams) -> Dict[str, Any]:
        """
        Get active orders with pagination and filters.

        Args:
            params: Active order query parameters

        Returns:
            Dict[str, Any]: The active orders

        Raises:
            ValueError: If the request fails
        """
        # Build query parameters
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(params.filter_coin_id_list)
        if params.filter_contract_id_list:
            query_params["filterContractIdList"] = ",".join(params.filter_contract_id_list)
        if params.filter_type_list:
            query_params["filterTypeList"] = ",".join(params.filter_type_list)
        if params.filter_status_list:
            query_params["filterStatusList"] = ",".join(params.filter_status_list)

        # Add boolean filters
        if params.filter_is_liquidate is not None:
            query_params["filterIsLiquidateList"] = str(params.filter_is_liquidate).lower()
        if params.filter_is_deleverage is not None:
            query_params["filterIsDeleverageList"] = str(params.filter_is_deleverage).lower()
        if params.filter_is_position_tpsl is not None:
            query_params["filterIsPositionTpslList"] = str(params.filter_is_position_tpsl).lower()

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        # Execute request using async client
        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/order/getActiveOrderPage",
            params=query_params
        )

    async def get_order_fill_transactions(self, params: OrderFillTransactionParams) -> Dict[str, Any]:
        """
        Get order fill transactions with pagination and filters.

        Args:
            params: Order fill transaction query parameters

        Returns:
            Dict[str, Any]: The order fill transactions

        Raises:
            ValueError: If the request fails
        """
        # Build query parameters
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(params.filter_coin_id_list)
        if params.filter_contract_id_list:
            query_params["filterContractIdList"] = ",".join(params.filter_contract_id_list)
        if params.filter_order_id_list:
            query_params["filterOrderIdList"] = ",".join(params.filter_order_id_list)

        # Add boolean filters
        if params.filter_is_liquidate is not None:
            query_params["filterIsLiquidateList"] = str(params.filter_is_liquidate).lower()
        if params.filter_is_deleverage is not None:
            query_params["filterIsDeleverageList"] = str(params.filter_is_deleverage).lower()
        if params.filter_is_position_tpsl is not None:
            query_params["filterIsPositionTpslList"] = str(params.filter_is_position_tpsl).lower()

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        # Execute request using async client
        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/order/getHistoryOrderFillTransactionPage",
            params=query_params
        )

    async def get_max_order_size(self, contract_id: str, price: float) -> Dict[str, Any]:
        """
        Get the maximum order size for a given contract and price.

        Args:
            contract_id: The contract ID
            price: The price

        Returns:
            Dict[str, Any]: The maximum order size information

        Raises:
            ValueError: If the request fails
        """
        # Build request body (API expects POST with JSON body)
        data = {
            "accountId": str(self.async_client.get_account_id()),
            "contractId": contract_id,
            "price": str(price)
        }

        # Execute request using async client
        return await self.async_client.make_authenticated_request(
            method="POST",
            path="/api/v1/private/order/getMaxCreateOrderSize",
            data=data
        )


## edgex_sdk/order/types.py
from dataclasses import dataclass
from enum import Enum
from typing import List, Optional, Dict, Any


class TimeInForce(str, Enum):
    """Time in force options for orders."""
    UNKNOWN_TIME_IN_FORCE = "UNKNOWN_TIME_IN_FORCE"
    GOOD_TIL_CANCEL = "GOOD_TIL_CANCEL"
    FILL_OR_KILL = "FILL_OR_KILL"
    IMMEDIATE_OR_CANCEL = "IMMEDIATE_OR_CANCEL"
    POST_ONLY = "POST_ONLY"


class OrderSide(str, Enum):
    """Order side options."""
    BUY = "BUY"
    SELL = "SELL"


class ResponseCode(str, Enum):
    """API response codes."""
    SUCCESS = "SUCCESS"


class OrderType(str, Enum):
    """Order type options."""
    UNKNOWN = "UNKNOWN_ORDER_TYPE"
    LIMIT = "LIMIT"
    MARKET = "MARKET"
    STOP_LIMIT = "STOP_LIMIT"
    STOP_MARKET = "STOP_MARKET"
    TAKE_PROFIT_LIMIT = "TAKE_PROFIT_LIMIT"
    TAKE_PROFIT_MARKET = "TAKE_PROFIT_MARKET"


@dataclass
class OrderFilterParams:
    """Common filter types used across different order APIs."""
    filter_coin_id_list: List[str] = None  # Filter by coin IDs, empty means all coins
    filter_contract_id_list: List[str] = None  # Filter by contract IDs, empty means all contracts
    filter_type_list: List[str] = None  # Filter by order types
    filter_status_list: List[str] = None  # Filter by order statuses
    filter_is_liquidate: Optional[bool] = None  # Filter by liquidation status
    filter_is_deleverage: Optional[bool] = None  # Filter by deleverage status
    filter_is_position_tpsl: Optional[bool] = None  # Filter by position take-profit/stop-loss status
    
    def __post_init__(self):
        """Initialize empty lists."""
        if self.filter_coin_id_list is None:
            self.filter_coin_id_list = []
        if self.filter_contract_id_list is None:
            self.filter_contract_id_list = []
        if self.filter_type_list is None:
            self.filter_type_list = []
        if self.filter_status_list is None:
            self.filter_status_list = []


@dataclass
class PaginationParams:
    """Common pagination parameters."""
    size: str = ""  # Size of the page, must be greater than 0 and less than or equal to 100/200
    offset_data: str = ""  # Offset data for pagination. Empty string gets the first page


@dataclass
class OrderFillTransactionParams(PaginationParams, OrderFilterParams):
    """Parameters for getting order fill transactions."""
    filter_order_id_list: List[str] = None  # Filter by order IDs, empty means all orders
    filter_start_created_time_inclusive: int = 0  # Filter start time (inclusive), 0 means from earliest
    filter_end_created_time_exclusive: int = 0  # Filter end time (exclusive), 0 means until latest
    
    def __post_init__(self):
        """Initialize empty lists."""
        super().__post_init__()
        if self.filter_order_id_list is None:
            self.filter_order_id_list = []


@dataclass
class GetActiveOrderParams(PaginationParams, OrderFilterParams):
    """Parameters for getting active orders."""
    filter_start_created_time_inclusive: int = 0  # Filter start time (inclusive), 0 means from earliest
    filter_end_created_time_exclusive: int = 0  # Filter end time (exclusive), 0 means until latest


@dataclass
class GetHistoryOrderParams(PaginationParams, OrderFilterParams):
    """Parameters for getting historical orders."""
    filter_start_created_time_inclusive: int = 0  # Filter start time (inclusive), 0 means from earliest
    filter_end_created_time_exclusive: int = 0  # Filter end time (exclusive), 0 means until latest


@dataclass
class CreateOrderParams:
    """Parameters for creating an order."""
    contract_id: str
    price: str
    size: str
    type: OrderType
    side: str
    client_order_id: Optional[str] = None
    l2_expire_time: Optional[int] = None
    time_in_force: Optional[str] = None
    reduce_only: bool = False


@dataclass
class CancelOrderParams:
    """Parameters for canceling orders."""
    order_id: str = ""  # Order ID to cancel
    client_id: str = ""  # Client order ID to cancel
    contract_id: str = ""  # Contract ID for canceling all orders


class OrderResponse:
    """Response from creating an order."""
    code: str
    data: Dict[str, Any]
    error_param: Optional[Dict[str, Any]]
    request_time: str
    response_time: str
    trace_id: str
    
    def __init__(self, response_data: Dict[str, Any]):
        """Initialize from response data."""
        self.code = response_data.get("code", "")
        self.data = response_data.get("data", {})
        self.error_param = response_data.get("errorParam")
        self.request_time = response_data.get("requestTime", "")
        self.response_time = response_data.get("responseTime", "")
        self.trace_id = response_data.get("traceId", "")


class MaxOrderSizeResponse(OrderResponse):
    """Response from getting max order size."""
    pass


class OrderListResponse(OrderResponse):
    """Response from getting a list of orders."""
    pass


class OrderPageResponse(OrderResponse):
    """Response from getting paginated orders."""
    pass


class OrderFillTransactionResponse(OrderResponse):
    """Response from getting order fill transactions."""
    pass


@dataclass
class OrderFillFilterParams(OrderFilterParams):
    """Parameters for filtering order fill transactions."""
    filter_order_id_list: List[str] = None  # Filter by order IDs, empty means all orders
    
    def __post_init__(self):
        """Initialize empty lists."""
        super().__post_init__()
        if self.filter_order_id_list is None:
            self.filter_order_id_list = []


## edgex_sdk/quote/__init__.py


## edgex_sdk/quote/client.py
from typing import Dict, Any, List

from ..internal.async_client import AsyncClient


class GetKLineParams:
    """Parameters for getting K-line data."""

    def __init__(
        self,
        contract_id: str,
        interval: str,
        size: str = "",
        offset_data: str = "",
        filter_start_time_inclusive: int = 0,
        filter_end_time_exclusive: int = 0
    ):
        self.contract_id = contract_id
        self.interval = interval
        self.size = size
        self.offset_data = offset_data
        self.filter_start_time_inclusive = filter_start_time_inclusive
        self.filter_end_time_exclusive = filter_end_time_exclusive


class GetOrderBookDepthParams:
    """Parameters for getting order book depth."""

    def __init__(
        self,
        contract_id: str,
        limit: int = 50
    ):
        self.contract_id = contract_id
        self.limit = limit


class GetMultiContractKLineParams:
    """Parameters for getting K-line data for multiple contracts."""

    def __init__(
        self,
        contract_id_list: List[str],
        interval: str,
        limit: int = 1
    ):
        self.contract_id_list = contract_id_list
        self.interval = interval
        self.limit = limit


class Client:
    """Client for quote-related API endpoints."""

    def __init__(self, async_client: AsyncClient):
        """
        Initialize the quote client.

        Args:
            async_client: The async client for common functionality
        """
        self.async_client = async_client

    async def get_quote_summary(self, contract_id: str) -> Dict[str, Any]:
        """
        Get the quote summary for a given contract.

        Args:
            contract_id: The contract ID

        Returns:
            Dict[str, Any]: The quote summary

        Raises:
            ValueError: If the request fails
        """
        # Public endpoint - use simple GET request
        await self.async_client._ensure_session()

        url = f"{self.async_client.base_url}/api/v1/public/quote/getTicketSummary"
        params = {
            "contractId": contract_id
        }

        try:
            async with self.async_client.session.get(url, params=params) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except:
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")

                resp_data = await response.json()

                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")

                return resp_data

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise ValueError(f"request failed: {str(e)}")

    async def get_24_hour_quote(self, contract_id: str) -> Dict[str, Any]:
        """
        Get the 24-hour quotes for a given contract.

        Args:
            contract_id: The contract ID

        Returns:
            Dict[str, Any]: The 24-hour quotes

        Raises:
            ValueError: If the request fails
        """
        # Public endpoint - use simple GET request
        await self.async_client._ensure_session()

        url = f"{self.async_client.base_url}/api/v1/public/quote/getTicker"
        params = {
            "contractId": contract_id
        }

        try:
            async with self.async_client.session.get(url, params=params) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except:
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")

                resp_data = await response.json()

                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")

                return resp_data

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise ValueError(f"request failed: {str(e)}")

    async def get_k_line(self, params: GetKLineParams) -> Dict[str, Any]:
        """
        Get the K-line data for a contract.

        Args:
            params: K-line query parameters

        Returns:
            Dict[str, Any]: The K-line data

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.async_client.base_url}/api/v1/public/quote/getKline"
        query_params = {
            "contractId": params.contract_id,
            "interval": params.interval
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add time filters
        if params.filter_start_time_inclusive > 0:
            query_params["filterStartTimeInclusive"] = str(params.filter_start_time_inclusive)
        if params.filter_end_time_exclusive > 0:
            query_params["filterEndTimeExclusive"] = str(params.filter_end_time_exclusive)

        # Public endpoint - use simple GET request
        await self.async_client._ensure_session()

        url = f"{self.async_client.base_url}/api/v1/public/quote/getKline"

        try:
            async with self.async_client.session.get(url, params=query_params) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except:
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")

                resp_data = await response.json()

                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")

                return resp_data

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise ValueError(f"request failed: {str(e)}")

    async def get_order_book_depth(self, params: GetOrderBookDepthParams) -> Dict[str, Any]:
        """
        Get the order book depth for a contract.

        Args:
            params: Order book depth query parameters

        Returns:
            Dict[str, Any]: The order book depth

        Raises:
            ValueError: If the request fails
        """
        url = f"{self.async_client.base_url}/api/v1/public/quote/getDepth"
        query_params = {
            "contractId": params.contract_id,
            "level": str(params.limit)  # The API expects 'level', not 'limit'
        }

        # Public endpoint - use simple GET request
        await self.async_client._ensure_session()

        url = f"{self.async_client.base_url}/api/v1/public/quote/getDepth"

        try:
            async with self.async_client.session.get(url, params=query_params) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except:
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")

                resp_data = await response.json()

                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")

                return resp_data

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise ValueError(f"request failed: {str(e)}")

    async def get_multi_contract_k_line(self, params: GetMultiContractKLineParams) -> Dict[str, Any]:
        """
        Get the K-line data for multiple contracts.

        Args:
            params: Multi-contract K-line query parameters

        Returns:
            Dict[str, Any]: The K-line data for multiple contracts

        Raises:
            ValueError: If the request fails
        """
        # Public endpoint - use simple GET request
        await self.async_client._ensure_session()

        url = f"{self.async_client.base_url}/api/v1/public/quote/getMultiContractKline"
        query_params = {
            "contractIdList": ",".join(params.contract_id_list),
            "interval": params.interval,
            "limit": str(params.limit)
        }

        try:
            async with self.async_client.session.get(url, params=query_params) as response:
                if response.status != 200:
                    try:
                        error_detail = await response.json()
                        raise ValueError(f"request failed with status code: {response.status}, response: {error_detail}")
                    except:
                        text = await response.text()
                        raise ValueError(f"request failed with status code: {response.status}, response: {text}")

                resp_data = await response.json()

                if resp_data.get("code") != "SUCCESS":
                    error_param = resp_data.get("errorParam")
                    if error_param:
                        raise ValueError(f"request failed with error params: {error_param}")
                    raise ValueError(f"request failed with code: {resp_data.get('code')}")

                return resp_data

        except Exception as e:
            if isinstance(e, ValueError):
                raise
            raise ValueError(f"request failed: {str(e)}")


## edgex_sdk/transfer/__init__.py


## edgex_sdk/transfer/client.py
from typing import Dict, Any, List

from ..internal.async_client import AsyncClient


class GetTransferOutByIdParams:
    """Parameters for getting transfer out records by ID."""

    def __init__(self, transfer_id_list: List[str]):
        self.transfer_id_list = transfer_id_list


class GetTransferInByIdParams:
    """Parameters for getting transfer in records by ID."""

    def __init__(self, transfer_id_list: List[str]):
        self.transfer_id_list = transfer_id_list


class GetWithdrawAvailableAmountParams:
    """Parameters for getting available withdrawal amount."""

    def __init__(self, coin_id: str):
        self.coin_id = coin_id


class CreateTransferOutParams:
    """Parameters for creating a transfer out order."""

    def __init__(
        self,
        coin_id: str,
        amount: str,
        address: str,
        network: str,
        memo: str = "",
        client_order_id: str = None
    ):
        self.coin_id = coin_id
        self.amount = amount
        self.address = address
        self.network = network
        self.memo = memo
        self.client_order_id = client_order_id


class GetTransferOutPageParams:
    """Parameters for getting transfer out page."""

    def __init__(self, size: str = "10", offset_data: str = "", filter_coin_id_list: List[str] = None,
                 filter_status_list: List[str] = None, filter_start_created_time_inclusive: int = 0,
                 filter_end_created_time_exclusive: int = 0):
        self.size = size
        self.offset_data = offset_data
        self.filter_coin_id_list = filter_coin_id_list or []
        self.filter_status_list = filter_status_list or []
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class GetTransferInPageParams:
    """Parameters for getting transfer in page."""

    def __init__(self, size: str = "10", offset_data: str = "", filter_coin_id_list: List[str] = None,
                 filter_status_list: List[str] = None, filter_start_created_time_inclusive: int = 0,
                 filter_end_created_time_exclusive: int = 0):
        self.size = size
        self.offset_data = offset_data
        self.filter_coin_id_list = filter_coin_id_list or []
        self.filter_status_list = filter_status_list or []
        self.filter_start_created_time_inclusive = filter_start_created_time_inclusive
        self.filter_end_created_time_exclusive = filter_end_created_time_exclusive


class Client:
    """Client for transfer-related API endpoints."""

    def __init__(self, async_client: AsyncClient):
        """
        Initialize the transfer client.

        Args:
            async_client: The async client for common functionality
        """
        self.async_client = async_client

    async def get_transfer_out_by_id(self, params: GetTransferOutByIdParams) -> Dict[str, Any]:
        """
        Get transfer out records by ID.

        Args:
            params: Transfer out query parameters

        Returns:
            Dict[str, Any]: The transfer out records

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id()),
            "transferIdList": ",".join(params.transfer_id_list)
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/transfer/getTransferOutById",
            params=query_params
        )

    async def get_transfer_in_by_id(self, params: GetTransferInByIdParams) -> Dict[str, Any]:
        """
        Get transfer in records by ID.

        Args:
            params: Transfer in query parameters

        Returns:
            Dict[str, Any]: The transfer in records

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id()),
            "transferIdList": ",".join(params.transfer_id_list)
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/transfer/getTransferInById",
            params=query_params
        )

    async def get_withdraw_available_amount(self, params: GetWithdrawAvailableAmountParams) -> Dict[str, Any]:
        """
        Get the available withdrawal amount.

        Args:
            params: Withdrawal available amount query parameters

        Returns:
            Dict[str, Any]: The available withdrawal amount

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id()),
            "coinId": params.coin_id
        }

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/transfer/getTransferOutAvailableAmount",
            params=query_params
        )

    async def create_transfer_out(self, params: CreateTransferOutParams, metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Create a new transfer out order.

        Args:
            params: Transfer out parameters
            metadata: Exchange metadata (optional, not used in current implementation)

        Returns:
            Dict[str, Any]: The created transfer out order

        Raises:
            ValueError: If the request fails
        """
        client_order_id = params.client_order_id or self.async_client.generate_uuid()

        data = {
            "accountId": str(self.async_client.get_account_id()),
            "coinId": params.coin_id,
            "amount": params.amount,
            "address": params.address,
            "network": params.network,
            "clientOrderId": client_order_id
        }

        if params.memo:
            data["memo"] = params.memo

        # TODO: Implement signature calculation for transfer out
        # This would require:
        # 1. Asset ID from metadata based on coin_id
        # 2. Receiver public key from address
        # 3. Position IDs for sender, receiver, and fee
        # 4. Proper expiration time calculation
        # 5. Call to calc_transfer_hash and sign the result
        # For now, the API call is made without signature (may fail on actual server)

        return await self.async_client.make_authenticated_request(
            method="POST",
            path="/api/v1/private/transfer/createTransferOut",
            data=data
        )

    async def get_transfer_out_page(
        self,
        params: GetTransferOutPageParams
    ) -> Dict[str, Any]:
        """
        Get transfer out records with pagination.

        Args:
            params: Parameters for the request

        Returns:
            Dict[str, Any]: The transfer out records

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(params.filter_coin_id_list)
        if params.filter_status_list:
            query_params["filterStatusList"] = ",".join(params.filter_status_list)

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/transfer/getActiveTransferOut",
            params=query_params
        )

    async def get_transfer_in_page(
        self,
        params: GetTransferInPageParams
    ) -> Dict[str, Any]:
        """
        Get transfer in records with pagination.

        Args:
            params: Parameters for the request

        Returns:
            Dict[str, Any]: The transfer in records

        Raises:
            ValueError: If the request fails
        """
        query_params = {
            "accountId": str(self.async_client.get_account_id())
        }

        # Add pagination parameters
        if params.size:
            query_params["size"] = params.size
        if params.offset_data:
            query_params["offsetData"] = params.offset_data

        # Add filter parameters
        if params.filter_coin_id_list:
            query_params["filterCoinIdList"] = ",".join(params.filter_coin_id_list)
        if params.filter_status_list:
            query_params["filterStatusList"] = ",".join(params.filter_status_list)

        # Add time filters
        if params.filter_start_created_time_inclusive > 0:
            query_params["filterStartCreatedTimeInclusive"] = str(params.filter_start_created_time_inclusive)
        if params.filter_end_created_time_exclusive > 0:
            query_params["filterEndCreatedTimeExclusive"] = str(params.filter_end_created_time_exclusive)

        return await self.async_client.make_authenticated_request(
            method="GET",
            path="/api/v1/private/transfer/getActiveTransferIn",
            params=query_params
        )


## edgex_sdk/ws/__init__.py


## edgex_sdk/ws/client.py
import asyncio
import binascii
import json
import logging
import threading
import time
from typing import Dict, Any, List, Optional, Callable, Union

import websocket
from Crypto.Hash import keccak

from ..internal.signing_adapter import SigningAdapter

from ..internal.client import Client as InternalClient


class Client:
    """WebSocket client for real-time data."""

    def __init__(self, url: str, is_private: bool, account_id: int, stark_pri_key: str, signing_adapter: Optional[SigningAdapter] = None):
        """
        Initialize the WebSocket client.

        Args:
            url: WebSocket URL
            is_private: Whether this is a private WebSocket connection
            account_id: Account ID for authentication
            stark_pri_key: Stark private key for signing
        """
        self.url = url
        self.is_private = is_private
        self.account_id = account_id
        self.stark_pri_key = stark_pri_key

        # Use the provided signing adapter (required)
        if signing_adapter is None:
            raise ValueError("signing_adapter is required")
        self.signing_adapter = signing_adapter

        self.conn = None
        self.handlers = {}
        self.done = threading.Event()
        self.ping_thread = None
        self.subscriptions = set()
        self.on_connect_hooks = []
        self.on_message_hooks = []
        self.on_disconnect_hooks = []

        self.logger = logging.getLogger(__name__)

    def connect(self):
        """
        Establish a WebSocket connection.

        Raises:
            ValueError: If the connection fails
        """
        headers = {}
        url = self.url

        # Add timestamp parameter for both public and private connections
        timestamp = int(time.time() * 1000)

        if self.is_private:
            # Add timestamp header
            headers["X-edgeX-Api-Timestamp"] = str(timestamp)

            # Generate signature content (no ? separator, matching Go SDK)
            path = f"/api/v1/private/wsaccountId={self.account_id}"
            sign_content = f"{timestamp}GET{path}"

            # Hash the content
            keccak_hash = keccak.new(digest_bits=256)
            keccak_hash.update(sign_content.encode())
            message_hash = keccak_hash.digest()

            # Sign the message using the signing adapter
            try:
                r, s = self.signing_adapter.sign(message_hash, self.stark_pri_key)
            except Exception as e:
                raise ValueError(f"failed to sign message: {str(e)}")

            # Set signature header
            headers["X-edgeX-Api-Signature"] = f"{r}{s}"
        else:
            # For public connections, add timestamp as URL parameter
            separator = "&" if "?" in url else "?"
            url = f"{url}{separator}timestamp={timestamp}"

        # Create WebSocket connection
        try:
            self.conn = websocket.create_connection(url, header=headers)
        except Exception as e:
            raise ValueError(f"failed to connect to WebSocket: {str(e)}")

        # Start ping thread
        self.done.clear()
        self.ping_thread = threading.Thread(target=self._ping_loop)
        self.ping_thread.daemon = True
        self.ping_thread.start()

        # Start message handling thread
        self.message_thread = threading.Thread(target=self._handle_messages)
        self.message_thread.daemon = True
        self.message_thread.start()

        # Call connect hooks
        for hook in self.on_connect_hooks:
            hook()

    def close(self):
        """Close the WebSocket connection."""
        self.done.set()

        if self.conn:
            self.conn.close()
            self.conn = None

    def _ping_loop(self):
        """Send periodic ping messages."""
        while not self.done.is_set():
            if self.conn:
                ping_msg = {
                    "type": "ping",
                    "time": str(int(time.time() * 1000))
                }

                try:
                    self.conn.send(json.dumps(ping_msg))
                except Exception as e:
                    self.logger.error(f"Failed to send ping: {str(e)}")
                    break

            # Wait for 30 seconds or until done
            self.done.wait(30)

    def _handle_messages(self):
        """Process incoming WebSocket messages."""
        while not self.done.is_set():
            if not self.conn:
                break

            try:
                message = self.conn.recv()

                # Call message hooks
                for hook in self.on_message_hooks:
                    hook(message)

                # Parse message
                try:
                    msg = json.loads(message)
                except json.JSONDecodeError:
                    continue

                # Handle ping messages
                if msg.get("type") == "ping":
                    self._handle_pong(msg.get("time", ""))
                    continue

                # Handle quote events
                if msg.get("type") == "quote-event":
                    channel = msg.get("channel", "")
                    channel_type = channel.split(".")[0] if "." in channel else channel

                    if channel_type in self.handlers:
                        self.handlers[channel_type](message)
                    continue

                # Call registered handlers for other message types
                msg_type = msg.get("type", "")
                if msg_type in self.handlers:
                    self.handlers[msg_type](message)

            except Exception as e:
                self.logger.error(f"Error handling message: {str(e)}")

                # Call disconnect hooks
                for hook in self.on_disconnect_hooks:
                    hook(e)

                break

    def _handle_pong(self, timestamp: str):
        """
        Send pong response to server ping.

        Args:
            timestamp: The timestamp from the ping message
        """
        pong_msg = {
            "type": "pong",
            "time": timestamp
        }

        try:
            self.conn.send(json.dumps(pong_msg))
        except Exception as e:
            self.logger.error(f"Failed to send pong: {str(e)}")

    def subscribe(self, topic: str, params: Dict[str, Any] = None) -> bool:
        """
        Subscribe to a topic (for public WebSocket).

        Args:
            topic: The topic to subscribe to
            params: Optional parameters for the subscription

        Returns:
            bool: Whether the subscription was successful

        Raises:
            ValueError: If the subscription fails
        """
        if self.is_private:
            raise ValueError("cannot subscribe on private WebSocket connection")

        if not self.conn:
            raise ValueError("WebSocket connection is not established")

        sub_msg = {
            "type": "subscribe",
            "channel": topic
        }

        if params:
            sub_msg.update(params)

        try:
            self.conn.send(json.dumps(sub_msg))
            self.subscriptions.add(topic)
            return True
        except Exception as e:
            raise ValueError(f"failed to subscribe: {str(e)}")

    def unsubscribe(self, topic: str) -> bool:
        """
        Unsubscribe from a topic (for public WebSocket).

        Args:
            topic: The topic to unsubscribe from

        Returns:
            bool: Whether the unsubscription was successful

        Raises:
            ValueError: If the unsubscription fails
        """
        if self.is_private:
            raise ValueError("cannot unsubscribe on private WebSocket connection")

        if not self.conn:
            raise ValueError("WebSocket connection is not established")

        unsub_msg = {
            "type": "unsubscribe",
            "channel": topic
        }

        try:
            self.conn.send(json.dumps(unsub_msg))
            self.subscriptions.discard(topic)
            return True
        except Exception as e:
            raise ValueError(f"failed to unsubscribe: {str(e)}")

    def on_message(self, msg_type: str, handler: Callable[[str], None]):
        """
        Register a handler for a specific message type.

        Args:
            msg_type: The message type to handle
            handler: The handler function
        """
        self.handlers[msg_type] = handler

    def on_message_hook(self, hook: Callable[[str], None]):
        """
        Register a hook that will be called for all messages.

        Args:
            hook: The hook function
        """
        self.on_message_hooks.append(hook)

    def on_connect(self, hook: Callable[[], None]):
        """
        Register a hook that will be called when connection is established.

        Args:
            hook: The hook function
        """
        self.on_connect_hooks.append(hook)

    def on_disconnect(self, hook: Callable[[Exception], None]):
        """
        Register a hook that will be called when connection is closed.

        Args:
            hook: The hook function
        """
        self.on_disconnect_hooks.append(hook)


## edgex_sdk/ws/manager.py
import logging
from typing import Dict, Any, List, Optional, Callable

from ..internal.signing_adapter import SigningAdapter
from ..internal.starkex_signing_adapter import StarkExSigningAdapter
from .client import Client


class Manager:
    """Manager for WebSocket connections."""

    def __init__(self, base_url: str, account_id: int, stark_pri_key: str, signing_adapter: Optional[SigningAdapter] = None):
        """
        Initialize the WebSocket manager.

        Args:
            base_url: Base WebSocket URL
            account_id: Account ID for authentication
            stark_pri_key: Stark private key for signing
            signing_adapter: Optional signing adapter (defaults to StarkExSigningAdapter)
        """
        self.base_url = base_url
        self.account_id = account_id
        self.stark_pri_key = stark_pri_key

        # Use StarkExSigningAdapter as default if none provided
        if signing_adapter is None:
            signing_adapter = StarkExSigningAdapter()
        self.signing_adapter = signing_adapter

        self.public_client = None
        self.private_client = None

        self.logger = logging.getLogger(__name__)

    def get_public_client(self) -> Client:
        """
        Get the public WebSocket client.

        Returns:
            Client: The public WebSocket client
        """
        if not self.public_client:
            self.public_client = Client(
                url=f"{self.base_url}/api/v1/public/ws",
                is_private=False,
                account_id=self.account_id,
                stark_pri_key=self.stark_pri_key,
                signing_adapter=self.signing_adapter
            )

        return self.public_client

    def get_private_client(self) -> Client:
        """
        Get the private WebSocket client.

        Returns:
            Client: The private WebSocket client
        """
        if not self.private_client:
            self.private_client = Client(
                url=f"{self.base_url}/api/v1/private/ws?accountId={self.account_id}",
                is_private=True,
                account_id=self.account_id,
                stark_pri_key=self.stark_pri_key,
                signing_adapter=self.signing_adapter
            )

        return self.private_client

    def connect_public(self):
        """
        Connect to the public WebSocket.

        Raises:
            ValueError: If the connection fails
        """
        client = self.get_public_client()
        client.connect()

    def connect_private(self):
        """
        Connect to the private WebSocket.

        Raises:
            ValueError: If the connection fails
        """
        client = self.get_private_client()
        client.connect()

    def disconnect_public(self):
        """Disconnect from the public WebSocket."""
        if self.public_client:
            self.public_client.close()

    def disconnect_private(self):
        """Disconnect from the private WebSocket."""
        if self.private_client:
            self.private_client.close()

    def disconnect_all(self):
        """Disconnect from all WebSockets."""
        self.disconnect_public()
        self.disconnect_private()

    def subscribe_ticker(self, contract_id: str, handler: Callable[[str], None]):
        """
        Subscribe to ticker updates for a contract.

        Args:
            contract_id: The contract ID
            handler: The handler function

        Raises:
            ValueError: If the subscription fails
        """
        client = self.get_public_client()

        # Register handler
        client.on_message("ticker", handler)

        # Subscribe to ticker channel
        channel = f"ticker.{contract_id}"
        client.subscribe(channel)

    def subscribe_kline(self, contract_id: str, interval: str, handler: Callable[[str], None]):
        """
        Subscribe to K-line updates for a contract.

        Args:
            contract_id: The contract ID
            interval: The K-line interval
            handler: The handler function

        Raises:
            ValueError: If the subscription fails
        """
        client = self.get_public_client()

        # Register handler
        client.on_message("kline", handler)

        # Subscribe to kline channel
        channel = f"kline.{contract_id}.{interval}"
        client.subscribe(channel)

    def subscribe_depth(self, contract_id: str, handler: Callable[[str], None]):
        """
        Subscribe to depth updates for a contract.

        Args:
            contract_id: The contract ID
            handler: The handler function

        Raises:
            ValueError: If the subscription fails
        """
        client = self.get_public_client()

        # Register handler
        client.on_message("depth", handler)

        # Subscribe to depth channel
        channel = f"depth.{contract_id}"
        client.subscribe(channel)

    def subscribe_trade(self, contract_id: str, handler: Callable[[str], None]):
        """
        Subscribe to trade updates for a contract.

        Args:
            contract_id: The contract ID
            handler: The handler function

        Raises:
            ValueError: If the subscription fails
        """
        client = self.get_public_client()

        # Register handler
        client.on_message("trade", handler)

        # Subscribe to trade channel
        channel = f"trade.{contract_id}"
        client.subscribe(channel)

    def subscribe_account_update(self, handler: Callable[[str], None]):
        """
        Subscribe to account updates.

        Args:
            handler: The handler function

        Raises:
            ValueError: If the subscription fails
        """
        client = self.get_private_client()

        # Register handler
        client.on_message("account", handler)

    def subscribe_order_update(self, handler: Callable[[str], None]):
        """
        Subscribe to order updates.

        Args:
            handler: The handler function

        Raises:
            ValueError: If the subscription fails
        """
        client = self.get_private_client()

        # Register handler
        client.on_message("order", handler)

    def subscribe_position_update(self, handler: Callable[[str], None]):
        """
        Subscribe to position updates.

        Args:
            handler: The handler function

        Raises:
            ValueError: If the subscription fails
        """
        client = self.get_private_client()

        # Register handler
        client.on_message("position", handler)


## examples/advanced_usage.py
"""
Advanced usage example for the EdgeX Python SDK.

This example demonstrates more advanced features of the SDK, including:
- Order management
- WebSocket integration
- Error handling
- Pagination
"""

import asyncio
import os
import logging
from decimal import Decimal
from typing import Dict, Any, List

from edgex_sdk import (
    Client,
    OrderSide,
    OrderType,
    TimeInForce,
    CreateOrderParams,
    CancelOrderParams,
    GetActiveOrderParams,
    OrderFillTransactionParams,
    GetKLineParams,
    GetOrderBookDepthParams,
    WebSocketManager
)


# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class EdgeXTrader:
    """Example trader using the EdgeX Python SDK."""
    
    def __init__(self, base_url: str, ws_url: str, account_id: int, stark_private_key: str):
        """
        Initialize the trader.
        
        Args:
            base_url: Base URL for API endpoints
            ws_url: Base URL for WebSocket endpoints
            account_id: Account ID for authentication
            stark_private_key: Stark private key for signing
        """
        self.client = Client(
            base_url=base_url,
            account_id=account_id,
            stark_private_key=stark_private_key
        )
        
        self.ws_manager = WebSocketManager(
            base_url=ws_url,
            account_id=account_id,
            stark_pri_key=stark_private_key
        )
        
        self.metadata = None
        self.contracts = {}
        self.market_data = {}
        self.active_orders = {}
        self.positions = {}
        self.assets = {}
    
    async def initialize(self):
        """Initialize the trader by fetching metadata and account information."""
        logger.info("Initializing trader...")
        
        try:
            # Get metadata
            self.metadata = await self.client.get_metadata()
            logger.info("Metadata retrieved")
            
            # Extract contracts
            contract_list = self.metadata.get("data", {}).get("contractList", [])
            for contract in contract_list:
                contract_id = contract.get("contractId")
                if contract_id:
                    self.contracts[contract_id] = contract
            
            logger.info(f"Found {len(self.contracts)} contracts")
            
            # Get account assets
            assets_response = await self.client.get_account_asset()
            self.assets = assets_response.get("data", {})
            logger.info("Account assets retrieved")
            
            # Get account positions
            positions_response = await self.client.get_account_positions()
            positions_data = positions_response.get("data", {})
            position_list = positions_data.get("positionList", [])
            for position in position_list:
                contract_id = position.get("contractId")
                if contract_id:
                    self.positions[contract_id] = position
            
            logger.info(f"Found {len(self.positions)} positions")
            
            # Get active orders
            await self.update_active_orders()
            
            # Initialize WebSocket
            await self.initialize_websocket()
            
            logger.info("Trader initialized successfully")
            return True
        
        except Exception as e:
            logger.error(f"Failed to initialize trader: {str(e)}")
            return False
    
    async def update_active_orders(self):
        """Update the list of active orders."""
        try:
            params = GetActiveOrderParams()
            active_orders_response = await self.client.get_active_orders(params)
            
            order_list = active_orders_response.get("data", {}).get("list", [])
            self.active_orders = {}
            
            for order in order_list:
                order_id = order.get("orderId")
                if order_id:
                    self.active_orders[order_id] = order
            
            logger.info(f"Found {len(self.active_orders)} active orders")
            return True
        
        except Exception as e:
            logger.error(f"Failed to update active orders: {str(e)}")
            return False
    
    async def initialize_websocket(self):
        """Initialize WebSocket connections and subscriptions."""
        try:
            # Connect to public WebSocket
            self.ws_manager.connect_public()
            logger.info("Connected to public WebSocket")
            
            # Connect to private WebSocket
            self.ws_manager.connect_private()
            logger.info("Connected to private WebSocket")
            
            # Subscribe to account updates
            self.ws_manager.subscribe_account_update(self.handle_account_update)
            logger.info("Subscribed to account updates")
            
            # Subscribe to order updates
            self.ws_manager.subscribe_order_update(self.handle_order_update)
            logger.info("Subscribed to order updates")
            
            # Subscribe to position updates
            self.ws_manager.subscribe_position_update(self.handle_position_update)
            logger.info("Subscribed to position updates")

            # Subscribe to market data for BTCUSDT (contract ID: 10000001)
            self.ws_manager.subscribe_ticker("10000001", self.handle_ticker_update)
            self.ws_manager.subscribe_kline("10000001", "1m", self.handle_kline_update)
            self.ws_manager.subscribe_depth("10000001", self.handle_depth_update)
            logger.info("Subscribed to market data for BTCUSDT (10000001)")
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to initialize WebSocket: {str(e)}")
            return False
    
    def handle_account_update(self, message: str):
        """
        Handle account update messages from WebSocket.
        
        Args:
            message: The WebSocket message
        """
        try:
            import json
            data = json.loads(message)
            logger.info(f"Account update: {data}")
            
            # Update assets
            account_data = data.get("content", {}).get("data", {})
            if account_data:
                self.assets = account_data
        
        except Exception as e:
            logger.error(f"Failed to handle account update: {str(e)}")
    
    def handle_order_update(self, message: str):
        """
        Handle order update messages from WebSocket.
        
        Args:
            message: The WebSocket message
        """
        try:
            import json
            data = json.loads(message)
            logger.info(f"Order update: {data}")
            
            # Update active orders
            asyncio.create_task(self.update_active_orders())
        
        except Exception as e:
            logger.error(f"Failed to handle order update: {str(e)}")
    
    def handle_position_update(self, message: str):
        """
        Handle position update messages from WebSocket.
        
        Args:
            message: The WebSocket message
        """
        try:
            import json
            data = json.loads(message)
            logger.info(f"Position update: {data}")
            
            # Update positions
            position_data = data.get("content", {}).get("data", {})
            contract_id = position_data.get("contractId")
            
            if contract_id:
                self.positions[contract_id] = position_data
        
        except Exception as e:
            logger.error(f"Failed to handle position update: {str(e)}")
    
    def handle_ticker_update(self, message: str):
        """
        Handle ticker update messages from WebSocket.
        
        Args:
            message: The WebSocket message
        """
        try:
            import json
            data = json.loads(message)
            
            # Extract ticker data
            content = data.get("content", {})
            ticker_data_list = content.get("data", [])

            # Handle both single ticker and list of tickers
            if isinstance(ticker_data_list, list) and ticker_data_list:
                ticker_data = ticker_data_list[0]  # Take the first ticker
            else:
                ticker_data = ticker_data_list

            contract_id = ticker_data.get("contractId") if isinstance(ticker_data, dict) else None
            
            if contract_id:
                if "ticker" not in self.market_data:
                    self.market_data["ticker"] = {}
                
                self.market_data["ticker"][contract_id] = ticker_data
                logger.info(f"Ticker update for {contract_id}: {ticker_data.get('lastPrice')}")
        
        except Exception as e:
            logger.error(f"Failed to handle ticker update: {str(e)}")
    
    def handle_kline_update(self, message: str):
        """
        Handle K-line update messages from WebSocket.
        
        Args:
            message: The WebSocket message
        """
        try:
            import json
            data = json.loads(message)
            
            # Extract K-line data
            kline_data = data.get("content", {}).get("data", {})
            contract_id = kline_data.get("contractId")
            interval = kline_data.get("interval")
            
            if contract_id and interval:
                if "kline" not in self.market_data:
                    self.market_data["kline"] = {}
                
                if contract_id not in self.market_data["kline"]:
                    self.market_data["kline"][contract_id] = {}
                
                self.market_data["kline"][contract_id][interval] = kline_data
                logger.info(f"K-line update for {contract_id} {interval}: {kline_data.get('close')}")
        
        except Exception as e:
            logger.error(f"Failed to handle K-line update: {str(e)}")
    
    def handle_depth_update(self, message: str):
        """
        Handle depth update messages from WebSocket.
        
        Args:
            message: The WebSocket message
        """
        try:
            import json
            data = json.loads(message)
            
            # Extract depth data
            depth_data = data.get("content", {}).get("data", {})
            contract_id = depth_data.get("contractId")
            
            if contract_id:
                if "depth" not in self.market_data:
                    self.market_data["depth"] = {}
                
                self.market_data["depth"][contract_id] = depth_data
                logger.info(f"Depth update for {contract_id}")
        
        except Exception as e:
            logger.error(f"Failed to handle depth update: {str(e)}")
    
    async def create_limit_order(
        self,
        contract_id: str,
        size: str,
        price: str,
        side: str,
        time_in_force: str = TimeInForce.GOOD_TIL_CANCEL,
        reduce_only: bool = False
    ) -> Dict[str, Any]:
        """
        Create a limit order.
        
        Args:
            contract_id: The contract ID
            size: The order size
            price: The order price
            side: The order side (BUY or SELL)
            time_in_force: The time in force
            reduce_only: Whether the order is reduce-only
            
        Returns:
            Dict[str, Any]: The created order
            
        Raises:
            ValueError: If the order creation fails
        """
        try:
            # Create order parameters
            params = CreateOrderParams(
                contract_id=contract_id,
                size=size,
                price=price,
                type=OrderType.LIMIT,
                side=side,
                time_in_force=time_in_force,
                reduce_only=reduce_only
            )
            
            # Create the order
            result = await self.client.create_order(params)
            
            # Check for success
            if result.get("code") != "SUCCESS":
                error_param = result.get("errorParam")
                if error_param:
                    raise ValueError(f"Failed to create order: {error_param}")
                raise ValueError(f"Failed to create order: {result.get('code')}")
            
            # Update active orders
            await self.update_active_orders()
            
            logger.info(f"Created limit order: {result.get('data', {}).get('orderId')}")
            return result
        
        except Exception as e:
            logger.error(f"Failed to create limit order: {str(e)}")
            raise
    
    async def cancel_order(self, order_id: str) -> Dict[str, Any]:
        """
        Cancel an order.
        
        Args:
            order_id: The order ID
            
        Returns:
            Dict[str, Any]: The cancellation result
            
        Raises:
            ValueError: If the order cancellation fails
        """
        try:
            # Create cancel order parameters
            params = CancelOrderParams(order_id=order_id)
            
            # Cancel the order
            result = await self.client.cancel_order(params)
            
            # Check for success
            if result.get("code") != "SUCCESS":
                error_param = result.get("errorParam")
                if error_param:
                    raise ValueError(f"Failed to cancel order: {error_param}")
                raise ValueError(f"Failed to cancel order: {result.get('code')}")
            
            # Update active orders
            await self.update_active_orders()
            
            logger.info(f"Cancelled order: {order_id}")
            return result
        
        except Exception as e:
            logger.error(f"Failed to cancel order: {str(e)}")
            raise
    
    async def cancel_all_orders(self, contract_id: str = None) -> Dict[str, Any]:
        """
        Cancel all orders for a contract.
        
        Args:
            contract_id: The contract ID (optional)
            
        Returns:
            Dict[str, Any]: The cancellation result
            
        Raises:
            ValueError: If the order cancellation fails
        """
        try:
            # Create cancel order parameters
            params = CancelOrderParams(contract_id=contract_id or "")
            
            # Cancel the orders
            result = await self.client.cancel_order(params)
            
            # Check for success
            if result.get("code") != "SUCCESS":
                error_param = result.get("errorParam")
                if error_param:
                    raise ValueError(f"Failed to cancel orders: {error_param}")
                raise ValueError(f"Failed to cancel orders: {result.get('code')}")
            
            # Update active orders
            await self.update_active_orders()
            
            logger.info(f"Cancelled all orders for contract: {contract_id or 'all'}")
            return result
        
        except Exception as e:
            logger.error(f"Failed to cancel all orders: {str(e)}")
            raise
    
    async def get_order_fill_transactions(
        self,
        contract_id: str = None,
        size: str = "10",
        offset_data: str = ""
    ) -> Dict[str, Any]:
        """
        Get order fill transactions.
        
        Args:
            contract_id: The contract ID (optional)
            size: The page size
            offset_data: The offset data for pagination
            
        Returns:
            Dict[str, Any]: The order fill transactions
            
        Raises:
            ValueError: If the request fails
        """
        try:
            # Create parameters
            params = OrderFillTransactionParams(
                size=size,
                offset_data=offset_data
            )
            
            if contract_id:
                params.filter_contract_id_list = [contract_id]
            
            # Get order fill transactions
            result = await self.client.get_order_fill_transactions(params)
            
            # Check for success
            if result.get("code") != "SUCCESS":
                error_param = result.get("errorParam")
                if error_param:
                    raise ValueError(f"Failed to get order fill transactions: {error_param}")
                raise ValueError(f"Failed to get order fill transactions: {result.get('code')}")
            
            logger.info(f"Got order fill transactions: {len(result.get('data', {}).get('list', []))}")
            return result
        
        except Exception as e:
            logger.error(f"Failed to get order fill transactions: {str(e)}")
            raise
    
    async def get_k_line(
        self,
        contract_id: str,
        interval: str,
        size: str = "100",
        offset_data: str = ""
    ) -> Dict[str, Any]:
        """
        Get K-line data.
        
        Args:
            contract_id: The contract ID
            interval: The K-line interval
            size: The page size
            offset_data: The offset data for pagination
            
        Returns:
            Dict[str, Any]: The K-line data
            
        Raises:
            ValueError: If the request fails
        """
        try:
            # Create parameters
            params = GetKLineParams(
                contract_id=contract_id,
                interval=interval,
                size=size,
                offset_data=offset_data
            )
            
            # Get K-line data
            result = await self.client.quote.get_k_line(params)
            
            # Check for success
            if result.get("code") != "SUCCESS":
                error_param = result.get("errorParam")
                if error_param:
                    raise ValueError(f"Failed to get K-line data: {error_param}")
                raise ValueError(f"Failed to get K-line data: {result.get('code')}")
            
            logger.info(f"Got K-line data: {len(result.get('data', {}).get('list', []))}")
            return result
        
        except Exception as e:
            logger.error(f"Failed to get K-line data: {str(e)}")
            raise
    
    async def get_order_book_depth(
        self,
        contract_id: str,
        limit: int = 15
    ) -> Dict[str, Any]:
        """
        Get order book depth.
        
        Args:
            contract_id: The contract ID
            limit: The depth limit (valid values are 15 or 200)
            
        Returns:
            Dict[str, Any]: The order book depth
            
        Raises:
            ValueError: If the request fails
        """
        try:
            # Create parameters
            params = GetOrderBookDepthParams(
                contract_id=contract_id,
                limit=limit
            )
            
            # Get order book depth
            result = await self.client.quote.get_order_book_depth(params)
            
            # Check for success
            if result.get("code") != "SUCCESS":
                error_param = result.get("errorParam")
                if error_param:
                    raise ValueError(f"Failed to get order book depth: {error_param}")
                raise ValueError(f"Failed to get order book depth: {result.get('code')}")
            
            logger.info(f"Got order book depth for {contract_id}")
            return result
        
        except Exception as e:
            logger.error(f"Failed to get order book depth: {str(e)}")
            raise
    
    async def close(self):
        """Close all connections."""
        try:
            # Disconnect WebSocket
            self.ws_manager.disconnect_all()
            logger.info("Disconnected from WebSocket")
            
            return True
        
        except Exception as e:
            logger.error(f"Failed to close connections: {str(e)}")
            return False


async def main():
    """Main function."""
    # Load configuration from environment variables
    base_url = os.getenv("EDGEX_BASE_URL", "https://testnet.edgex.exchange")
    ws_url = os.getenv("EDGEX_WS_URL", "wss://quote-testnet.edgex.exchange")
    account_id = int(os.getenv("EDGEX_ACCOUNT_ID", "12345"))
    stark_private_key = os.getenv("EDGEX_STARK_PRIVATE_KEY", "your-stark-private-key")
    
    # Create trader
    trader = EdgeXTrader(
        base_url=base_url,
        ws_url=ws_url,
        account_id=account_id,
        stark_private_key=stark_private_key
    )
    
    # Initialize trader
    if not await trader.initialize():
        logger.error("Failed to initialize trader")
        return
    
    try:
        # Get K-line data for BTCUSDT (contract ID: 10000001)
        klines = await trader.get_k_line("10000001", "1m")
        logger.info(f"Retrieved K-line data: {len(klines.get('data', {}).get('list', []))} entries")

        # Get order book depth for BTCUSDT (contract ID: 10000001)
        await trader.get_order_book_depth("10000001")
        logger.info(f"Retrieved order book depth")

        # Create a limit order (commented out to avoid actual order creation)
        # order = await trader.create_limit_order(
        #     contract_id="10000001",  # BTCUSDT
        #     size="0.001",
        #     price="30000",
        #     side=OrderSide.BUY
        # )
        #
        # # Cancel the order
        # if order and order.get("data", {}).get("orderId"):
        #     await trader.cancel_order(order.get("data", {}).get("orderId"))
        
        # Wait for some WebSocket updates
        logger.info("Waiting for WebSocket updates...")
        await asyncio.sleep(60)
    
    finally:
        # Close connections
        await trader.close()


if __name__ == "__main__":
    asyncio.run(main())


## examples/basic_usage.py
"""
Basic usage example for the EdgeX Python SDK.

This example demonstrates the basic functionality of the SDK:
- Creating a client
- Getting server time and metadata
- Getting account assets and positions
- Getting market data (K-lines, order book depth)
- Creating orders (commented out to avoid actual order creation)
- Using WebSockets for real-time data
"""

import asyncio
import os

from edgex_sdk import (
    Client,
    OrderSide,
    GetKLineParams,
    GetOrderBookDepthParams,
    WebSocketManager
)


async def main():
    # Load configuration from environment variables
    base_url = os.getenv("EDGEX_BASE_URL", "https://testnet.edgex.exchange")
    account_id = int(os.getenv("EDGEX_ACCOUNT_ID", "12345"))
    stark_private_key = os.getenv("EDGEX_STARK_PRIVATE_KEY", "your-stark-private-key")

    # Create a new client
    client = Client(
        base_url=base_url,
        account_id=account_id,
        stark_private_key=stark_private_key
    )

    # Get server time
    server_time = await client.get_server_time()
    print(f"Server Time: {server_time}")

    # Get exchange metadata
    metadata = await client.get_metadata()
    print(f"Available contracts: {len(metadata.get('data', {}).get('contractList', []))}")

    # Get account assets
    assets = await client.get_account_asset()
    print(f"Account Assets: {assets}")

    # Get account positions
    positions = await client.get_account_positions()
    print(f"Account Positions: {positions}")

    # Get 24-hour market data for BNBUSDT (contract ID: 10000004)
    quote = await client.get_24_hour_quote("10000004")
    print(f"BNBUSDT Price: {quote}")

    # Get K-line data for BTCUSDT (contract ID: 10000001)
    kline_params = GetKLineParams(
        contract_id="10000001",  # BTCUSDT
        interval="1m",
        size="10"
    )
    klines = await client.quote.get_k_line(kline_params)
    print(f"K-lines: {klines}")

    # Get order book depth for ETHUSDT (contract ID: 10000002)
    depth_params = GetOrderBookDepthParams(
        contract_id="10000002",  # ETHUSDT
        limit=15  # Valid values are 15 or 200
    )
    depth = await client.quote.get_order_book_depth(depth_params)
    print(f"Order Book Depth: {depth}")

    # Create a limit order (commented out to avoid actual order creation)
    # order = await client.create_limit_order(
    #     contract_id="10000004",  # BNBUSDT
    #     size="0.01",
    #     price="600.00",
    #     side=OrderSide.BUY
    # )
    # print(f"Order created: {order}")

    # WebSocket example
    ws_url = os.getenv("EDGEX_WS_URL", "wss://quote-testnet.edgex.exchange")
    ws_manager = WebSocketManager(
        base_url=ws_url,
        account_id=account_id,
        stark_pri_key=stark_private_key
    )

    # Define message handlers
    def ticker_handler(message):
        print(f"Ticker Update: {message}")

    def kline_handler(message):
        print(f"K-line Update: {message}")

    # Connect to public WebSocket for market data
    ws_manager.connect_public()

    # Subscribe to real-time updates for BNBUSDT (contract ID: 10000004)
    ws_manager.subscribe_ticker("10000004", ticker_handler)
    ws_manager.subscribe_kline("10000004", "1m", kline_handler)

    # Wait for updates
    await asyncio.sleep(30)

    # Disconnect all connections
    ws_manager.disconnect_all()


if __name__ == "__main__":
    asyncio.run(main())


## run_integration_tests.py
#!/usr/bin/env python3
"""
Integration test runner for the EdgeX Python SDK.
"""

import os
import sys
import subprocess
import logging

from tests.integration.config import check_env_vars

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Check if required environment variables are set
env_status = check_env_vars()
if not env_status["all_set"]:
    missing_vars = env_status["missing_vars"]
    logger.error(f"Cannot run integration tests because the following environment variables are not set: {', '.join(missing_vars)}")
    logger.error("Please set these environment variables and try again.")
    sys.exit(1)

# Set the StarkEx signing adapter in the environment
# os.environ["EDGEX_SIGNING_ADAPTER"] = "starkex"

# Log information about the signing adapter
logger.info("Running integration tests with the StarkEx signing adapter.")
logger.info("This means that cryptographic operations are performed using the actual Stark curve implementation.")

# Run the integration tests as a module
result = subprocess.run([sys.executable, "-m", "tests.integration"])

# Exit with the same exit code
sys.exit(result.returncode)


## run_mock_tests.py
#!/usr/bin/env python3
"""
Mock test runner for the EdgeX Python SDK.

This script runs the integration tests with dummy values for the environment variables.
It's useful for testing the SDK without actual API credentials.

Note: This will not make actual API calls, as the tests will fail when trying to connect
to the EdgeX API with invalid credentials. However, it's useful for testing the SDK
structure and mock signing adapter.
"""

import os
import sys
import subprocess
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Set dummy environment variables
os.environ["EDGEX_BASE_URL"] = "https://testnet.edgex.exchange"
os.environ["EDGEX_WS_URL"] = "wss://testnet.edgex.exchange"
os.environ["EDGEX_ACCOUNT_ID"] = "12345"
os.environ["EDGEX_STARK_PRIVATE_KEY"] = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"
os.environ["EDGEX_SIGNING_ADAPTER"] = "mock"

# Log information about the mock tests
logger.info("Running integration tests with dummy credentials and a mock signing adapter.")
logger.info("This means that API calls will fail, but the SDK structure and mock signing adapter can be tested.")
logger.info("For actual API testing, use the run_integration_tests.py script with valid credentials.")

# Run the integration tests as a module
result = subprocess.run([sys.executable, "-m", "tests.integration"])

# Exit with the same exit code
sys.exit(result.returncode)


## run_public_tests.py
#!/usr/bin/env python3
"""
Public endpoints test runner for the EdgeX Python SDK.

This script runs tests for public endpoints that don't require authentication.
"""

import os
import sys
import unittest
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Set dummy values for required environment variables
# These won't be used for authentication but are needed for client initialization
os.environ["EDGEX_BASE_URL"] = "https://pro.edgex.exchange"
# Use the correct WebSocket URL
os.environ["EDGEX_WS_URL"] = "wss://quote.edgex.exchange"
os.environ["EDGEX_ACCOUNT_ID"] = "0"  # Dummy value
os.environ["EDGEX_STARK_PRIVATE_KEY"] = "0" * 64  # Dummy value
os.environ["EDGEX_SIGNING_ADAPTER"] = "mock"  # Use mock adapter
os.environ["EDGEX_PUBLIC_ONLY"] = "true"  # Flag to indicate public endpoints only

# Log information
logger.info("Running tests for public endpoints only")
logger.info("These tests don't require authentication credentials")

# Create the public test directory if it doesn't exist
os.makedirs("tests/integration/public", exist_ok=True)

# Create an __init__.py file in the public test directory
with open("tests/integration/public/__init__.py", "w") as f:
    f.write("# Public endpoint tests\n")

# Discover and run tests
test_loader = unittest.TestLoader()

# Run the public endpoint tests
test_suite = test_loader.discover('tests/integration/public', pattern='test_*.py')

# Run the tests
test_runner = unittest.TextTestRunner(verbosity=2)
result = test_runner.run(test_suite)

# Exit with the number of failures and errors
sys.exit(len(result.failures) + len(result.errors))


## run_tests.py
#!/usr/bin/env python3
"""
Test runner for the EdgeX Python SDK.
"""

import unittest
import sys
import os


def run_tests():
    """Run all tests in the tests directory."""
    # Add the parent directory to the path so we can import the package
    sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
    
    # Discover and run tests
    test_loader = unittest.TestLoader()
    test_suite = test_loader.discover('tests', pattern='test_*.py')
    
    # Run the tests
    test_runner = unittest.TextTestRunner(verbosity=2)
    result = test_runner.run(test_suite)
    
    # Return the number of failures and errors
    return len(result.failures) + len(result.errors)


if __name__ == '__main__':
    # Run the tests
    exit_code = run_tests()
    
    # Exit with the number of failures and errors
    sys.exit(exit_code)


## scripts/build_and_test_package.py
#!/usr/bin/env python3
"""
Script to build and test the package locally before publishing to PyPI.
"""

import subprocess
import sys
import os
import shutil
from pathlib import Path

def run_command(cmd, description):
    """Run a command and handle errors."""
    print(f"\n🔄 {description}...")
    try:
        result = subprocess.run(cmd, shell=True, check=True, capture_output=True, text=True)
        print(f"✅ {description} completed successfully")
        if result.stdout:
            print(result.stdout)
        return True
    except subprocess.CalledProcessError as e:
        print(f"❌ {description} failed")
        print(f"Error: {e.stderr}")
        return False

def clean_build_artifacts():
    """Clean up build artifacts."""
    print("\n🧹 Cleaning build artifacts...")
    artifacts = ['build', 'dist', '*.egg-info']
    for artifact in artifacts:
        for path in Path('.').glob(artifact):
            if path.is_dir():
                shutil.rmtree(path)
                print(f"Removed directory: {path}")
            else:
                path.unlink()
                print(f"Removed file: {path}")

def main():
    """Main function to build and test package."""
    print("🚀 Building and testing EdgeX Python SDK package")
    
    # Change to project root
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    os.chdir(project_root)
    
    # Clean previous builds
    clean_build_artifacts()
    
    # Install build dependencies
    if not run_command("pip install --upgrade pip build twine", "Installing build dependencies"):
        return 1
    
    # Build the package
    if not run_command("python -m build", "Building package"):
        return 1
    
    # Check the package
    if not run_command("twine check dist/*", "Checking package"):
        return 1
    
    # List built files
    print("\n📦 Built packages:")
    dist_dir = Path("dist")
    if dist_dir.exists():
        for file in dist_dir.iterdir():
            print(f"  - {file.name}")
    
    print("\n✅ Package build and check completed successfully!")
    print("\n📋 Next steps:")
    print("1. Test install locally: pip install dist/edgex_python_sdk-*.whl")
    print("2. Upload to Test PyPI: twine upload --repository testpypi dist/*")
    print("3. Test install from Test PyPI: pip install --index-url https://test.pypi.org/simple/ edgex-python-sdk")
    print("4. If everything works, upload to PyPI: twine upload dist/*")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())


## setup.py
from setuptools import setup, find_packages

# Read the README file for long description
def read_readme():
    with open("README.md", "r", encoding="utf-8") as fh:
        return fh.read()

setup(
    name="edgex-python-sdk",
    version="0.1.0",
    description="A Python SDK for interacting with the EdgeX Exchange API",
    long_description=read_readme(),
    long_description_content_type="text/markdown",
    author="EdgeX Tech",
    author_email="info@edgex.exchange",
    url="https://github.com/edgex-Tech/edgex-python-sdk",
    project_urls={
        "Bug Reports": "https://github.com/edgex-Tech/edgex-python-sdk/issues",
        "Source": "https://github.com/edgex-Tech/edgex-python-sdk",
        "Documentation": "https://github.com/edgex-Tech/edgex-python-sdk#readme",
    },
    packages=find_packages(exclude=["tests*", "examples*"]),
    install_requires=[
        "aiohttp>=3.8.0",
        "websocket-client>=1.0.0",
        "pydantic>=1.8.0",
        "python-dotenv>=0.15.0",
        "pycryptodome>=3.15.0",
        "ecdsa>=0.17.0",
    ],
    extras_require={
        "dev": [
            "pytest>=6.0",
            "pytest-asyncio>=0.18.0",
            "black>=21.0.0",
            "flake8>=3.8.0",
            "mypy>=0.800",
        ],
    },
    classifiers=[
        "Development Status :: 3 - Alpha",
        "Intended Audience :: Developers",
        "License :: OSI Approved :: MIT License",
        "Programming Language :: Python :: 3",
        "Programming Language :: Python :: 3.7",
        "Programming Language :: Python :: 3.8",
        "Programming Language :: Python :: 3.9",
        "Programming Language :: Python :: 3.10",
        "Programming Language :: Python :: 3.11",
        "Topic :: Software Development :: Libraries :: Python Modules",
        "Topic :: Internet :: WWW/HTTP :: Dynamic Content",
        "Topic :: Office/Business :: Financial",
    ],
    python_requires=">=3.7",
    keywords="edgex exchange trading api sdk cryptocurrency",
    include_package_data=True,
)

## tests/integration/__init__.py
"""Integration tests for the EdgeX Python SDK."""


## tests/integration/__main__.py
"""
Main module for running integration tests.
"""

import unittest
import sys
import os
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Set the mock signing adapter in the environment
# os.environ["EDGEX_SIGNING_ADAPTER"] = "mock"

# Log information about the mock tests
logger.info("Running integration tests with the mock signing adapter.")
logger.info("This means that cryptographic operations are not performed using the actual Stark curve.")

# Discover and run tests
test_loader = unittest.TestLoader()
test_suite = test_loader.discover(os.path.dirname(__file__), pattern='test_*.py')

# Run the tests
test_runner = unittest.TextTestRunner(verbosity=2)
result = test_runner.run(test_suite)

# Exit with the number of failures and errors
sys.exit(len(result.failures) + len(result.errors))


## tests/integration/base_test.py
"""Base test class for integration tests."""

import unittest
import asyncio
import logging
import os
from typing import Dict, Any, Optional

from edgex_sdk import Client, WebSocketManager
from .config import BASE_URL, WS_URL, ACCOUNT_ID, STARK_PRIVATE_KEY, STARKEX_SIGNING_ADAPTER, check_env_vars

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class BaseIntegrationTest(unittest.TestCase):
    """Base class for integration tests."""

    @classmethod
    def setUpClass(cls):
        """Set up the test class."""
        # Check if required environment variables are set
        env_status = check_env_vars()
        if not env_status["all_set"]:
            missing_vars = env_status["missing_vars"]
            raise unittest.SkipTest(
                f"Skipping integration tests because the following environment variables are not set: {', '.join(missing_vars)}"
            )

        # Log which signing adapter is being used
        logger.info("Using StarkEx signing adapter (default)")

        # Store test data
        cls.test_data = {}

    @classmethod
    def tearDownClass(cls):
        """Tear down the test class."""
        pass  # No class-level cleanup needed

    def run_async(self, coro):
        """
        Run an async coroutine in the current event loop.

        Args:
            coro: The coroutine to run

        Returns:
            Any: The result of the coroutine
        """
        return self.loop.run_until_complete(coro)

    def setUp(self):
        """Set up the test."""
        # Create a new event loop for each test
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)

        # Create a fresh client for each test method
        self.client = Client(
            base_url=BASE_URL,
            account_id=ACCOUNT_ID,
            stark_private_key=STARK_PRIVATE_KEY
        )

        # Create WebSocket manager for each test
        self.ws_manager = WebSocketManager(
            base_url=WS_URL,
            account_id=ACCOUNT_ID,
            stark_pri_key=STARK_PRIVATE_KEY
        )

    def tearDown(self):
        """Tear down the test."""
        # Close client and WebSocket connections
        if hasattr(self, 'client'):
            self.run_async(self.client.close())

        if hasattr(self, 'ws_manager'):
            self.ws_manager.disconnect_all()

        # Close the event loop
        self.loop.close()

    def assertResponseSuccess(self, response: Dict[str, Any], msg: Optional[str] = None):
        """
        Assert that a response is successful.

        Args:
            response: The response to check
            msg: Optional message to display on failure
        """
        self.assertIn("code", response, msg=msg)
        self.assertEqual(response["code"], "SUCCESS", msg=msg)
        self.assertIn("data", response, msg=msg)


## tests/integration/config.py
"""Configuration for integration tests."""

import os
from typing import Dict, Any
from dotenv import load_dotenv

from edgex_sdk.internal.starkex_signing_adapter import StarkExSigningAdapter

# Load environment variables from .env file
load_dotenv()

# Load environment variables
BASE_URL = os.getenv("EDGEX_BASE_URL", "https://testnet.edgex.exchange")
WS_URL = os.getenv("EDGEX_WS_URL", "wss://quote-testnet.edgex.exchange")
ACCOUNT_ID = int(os.getenv("EDGEX_ACCOUNT_ID", "0"))
STARK_PRIVATE_KEY = os.getenv("EDGEX_STARK_PRIVATE_KEY", "")

# Test data
TEST_CONTRACT_ID = "10000004"  # Contract ID provided
TEST_ORDER_SIZE = "0.001"
TEST_ORDER_PRICE = "30000"

# Create signing adapter for testing
STARKEX_SIGNING_ADAPTER = StarkExSigningAdapter()

# Check if required environment variables are set
def check_env_vars() -> Dict[str, Any]:
    """
    Check if required environment variables are set.

    Returns:
        Dict[str, Any]: A dictionary with the status of each environment variable
    """
    env_vars = {
        "EDGEX_BASE_URL": BASE_URL,
        "EDGEX_WS_URL": WS_URL,
        "EDGEX_ACCOUNT_ID": ACCOUNT_ID,
        "EDGEX_STARK_PRIVATE_KEY": STARK_PRIVATE_KEY
    }

    missing_vars = []
    for var_name, var_value in env_vars.items():
        if not var_value or (var_name == "EDGEX_ACCOUNT_ID" and var_value == 0):
            missing_vars.append(var_name)

    return {
        "all_set": len(missing_vars) == 0,
        "missing_vars": missing_vars,
        "env_vars": env_vars
    }


## tests/integration/public/__init__.py
# Public endpoint tests


## tests/integration/public/base_test.py
"""Base test class for public endpoint tests."""

import unittest
import asyncio
import logging
import os
from typing import Dict, Any, Optional

from edgex_sdk import Client
from edgex_sdk.internal.starkex_signing_adapter import StarkExSigningAdapter
from tests.integration.config import BASE_URL

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class BasePublicEndpointTest(unittest.TestCase):
    """Base class for public endpoint tests."""

    @classmethod
    def setUpClass(cls):
        """Set up the test class."""
        # Store test data
        cls.test_data = {}

    def run_async(self, coro):
        """
        Run an async coroutine in the current event loop.

        Args:
            coro: The coroutine to run

        Returns:
            Any: The result of the coroutine
        """
        return self.loop.run_until_complete(coro)

    def setUp(self):
        """Set up the test."""
        # Create a new event loop for each test
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)

        # Create a fresh client for each test method
        # Create a StarkEx signing adapter
        signing_adapter = StarkExSigningAdapter()

        # Create client with dummy values
        # The account_id and stark_private_key won't be used for public endpoints
        self.client = Client(
            base_url=BASE_URL,
            account_id=0,  # Dummy value
            stark_private_key="0" * 64,  # Dummy value
            signing_adapter=signing_adapter
        )

    def tearDown(self):
        """Tear down the test."""
        # Close client
        if hasattr(self, 'client'):
            self.run_async(self.client.close())

        # Close the event loop
        self.loop.close()

    def assertResponseSuccess(self, response: Dict[str, Any], msg: Optional[str] = None):
        """
        Assert that a response is successful.
        
        Args:
            response: The response to check
            msg: Optional message to display on failure
        """
        self.assertIn("code", response, msg=msg)
        self.assertEqual(response["code"], "SUCCESS", msg=msg)
        self.assertIn("data", response, msg=msg)


## tests/integration/public/test_metadata.py
"""Tests for public metadata endpoints."""

import unittest
import logging

from tests.integration.public.base_test import BasePublicEndpointTest

# Configure logging
logger = logging.getLogger(__name__)


class TestPublicMetadataAPI(BasePublicEndpointTest):
    """Tests for public metadata endpoints."""

    def test_get_metadata(self):
        """Test get_metadata method."""
        # Get metadata
        metadata = self.run_async(self.client.get_metadata())

        # Check response
        self.assertResponseSuccess(metadata)

        # Check data
        data = metadata.get("data", {})
        self.assertIn("contractList", data)
        self.assertIsInstance(data["contractList"], list)

        # Log contract count
        logger.info(f"Found {len(data['contractList'])} contracts")

    def test_get_server_time(self):
        """Test get_server_time method."""
        # Get server time
        server_time = self.run_async(self.client.get_server_time())

        # Check response
        self.assertResponseSuccess(server_time)

        # Check data
        data = server_time.get("data", {})
        # The response might contain 'serverTime' or 'timeMillis'
        self.assertTrue("serverTime" in data or "timeMillis" in data, "Neither 'serverTime' nor 'timeMillis' found in response")

        # Get the time value
        time_value = data.get("serverTime") or data.get("timeMillis")
        # The time value might be an int or a string
        self.assertTrue(isinstance(time_value, int) or isinstance(time_value, str), "Time value is not an int or string")

        # Log server time
        time_value = data.get("serverTime") or data.get("timeMillis")
        logger.info(f"Server time: {time_value}")


if __name__ == "__main__":
    unittest.main()


## tests/integration/public/test_quote.py
"""Tests for public quote endpoints."""

import unittest
import logging

from edgex_sdk import GetKLineParams, GetOrderBookDepthParams, GetMultiContractKLineParams
from tests.integration.public.base_test import BasePublicEndpointTest

# Configure logging
logger = logging.getLogger(__name__)

# Test contract ID
TEST_CONTRACT_ID = "10000004"  # Contract ID provided


class TestPublicQuoteAPI(BasePublicEndpointTest):
    """Tests for public quote endpoints."""

    def test_get_24_hour_quote(self):
        """Test get_24_hour_quote method."""
        # Get 24-hour quote
        quote = self.run_async(self.client.quote.get_24_hour_quote(TEST_CONTRACT_ID))

        # Check response
        self.assertResponseSuccess(quote)

        # Check data
        data = quote.get("data", [])
        self.assertIsInstance(data, list)

        # Log quote details
        if data:
            first_quote = data[0]
            logger.info(f"24-hour quote for {TEST_CONTRACT_ID}: {first_quote.get('lastPrice')}")
        else:
            logger.info(f"No 24-hour quote data for {TEST_CONTRACT_ID}")

    def test_get_k_line(self):
        """Test get_k_line method."""
        # Create parameters
        params = GetKLineParams(
            contract_id=TEST_CONTRACT_ID,
            interval="HOUR_1",
            size="10"
        )

        # Get K-line data
        klines = self.run_async(self.client.quote.get_k_line(params))

        # Check response
        self.assertResponseSuccess(klines)

        # Check data
        data = klines.get("data", {})

        # Log K-line details
        if "list" in data and data["list"]:
            first_kline = data["list"][0]
            logger.info(f"First K-line for {TEST_CONTRACT_ID}: {first_kline}")
        else:
            logger.info(f"No K-line data for {TEST_CONTRACT_ID}")

    def test_get_order_book_depth(self):
        """Test get_order_book_depth method."""
        # Create parameters
        params = GetOrderBookDepthParams(
            contract_id=TEST_CONTRACT_ID,
            limit=200  # Use a valid depth level (15 or 200)
        )

        try:
            # Get order book depth
            depth = self.run_async(self.client.quote.get_order_book_depth(params))

            # Check response
            self.assertResponseSuccess(depth)

            # Check data
            data = depth.get("data", [])
            self.assertIsInstance(data, list)

            # The data might be empty for the test contract
            if data:
                depth_data = data[0]  # Get first item from list
                self.assertIn("asks", depth_data)
                self.assertIn("bids", depth_data)
                self.assertIsInstance(depth_data["asks"], list)
                self.assertIsInstance(depth_data["bids"], list)

                # Log depth details
                asks = depth_data["asks"]
                bids = depth_data["bids"]
                logger.info(f"Order book depth for {TEST_CONTRACT_ID}: {len(asks)} asks, {len(bids)} bids")
            else:
                # Log that no data was returned
                logger.info(f"No order book depth data for {TEST_CONTRACT_ID}")
        except ValueError as e:
            # Skip the test if we get an INVALID_DEPTH_LEVEL error
            if "INVALID_DEPTH_LEVEL" in str(e):
                self.skipTest(f"Skipping due to API error: {e}")
            else:
                raise


if __name__ == "__main__":
    unittest.main()


## tests/integration/public/test_websocket.py
"""Tests for public WebSocket endpoints."""

import unittest
import logging
import asyncio
import time
from typing import Dict, Any, List

from edgex_sdk import WebSocketManager
from tests.integration.public.base_test import BasePublicEndpointTest
from tests.integration.config import BASE_URL, WS_URL

# Configure logging
logger = logging.getLogger(__name__)

# Test contract ID
TEST_CONTRACT_ID = "10000004"  # Contract ID provided


class TestPublicWebSocketAPI(BasePublicEndpointTest):
    """Tests for public WebSocket endpoints."""

    def setUp(self):
        """Set up the test."""
        super().setUp()

        # Create a WebSocket manager with dummy credentials
        # Use the correct WebSocket URL from config
        self.ws_manager = WebSocketManager(
            base_url=WS_URL,
            account_id=0,  # Dummy value
            stark_pri_key="0" * 64,  # Dummy value
            signing_adapter=self.client.internal_client.signing_adapter
        )

        # Store received messages
        self.received_messages: List[Dict[str, Any]] = []

    def tearDown(self):
        """Tear down the test."""
        # Disconnect WebSocket
        self.ws_manager.disconnect_all()

        # Call parent tearDown
        super().tearDown()

    def message_handler(self, message: Dict[str, Any]):
        """
        Handle received WebSocket messages.

        Args:
            message: The received message
        """
        logger.info(f"Received message: {message}")
        self.received_messages.append(message)

    def test_public_websocket(self):
        """Test public WebSocket connection."""
        try:
            # Connect to public WebSocket
            self.ws_manager.connect_public()

            # Subscribe to ticker updates
            self.ws_manager.subscribe_ticker(TEST_CONTRACT_ID, self.message_handler)

            # Wait for messages (with timeout)
            start_time = time.time()
            timeout = 5  # 5 seconds

            while time.time() - start_time < timeout and not self.received_messages:
                # Process events for 0.1 seconds
                asyncio.get_event_loop().run_until_complete(asyncio.sleep(0.1))

            # We don't assert on receiving messages because the exchange might not send any
            # during the test period. We just verify that the connection and subscription work.
            logger.info(f"Received {len(self.received_messages)} messages")

            # Test passed if we got here without exceptions
            self.assertTrue(True)
        except Exception as e:
            if "Handshake status" in str(e) or "Service Temporarily Unavailable" in str(e):
                # This is expected when:
                # 1. The WebSocket endpoint returns HTML instead of establishing a WebSocket connection
                # 2. The endpoint returns a 404, 503, or other HTTP error
                # 3. WebSocket services are not available on testnet environments
                self.skipTest(f"Skipping due to WebSocket connection issue: {e}")
            else:
                raise


if __name__ == "__main__":
    unittest.main()


## tests/integration/test_account.py
"""Integration tests for the account API."""

import unittest
import logging
from typing import Dict, Any

from edgex_sdk import GetPositionTransactionPageParams, GetCollateralTransactionPageParams
from tests.integration.base_test import BaseIntegrationTest
from tests.integration.config import TEST_CONTRACT_ID

# Configure logging
logger = logging.getLogger(__name__)


class TestAccountAPI(BaseIntegrationTest):
    """Integration tests for the account API."""

    def test_get_account_asset(self):
        """Test get_account_asset method."""
        # Get account asset
        assets = self.run_async(self.client.get_account_asset())

        # Check response
        self.assertResponseSuccess(assets)

        # Check data
        data = assets.get("data", {})
        self.assertIsInstance(data, dict)

        # Store assets for other tests
        self.__class__.test_data["assets"] = data

        # Log asset details
        logger.info(f"Account assets: {data}")

    def test_get_account_positions(self):
        """Test get_account_positions method."""
        # Get account positions
        positions = self.run_async(self.client.get_account_positions())

        # Check response
        self.assertResponseSuccess(positions)

        # Check data (positions API returns same format as account asset)
        data = positions.get("data", {})
        self.assertIsInstance(data, dict)

        # Check position asset list
        position_assets = data.get("positionAssetList", [])
        self.assertIsInstance(position_assets, list)

        # Store positions for other tests
        self.__class__.test_data["positions"] = position_assets

        # Log position count
        logger.info(f"Found {len(position_assets)} position assets")

        # Log position details
        for position in position_assets:
            logger.info(f"Position: {position.get('contractId')} - {position.get('positionValue')}")

    def test_get_position_transaction_page(self):
        """Test get_position_transaction_page method."""
        # Create parameters
        params = GetPositionTransactionPageParams(
            size="10"
        )

        # Get position transactions
        transactions = self.run_async(self.client.account.get_position_transaction_page(params))

        # Check response
        self.assertResponseSuccess(transactions)

        # Check data
        data = transactions.get("data", {})
        self.assertIn("dataList", data)
        self.assertIsInstance(data["dataList"], list)

        # Log transaction count
        logger.info(f"Found {len(data.get('dataList', []))} position transactions")

    def test_get_collateral_transaction_page(self):
        """Test get_collateral_transaction_page method."""
        # Create parameters
        params = GetCollateralTransactionPageParams(
            size="10"
        )

        # Get collateral transactions
        transactions = self.run_async(self.client.account.get_collateral_transaction_page(params))

        # Check response
        self.assertResponseSuccess(transactions)

        # Check data
        data = transactions.get("data", {})
        self.assertIn("dataList", data)
        self.assertIsInstance(data["dataList"], list)

        # Log transaction count
        logger.info(f"Found {len(data.get('dataList', []))} collateral transactions")

    def test_get_account_by_id(self):
        """Test get_account_by_id method."""
        # Get account
        account = self.run_async(self.client.account.get_account_by_id())

        # Check response
        self.assertResponseSuccess(account)

        # Check data
        data = account.get("data", {})
        self.assertIsInstance(data, dict)

        # Check account ID (field is called "id" in response)
        self.assertIn("id", data)
        self.assertEqual(data["id"], str(self.client.internal_client.get_account_id()))

        # Log account details
        logger.info(f"Account details: {data}")


if __name__ == "__main__":
    unittest.main()


## tests/integration/test_asset.py
"""Integration tests for the asset API."""

import unittest
import logging
from typing import Dict, Any

from edgex_sdk import (
    GetAssetOrdersParams,
    CreateWithdrawalParams,
    GetWithdrawalRecordsParams
)
from tests.integration.base_test import BaseIntegrationTest

# Configure logging
logger = logging.getLogger(__name__)


class TestAssetAPI(BaseIntegrationTest):
    """Integration tests for the asset API."""

    def test_get_account_asset_delegation(self):
        """Test that get_account_asset properly delegates to account client."""
        # This should raise NotImplementedError since it's an account endpoint
        with self.assertRaises(NotImplementedError) as context:
            self.run_async(self.client.asset.get_account_asset())

        self.assertIn("account client", str(context.exception))
        logger.info("Asset client properly delegates get_account_asset to account client")

    def test_get_asset_orders(self):
        """Test get_asset_orders method."""
        # Test with minimal parameters
        params = GetAssetOrdersParams(
            size="10"
        )

        try:
            orders = self.run_async(self.client.asset.get_asset_orders(params))
        except ValueError as e:
            # Asset APIs require X-edgeX-Api-Key header that test accounts don't have
            logger.info(f"Asset orders API requires API key (expected): {e}")
            self.skipTest("Skipping test due to API key requirement")
            return

        # Check response
        self.assertResponseSuccess(orders)

        # Check data structure
        data = orders.get("data", {})
        self.assertIsInstance(data, dict)

        if "orderList" in data:
            order_list = data["orderList"]
            self.assertIsInstance(order_list, list)
            logger.info(f"Found {len(order_list)} asset orders")

            # Check order structure if any orders exist
            if order_list:
                order = order_list[0]
                self.assertIsInstance(order, dict)
                expected_fields = ["id", "coinId", "amount", "status", "createdTime"]
                for field in expected_fields:
                    if field in order:
                        logger.info(f"Order {field}: {order[field]}")

    def test_get_coin_rates(self):
        """Test get_coin_rates method."""
        try:
            rates = self.run_async(self.client.asset.get_coin_rates())
        except ValueError as e:
            # Asset APIs require X-edgeX-Api-Key header that test accounts don't have
            logger.info(f"Coin rates API requires API key (expected): {e}")
            self.skipTest("Skipping test due to API key requirement")
            return

        # Check response
        self.assertResponseSuccess(rates)

        # Check data structure
        data = rates.get("data", [])
        self.assertIsInstance(data, list)
        logger.info(f"Found {len(data)} coin rates")

        # Check rate structure if any rates exist
        if data:
            rate = data[0]
            self.assertIsInstance(rate, dict)
            expected_fields = ["coinId", "coinName", "rate"]
            for field in expected_fields:
                if field in rate:
                    logger.info(f"Rate {field}: {rate[field]}")

    def test_get_withdrawable_amount(self):
        """Test get_withdrawable_amount method."""
        # Test with USDT contract address
        address = "0xdac17f958d2ee523a2206206994597c13d831ec7"  # USDT contract address

        try:
            amount = self.run_async(self.client.asset.get_withdrawable_amount(address))

            # Check response
            self.assertResponseSuccess(amount)

            # Check data structure
            data = amount.get("data", {})
            self.assertIsInstance(data, dict)

            if "withdrawableAmount" in data:
                withdrawable = data["withdrawableAmount"]
                logger.info(f"Withdrawable amount for address {address}: {withdrawable}")

        except Exception as e:
            # Asset APIs require X-edgeX-Api-Key header that test accounts don't have
            logger.info(f"Withdrawable amount API requires API key (expected): {e}")
            self.skipTest("Skipping test due to API key requirement")

    def test_get_withdrawal_records(self):
        """Test get_withdrawal_records method."""
        params = GetWithdrawalRecordsParams(
            size=10
        )

        try:
            records = self.run_async(self.client.asset.get_withdrawal_records(params))

            # Check response
            self.assertResponseSuccess(records)

            # Check data structure
            data = records.get("data", {})
            self.assertIsInstance(data, dict)

            if "withdrawalList" in data:
                withdrawal_list = data["withdrawalList"]
                self.assertIsInstance(withdrawal_list, list)
                logger.info(f"Found {len(withdrawal_list)} withdrawal records")

                # Check withdrawal structure if any records exist
                if withdrawal_list:
                    withdrawal = withdrawal_list[0]
                    self.assertIsInstance(withdrawal, dict)
                    expected_fields = ["id", "coinId", "amount", "status", "createdTime"]
                    for field in expected_fields:
                        if field in withdrawal:
                            logger.info(f"Withdrawal {field}: {withdrawal[field]}")

        except Exception as e:
            # Asset APIs require X-edgeX-Api-Key header that test accounts don't have
            logger.info(f"Withdrawal records API requires API key (expected): {e}")
            self.skipTest("Skipping test due to API key requirement")

    def test_create_withdrawal_validation(self):
        """Test create_withdrawal method validation (without actually creating)."""
        # Test parameter validation without actually submitting
        params = CreateWithdrawalParams(
            coin_id="2",  # USDT
            amount="0.001",  # Very small amount
            address="0x1234567890123456789012345678901234567890",  # Dummy address
            tag=""
        )

        # We won't actually call the API to avoid creating real withdrawals
        # Just test that the parameters are properly structured
        self.assertIsInstance(params.coin_id, str)
        self.assertIsInstance(params.amount, str)
        self.assertIsInstance(params.address, str)

        logger.info("Withdrawal parameter validation passed")
        logger.warning("Actual withdrawal creation skipped for safety")


if __name__ == "__main__":
    unittest.main()


## tests/integration/test_metadata.py
"""Integration tests for the metadata API."""

import unittest
import logging
from typing import Dict, Any

from tests.integration.base_test import BaseIntegrationTest
from tests.integration.config import TEST_CONTRACT_ID

# Configure logging
logger = logging.getLogger(__name__)


class TestMetadataAPI(BaseIntegrationTest):
    """Integration tests for the metadata API."""

    def test_get_metadata(self):
        """Test get_metadata method."""
        # Get metadata
        metadata = self.run_async(self.client.get_metadata())

        # Check response
        self.assertResponseSuccess(metadata)

        # Check data
        data = metadata.get("data", {})
        self.assertIn("contractList", data)
        self.assertIsInstance(data["contractList"], list)

        # Store contract list for other tests
        self.__class__.test_data["contract_list"] = data["contractList"]

        # Log contract count
        logger.info(f"Found {len(data['contractList'])} contracts")

    def test_get_server_time(self):
        """Test get_server_time method."""
        # Get server time
        server_time = self.run_async(self.client.get_server_time())

        # Check response
        self.assertResponseSuccess(server_time)

        # Check data
        data = server_time.get("data", {})
        # The API returns 'timeMillis' instead of 'serverTime'
        if "timeMillis" in data:
            self.assertIsInstance(data["timeMillis"], (int, str))
            logger.info(f"Server time: {data['timeMillis']}")
        elif "serverTime" in data:
            self.assertIsInstance(data["serverTime"], (int, str))
            logger.info(f"Server time: {data['serverTime']}")
        else:
            self.fail("Neither 'timeMillis' nor 'serverTime' found in response data")

    def test_contract_exists(self):
        """Test that the test contract exists in the contract list."""
        # Get contract list (fetch if not available)
        if "contract_list" not in self.__class__.test_data:
            # Fetch metadata to get contract list
            metadata = self.run_async(self.client.get_metadata())
            self.assertResponseSuccess(metadata)
            data = metadata.get("data", {})
            self.assertIn("contractList", data)
            self.__class__.test_data["contract_list"] = data["contractList"]

        # Get contract list
        contract_list = self.__class__.test_data["contract_list"]

        # Check if test contract exists
        contract = None
        for c in contract_list:
            if c.get("contractId") == TEST_CONTRACT_ID:
                contract = c
                break

        # Assert contract exists
        self.assertIsNotNone(contract, f"Test contract {TEST_CONTRACT_ID} not found in contract list")

        # Store contract for other tests
        self.__class__.test_data["test_contract"] = contract

        # Log contract details
        logger.info(f"Found test contract: {contract.get('contractId')}")


if __name__ == "__main__":
    unittest.main()


## tests/integration/test_order.py
"""Integration tests for the order API."""

import unittest
import logging
from typing import Dict, Any
from decimal import Decimal

from edgex_sdk import (
    OrderSide,
    OrderType,
    TimeInForce,
    CreateOrderParams,
    CancelOrderParams,
    GetActiveOrderParams,
    OrderFillTransactionParams
)
from tests.integration.base_test import BaseIntegrationTest
from tests.integration.config import TEST_CONTRACT_ID, TEST_ORDER_SIZE, TEST_ORDER_PRICE

# Configure logging
logger = logging.getLogger(__name__)


class TestOrderAPI(BaseIntegrationTest):
    """Integration tests for the order API."""

    def test_get_max_order_size(self):
        """Test get_max_order_size method."""
        # Get max order size
        max_size = self.run_async(self.client.get_max_order_size(TEST_CONTRACT_ID, Decimal(TEST_ORDER_PRICE)))

        # Check response
        self.assertResponseSuccess(max_size)

        # Check data
        data = max_size.get("data", {})
        self.assertIn("maxBuySize", data)
        self.assertIn("maxSellSize", data)

        # Log max order size
        logger.info(f"Max buy size: {data.get('maxBuySize')}, Max sell size: {data.get('maxSellSize')}")

    def test_get_active_orders(self):
        """Test get_active_orders method."""
        # Create parameters
        params = GetActiveOrderParams(
            size="10"
        )

        # Get active orders
        orders = self.run_async(self.client.get_active_orders(params))

        # Check response
        self.assertResponseSuccess(orders)

        # Check data
        data = orders.get("data", {})
        self.assertIn("dataList", data)
        self.assertIsInstance(data["dataList"], list)

        # Store active orders for other tests
        self.__class__.test_data["active_orders"] = data.get("dataList", [])

        # Log order count
        logger.info(f"Found {len(data.get('dataList', []))} active orders")

    def test_get_order_fill_transactions(self):
        """Test get_order_fill_transactions method."""
        # Create parameters
        params = OrderFillTransactionParams(
            size="10"
        )

        # Get order fill transactions
        transactions = self.run_async(self.client.get_order_fill_transactions(params))

        # Check response
        self.assertResponseSuccess(transactions)

        # Check data
        data = transactions.get("data", {})
        self.assertIn("dataList", data)
        self.assertIsInstance(data["dataList"], list)

        # Log transaction count
        logger.info(f"Found {len(data.get('dataList', []))} order fill transactions")

    def test_create_and_cancel_order(self):
        """Test create_order and cancel_order methods."""
        # Create order parameters with price below market to avoid execution
        # This tests the order creation/cancellation flow without risk of actual trading
        # Current market price is around 673, using 640 (5% below) to avoid execution
        params = CreateOrderParams(
            contract_id=TEST_CONTRACT_ID,
            size="0.01",  # Minimum step size
            price="640",  # Price below market to avoid execution
            type=OrderType.LIMIT,
            side=OrderSide.BUY,
            time_in_force=TimeInForce.GOOD_TIL_CANCEL
        )

        # Create order
        order = self.run_async(self.client.create_order(params))

        # Check response
        self.assertResponseSuccess(order)

        # Check data
        data = order.get("data", {})
        self.assertIn("orderId", data)

        # Store order ID
        order_id = data["orderId"]

        # Log order details
        logger.info(f"Created order: {order_id}")

        # Cancel order
        cancel_params = CancelOrderParams(
            order_id=order_id
        )

        # Cancel order
        cancel = self.run_async(self.client.cancel_order(cancel_params))

        # Check response
        self.assertResponseSuccess(cancel)

        # Log cancellation details
        logger.info(f"Cancelled order: {order_id}")


if __name__ == "__main__":
    unittest.main()


## tests/integration/test_quote.py
"""Integration tests for the quote API."""

import unittest
import logging
from typing import Dict, Any

from edgex_sdk import GetKLineParams, GetOrderBookDepthParams, GetMultiContractKLineParams
from tests.integration.base_test import BaseIntegrationTest
from tests.integration.config import TEST_CONTRACT_ID

# Configure logging
logger = logging.getLogger(__name__)


class TestQuoteAPI(BaseIntegrationTest):
    """Integration tests for the quote API."""

    def test_get_24_hour_quote(self):
        """Test get_24_hour_quote method."""
        # Get 24-hour quote
        quote = self.run_async(self.client.quote.get_24_hour_quote(TEST_CONTRACT_ID))

        # Check response
        self.assertResponseSuccess(quote)

        # Check data
        data = quote.get("data", [])
        self.assertIsInstance(data, list)

        # The data might be empty for the test contract
        if data:
            # Check first quote
            first_quote = data[0]
            self.assertIn("contractId", first_quote)
            self.assertEqual(first_quote["contractId"], TEST_CONTRACT_ID)

            # Log quote details
            logger.info(f"24-hour quote for {TEST_CONTRACT_ID}: {first_quote.get('lastPrice')}")
        else:
            # Log that no data was returned
            logger.info(f"No 24-hour quote data for {TEST_CONTRACT_ID}")

    def test_get_k_line(self):
        """Test get_k_line method."""
        # Create parameters
        params = GetKLineParams(
            contract_id=TEST_CONTRACT_ID,
            interval="1m",
            size="10"
        )

        # Get K-line data
        klines = self.run_async(self.client.quote.get_k_line(params))

        # Check response
        self.assertResponseSuccess(klines)

        # Check data
        data = klines.get("data", {})
        # The API returns 'dataList' instead of 'list'
        if "dataList" in data:
            self.assertIsInstance(data["dataList"], list)
            kline_list = data["dataList"]
        elif "list" in data:
            self.assertIsInstance(data["list"], list)
            kline_list = data["list"]
        else:
            self.fail("Neither 'dataList' nor 'list' found in response data")

        # Check K-line count
        self.assertLessEqual(len(kline_list), 10)

        # Check first K-line
        if kline_list:
            first_kline = kline_list[0]
            self.assertIn("open", first_kline)
            self.assertIn("high", first_kline)
            self.assertIn("low", first_kline)
            self.assertIn("close", first_kline)
            self.assertIn("volume", first_kline)

            # Log K-line details
            logger.info(f"First K-line for {TEST_CONTRACT_ID}: {first_kline}")
        else:
            logger.info(f"No K-line data for {TEST_CONTRACT_ID}")

    def test_get_order_book_depth(self):
        """Test get_order_book_depth method."""
        # Create parameters - API supports 15 or 200 levels
        params = GetOrderBookDepthParams(
            contract_id=TEST_CONTRACT_ID,
            limit=15
        )

        # Get order book depth
        depth = self.run_async(self.client.quote.get_order_book_depth(params))

        # Check response
        self.assertResponseSuccess(depth)

        # Check data - API returns a list of depth objects
        data = depth.get("data", [])
        self.assertIsInstance(data, list)

        # The data might be empty for the test contract
        if data:
            depth_data = data[0]  # Get first item from list
            self.assertIn("asks", depth_data)
            self.assertIn("bids", depth_data)
            self.assertIsInstance(depth_data["asks"], list)
            self.assertIsInstance(depth_data["bids"], list)

            # Check ask and bid count
            asks = depth_data["asks"]
            bids = depth_data["bids"]
            self.assertLessEqual(len(asks), 15)
            self.assertLessEqual(len(bids), 15)

            # Log depth details
            logger.info(f"Order book depth for {TEST_CONTRACT_ID}: {len(asks)} asks, {len(bids)} bids")
        else:
            # Log that no data was returned
            logger.info(f"No order book depth data for {TEST_CONTRACT_ID}")

    def test_get_multi_contract_k_line(self):
        """Test get_multi_contract_k_line method."""
        # Create parameters
        params = GetMultiContractKLineParams(
            contract_id_list=[TEST_CONTRACT_ID],
            interval="1m",
            limit=1
        )

        # Get multi-contract K-line data
        klines = self.run_async(self.client.quote.get_multi_contract_k_line(params))

        # Check response
        self.assertResponseSuccess(klines)

        # Check data
        data = klines.get("data", {})
        # The API returns a list directly instead of a dict with 'list' key
        if isinstance(data, list):
            kline_list = data
        elif "list" in data:
            self.assertIsInstance(data["list"], list)
            kline_list = data["list"]
        else:
            self.fail("Expected list or dict with 'list' key in response data")

        # Check K-line count
        self.assertLessEqual(len(kline_list), 1)

        # Check first K-line
        if kline_list:
            first_kline = kline_list[0]
            self.assertIn("contractId", first_kline)
            # The API might return '0' for empty data or the actual contract ID
            contract_id = first_kline["contractId"]
            if contract_id != "0":
                self.assertEqual(contract_id, TEST_CONTRACT_ID)

            # Log K-line details
            logger.info(f"Multi-contract K-line for {TEST_CONTRACT_ID}: {first_kline}")
        else:
            logger.info(f"No multi-contract K-line data for {TEST_CONTRACT_ID}")


if __name__ == "__main__":
    unittest.main()


## tests/integration/test_transfer.py
"""Integration tests for the transfer API."""

import unittest
import logging
from typing import Dict, Any

from edgex_sdk import (
    GetTransferOutByIdParams,
    GetTransferInByIdParams,
    GetWithdrawAvailableAmountParams,
    CreateTransferOutParams,
    GetTransferOutPageParams,
    GetTransferInPageParams
)
from tests.integration.base_test import BaseIntegrationTest

# Configure logging
logger = logging.getLogger(__name__)


class TestTransferAPI(BaseIntegrationTest):
    """Integration tests for the transfer API."""

    def test_get_withdraw_available_amount(self):
        """Test get_withdraw_available_amount method."""
        # Try with coinId "1000" first (we know this exists from account tests)
        params = GetWithdrawAvailableAmountParams(
            coin_id="1000"  # The coin we know exists from account asset tests
        )

        try:
            amount = self.run_async(self.client.transfer.get_withdraw_available_amount(params))

            # Check response
            self.assertResponseSuccess(amount)

            # Check data structure
            data = amount.get("data", {})
            self.assertIsInstance(data, dict)

            if "availableAmount" in data:
                available = data["availableAmount"]
                logger.info(f"Available withdraw amount for coinId 1000: {available}")
            else:
                logger.info(f"Withdraw available amount response: {data}")

        except Exception as e:
            # If coinId 1000 doesn't work, try coinId "2" (USDT)
            logger.info(f"CoinId 1000 failed, trying coinId 2: {e}")
            try:
                params = GetWithdrawAvailableAmountParams(coin_id="2")
                amount = self.run_async(self.client.transfer.get_withdraw_available_amount(params))
                self.assertResponseSuccess(amount)
                data = amount.get("data", {})
                logger.info(f"Available withdraw amount for coinId 2: {data}")
            except Exception as e2:
                logger.warning(f"Both coinId 1000 and 2 failed: {e2}")
                self.skipTest(f"Withdraw available amount not available for test coins: {e2}")

    def test_get_transfer_out_page(self):
        """Test get_transfer_out_page method."""
        params = GetTransferOutPageParams(
            size=10
        )

        try:
            transfers = self.run_async(self.client.transfer.get_transfer_out_page(params))

            # Check response
            self.assertResponseSuccess(transfers)

            # Check data structure
            data = transfers.get("data", {})
            self.assertIsInstance(data, dict)

            if "transferList" in data:
                transfer_list = data["transferList"]
                self.assertIsInstance(transfer_list, list)
                logger.info(f"Found {len(transfer_list)} transfer out records")

                # Check transfer structure if any records exist
                if transfer_list:
                    transfer = transfer_list[0]
                    self.assertIsInstance(transfer, dict)
                    expected_fields = ["id", "coinId", "amount", "status", "createdTime"]
                    for field in expected_fields:
                        if field in transfer:
                            logger.info(f"Transfer out {field}: {transfer[field]}")

        except Exception as e:
            # Some endpoints might not be available for test accounts
            logger.warning(f"Transfer out page test failed (expected for test accounts): {e}")
            self.skipTest(f"Transfer out page not available: {e}")

    def test_get_transfer_in_page(self):
        """Test get_transfer_in_page method."""
        params = GetTransferInPageParams(
            size=10
        )

        try:
            transfers = self.run_async(self.client.transfer.get_transfer_in_page(params))

            # Check response
            self.assertResponseSuccess(transfers)

            # Check data structure
            data = transfers.get("data", {})
            self.assertIsInstance(data, dict)

            if "transferList" in data:
                transfer_list = data["transferList"]
                self.assertIsInstance(transfer_list, list)
                logger.info(f"Found {len(transfer_list)} transfer in records")

                # Check transfer structure if any records exist
                if transfer_list:
                    transfer = transfer_list[0]
                    self.assertIsInstance(transfer, dict)
                    expected_fields = ["id", "coinId", "amount", "status", "createdTime"]
                    for field in expected_fields:
                        if field in transfer:
                            logger.info(f"Transfer in {field}: {transfer[field]}")

        except Exception as e:
            # Some endpoints might not be available for test accounts
            logger.warning(f"Transfer in page test failed (expected for test accounts): {e}")
            self.skipTest(f"Transfer in page not available: {e}")

    def test_get_transfer_out_by_id_validation(self):
        """Test get_transfer_out_by_id method validation."""
        # Test with dummy IDs to validate parameter structure
        params = GetTransferOutByIdParams(
            transfer_id_list=["dummy_id_1", "dummy_id_2"]
        )

        # Validate parameter structure
        self.assertIsInstance(params.transfer_id_list, list)
        self.assertTrue(len(params.transfer_id_list) > 0)

        logger.info("Transfer out by ID parameter validation passed")
        logger.info("Actual API call skipped (requires valid transfer IDs)")

    def test_get_transfer_in_by_id_validation(self):
        """Test get_transfer_in_by_id method validation."""
        # Test with dummy IDs to validate parameter structure
        params = GetTransferInByIdParams(
            transfer_id_list=["dummy_id_1", "dummy_id_2"]
        )

        # Validate parameter structure
        self.assertIsInstance(params.transfer_id_list, list)
        self.assertTrue(len(params.transfer_id_list) > 0)

        logger.info("Transfer in by ID parameter validation passed")
        logger.info("Actual API call skipped (requires valid transfer IDs)")

    def test_create_transfer_out_validation(self):
        """Test create_transfer_out method validation (without actually creating)."""
        # Test parameter validation without actually submitting
        params = CreateTransferOutParams(
            coin_id="2",  # USDT
            amount="0.001",  # Very small amount
            address="0x1234567890123456789012345678901234567890",  # Dummy address
            network="ethereum"
        )

        # Mock metadata (would normally come from API)
        metadata = {
            "contracts": {
                "2": {
                    "assetId": "0x1234567890abcdef",
                    "quantum": "1000000"
                }
            }
        }

        # We won't actually call the API to avoid creating real transfers
        # Just test that the parameters are properly structured
        self.assertIsInstance(params.coin_id, str)
        self.assertIsInstance(params.amount, str)
        self.assertIsInstance(params.address, str)
        self.assertIsInstance(metadata, dict)

        logger.info("Transfer out parameter validation passed")
        logger.warning("Actual transfer creation skipped for safety")

    def test_transfer_api_accessibility(self):
        """Test that transfer API endpoints are accessible (basic connectivity)."""
        # Test that we can at least reach the transfer endpoints
        # This validates authentication and basic API structure

        try:
            # Try to get transfer out page with minimal params
            params = GetTransferOutPageParams(size=1)
            response = self.run_async(self.client.transfer.get_transfer_out_page(params))

            # Even if we get an error, we should get a structured response
            self.assertIsInstance(response, dict)
            self.assertIn("code", response)

            logger.info(f"Transfer API accessibility test - Response code: {response.get('code')}")

        except Exception as e:
            logger.info(f"Transfer API accessibility test - Exception (may be expected): {e}")
            # This is acceptable - we're just testing connectivity


if __name__ == "__main__":
    unittest.main()


## tests/integration/test_websocket.py
"""Integration tests for the WebSocket API."""

import unittest
import logging
import asyncio
import json
from typing import Dict, Any, List

from tests.integration.base_test import BaseIntegrationTest
from tests.integration.config import TEST_CONTRACT_ID

# Configure logging
logger = logging.getLogger(__name__)


class TestWebSocketAPI(BaseIntegrationTest):
    """Integration tests for the WebSocket API."""

    def setUp(self):
        """Set up the test."""
        super().setUp()

        # Create event lists for WebSocket messages
        self.ticker_events = []
        self.kline_events = []
        self.depth_events = []
        self.account_events = []
        self.order_events = []
        self.position_events = []

    def handle_ticker(self, message: str):
        """
        Handle ticker messages.

        Args:
            message: The WebSocket message
        """
        try:
            data = json.loads(message)
            self.ticker_events.append(data)
            logger.info(f"Received ticker event: {data}")
        except Exception as e:
            logger.error(f"Failed to handle ticker event: {str(e)}")

    def handle_kline(self, message: str):
        """
        Handle K-line messages.

        Args:
            message: The WebSocket message
        """
        try:
            data = json.loads(message)
            self.kline_events.append(data)
            logger.info(f"Received K-line event: {data}")
        except Exception as e:
            logger.error(f"Failed to handle K-line event: {str(e)}")

    def handle_depth(self, message: str):
        """
        Handle depth messages.

        Args:
            message: The WebSocket message
        """
        try:
            data = json.loads(message)
            self.depth_events.append(data)
            logger.info(f"Received depth event: {data}")
        except Exception as e:
            logger.error(f"Failed to handle depth event: {str(e)}")

    def handle_account(self, message: str):
        """
        Handle account messages.

        Args:
            message: The WebSocket message
        """
        try:
            data = json.loads(message)
            self.account_events.append(data)
            logger.info(f"Received account event: {data}")
        except Exception as e:
            logger.error(f"Failed to handle account event: {str(e)}")

    def handle_order(self, message: str):
        """
        Handle order messages.

        Args:
            message: The WebSocket message
        """
        try:
            data = json.loads(message)
            self.order_events.append(data)
            logger.info(f"Received order event: {data}")
        except Exception as e:
            logger.error(f"Failed to handle order event: {str(e)}")

    def handle_position(self, message: str):
        """
        Handle position messages.

        Args:
            message: The WebSocket message
        """
        try:
            data = json.loads(message)
            self.position_events.append(data)
            logger.info(f"Received position event: {data}")
        except Exception as e:
            logger.error(f"Failed to handle position event: {str(e)}")

    def test_public_websocket(self):
        """Test public WebSocket connection."""
        # Connect to public WebSocket
        self.ws_manager.connect_public()

        # Subscribe to ticker updates
        self.ws_manager.subscribe_ticker(TEST_CONTRACT_ID, self.handle_ticker)

        # Subscribe to K-line updates
        self.ws_manager.subscribe_kline(TEST_CONTRACT_ID, "1m", self.handle_kline)

        # Subscribe to depth updates
        self.ws_manager.subscribe_depth(TEST_CONTRACT_ID, self.handle_depth)

        # Wait for some updates
        logger.info("Waiting for WebSocket updates...")
        asyncio.run(asyncio.sleep(10))

        # Check if we received any events
        self.assertGreaterEqual(len(self.ticker_events) + len(self.kline_events) + len(self.depth_events), 0)

        # Disconnect
        self.ws_manager.disconnect_public()

    def test_private_websocket(self):
        """Test private WebSocket connection."""
        # Connect to private WebSocket
        self.ws_manager.connect_private()

        # Subscribe to account updates
        self.ws_manager.subscribe_account_update(self.handle_account)

        # Subscribe to order updates
        self.ws_manager.subscribe_order_update(self.handle_order)

        # Subscribe to position updates
        self.ws_manager.subscribe_position_update(self.handle_position)

        # Wait for some updates
        logger.info("Waiting for WebSocket updates...")
        asyncio.run(asyncio.sleep(10))

        # Disconnect
        self.ws_manager.disconnect_private()


if __name__ == "__main__":
    unittest.main()


## tests/test_client.py
"""
Unit tests for the main client.
"""

import unittest
import asyncio
from unittest.mock import patch, MagicMock, AsyncMock

from edgex_sdk.client import Client, RequestInterceptor
from edgex_sdk.order.types import OrderSide, OrderType, CreateOrderParams


class TestClient(unittest.TestCase):
    """Test cases for the main client."""

    def setUp(self):
        """Set up test fixtures."""
        self.base_url = "https://testnet.edgex.exchange"
        self.account_id = 12345
        self.stark_private_key = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

        # Create a client with mocked session
        with patch('edgex_sdk.client.requests.Session') as mock_session:
            self.mock_session = mock_session.return_value
            self.client = Client(
                base_url=self.base_url,
                account_id=self.account_id,
                stark_private_key=self.stark_private_key
            )

    def test_init(self):
        """Test client initialization."""
        self.assertIsNotNone(self.client.internal_client)
        self.assertIsNotNone(self.client.order)
        self.assertIsNotNone(self.client.metadata)
        self.assertIsNotNone(self.client.account)
        self.assertIsNotNone(self.client.quote)
        self.assertIsNotNone(self.client.funding)
        self.assertIsNotNone(self.client.transfer)
        self.assertIsNotNone(self.client.asset)

    def test_create_order(self):
        """Test create_order method."""
        # Mock the get_metadata method
        self.client.get_metadata = AsyncMock(return_value={"data": {"contractList": [{"contractId": "BTC-USDT"}]}})

        # Mock the order.create_order method
        self.client.order = MagicMock()
        self.client.order.create_order = AsyncMock(return_value={"code": "SUCCESS", "data": {"orderId": "123"}})

        # Create order parameters
        params = CreateOrderParams(
            contract_id="BTC-USDT",
            price="30000",
            size="0.001",
            type=OrderType.LIMIT,
            side=OrderSide.BUY
        )

        # Call the method
        result = asyncio.run(self.client.create_order(params))

        # Check that get_metadata was called
        self.client.get_metadata.assert_called_once()

        # Check that order.create_order was called with the correct arguments
        self.client.order.create_order.assert_called_once()

        # Check the result
        self.assertEqual(result, {"code": "SUCCESS", "data": {"orderId": "123"}})

    def test_get_max_order_size(self):
        """Test get_max_order_size method."""
        # Mock the order.get_max_order_size method
        self.client.order = MagicMock()
        self.client.order.get_max_order_size = AsyncMock(return_value={"code": "SUCCESS", "data": {"maxSize": "0.1"}})

        # Call the method
        result = asyncio.run(self.client.get_max_order_size("BTC-USDT", 30000))

        # Check that order.get_max_order_size was called with the correct arguments
        self.client.order.get_max_order_size.assert_called_once_with("BTC-USDT", 30000.0)

        # Check the result
        self.assertEqual(result, {"code": "SUCCESS", "data": {"maxSize": "0.1"}})

    def test_cancel_order(self):
        """Test cancel_order method."""
        # Mock the order.cancel_order method
        self.client.order = MagicMock()
        self.client.order.cancel_order = AsyncMock(return_value={"code": "SUCCESS", "data": {"success": True}})

        # Create cancel order parameters
        from edgex_sdk.order.types import CancelOrderParams
        params = CancelOrderParams(order_id="123")

        # Call the method
        result = asyncio.run(self.client.cancel_order(params))

        # Check that order.cancel_order was called with the correct arguments
        self.client.order.cancel_order.assert_called_once_with(params)

        # Check the result
        self.assertEqual(result, {"code": "SUCCESS", "data": {"success": True}})

    def test_get_account_asset(self):
        """Test get_account_asset method."""
        # Mock the account.get_account_asset method
        self.client.account = MagicMock()
        self.client.account.get_account_asset = AsyncMock(return_value={"code": "SUCCESS", "data": {"assets": []}})

        # Call the method
        result = asyncio.run(self.client.get_account_asset())

        # Check that account.get_account_asset was called
        self.client.account.get_account_asset.assert_called_once()

        # Check the result
        self.assertEqual(result, {"code": "SUCCESS", "data": {"assets": []}})

    def test_get_account_positions(self):
        """Test get_account_positions method."""
        # Mock the account.get_account_positions method
        self.client.account = MagicMock()
        self.client.account.get_account_positions = AsyncMock(return_value={"code": "SUCCESS", "data": {"positions": []}})

        # Call the method
        result = asyncio.run(self.client.get_account_positions())

        # Check that account.get_account_positions was called
        self.client.account.get_account_positions.assert_called_once()

        # Check the result
        self.assertEqual(result, {"code": "SUCCESS", "data": {"positions": []}})

    def test_create_limit_order(self):
        """Test create_limit_order method."""
        # Mock the create_order method
        self.client.create_order = AsyncMock(return_value={"code": "SUCCESS", "data": {"orderId": "123"}})

        # Call the method
        result = asyncio.run(self.client.create_limit_order(
            contract_id="BTC-USDT",
            size="0.001",
            price="30000",
            side=OrderSide.BUY
        ))

        # Check that create_order was called with the correct arguments
        self.client.create_order.assert_called_once()
        args = self.client.create_order.call_args[0][0]
        self.assertEqual(args.contract_id, "BTC-USDT")
        self.assertEqual(args.size, "0.001")
        self.assertEqual(args.price, "30000")
        self.assertEqual(args.side, OrderSide.BUY)
        self.assertEqual(args.type, OrderType.LIMIT)

        # Check the result
        self.assertEqual(result, {"code": "SUCCESS", "data": {"orderId": "123"}})

    def test_create_market_order(self):
        """Test create_market_order method."""
        # Mock the get_metadata method
        self.client.get_metadata = AsyncMock(return_value={
            "data": {
                "contractList": [
                    {
                        "contractId": "BTC-USDT",
                        "tickSize": "0.01"
                    }
                ]
            }
        })

        # Mock the get_24_hour_quote method
        self.client.get_24_hour_quote = AsyncMock(return_value={
            "data": [
                {
                    "oraclePrice": "30000"
                }
            ]
        })

        # Mock the create_order method
        self.client.create_order = AsyncMock(return_value={"code": "SUCCESS", "data": {"orderId": "123"}})

        # Call the method
        result = asyncio.run(self.client.create_market_order(
            contract_id="BTC-USDT",
            size="0.001",
            side=OrderSide.BUY
        ))

        # Check that get_metadata was called
        self.client.get_metadata.assert_called_once()

        # Check that get_24_hour_quote was called with the correct arguments
        self.client.get_24_hour_quote.assert_called_once_with("BTC-USDT")

        # Check that create_order was called with the correct arguments
        self.client.create_order.assert_called_once()
        args = self.client.create_order.call_args[0][0]
        self.assertEqual(args.contract_id, "BTC-USDT")
        self.assertEqual(args.size, "0.001")
        self.assertEqual(args.side, OrderSide.BUY)
        self.assertEqual(args.type, OrderType.MARKET)

        # Check the result
        self.assertEqual(result, {"code": "SUCCESS", "data": {"orderId": "123"}})


class TestRequestInterceptor(unittest.TestCase):
    """Test cases for the RequestInterceptor."""

    def setUp(self):
        """Set up test fixtures."""
        self.base_url = "https://testnet.edgex.exchange"

        # Create a mock internal client
        self.mock_internal_client = MagicMock()
        self.mock_internal_client.get_value.return_value = "value"
        self.mock_internal_client.sign.return_value = MagicMock(r="r", s="s")

        # Create a request interceptor
        self.interceptor = RequestInterceptor(self.mock_internal_client, self.base_url)

    def test_call_with_body(self):
        """Test __call__ method with a request body."""
        # Create a mock request
        mock_request = MagicMock()
        mock_request.url = f"{self.base_url}/api/v1/order"
        mock_request.method = "POST"
        mock_request.body = b'{"key": "value"}'
        mock_request.headers = {}

        # Call the interceptor
        result = self.interceptor(mock_request)

        # Check that the timestamp header was added
        self.assertIn("X-edgeX-Api-Timestamp", result.headers)

        # Check that the signature header was added
        self.assertIn("X-edgeX-Api-Signature", result.headers)
        self.assertEqual(result.headers["X-edgeX-Api-Signature"], "rs")

        # Check that the internal client's get_value method was called
        self.mock_internal_client.get_value.assert_called_once()

        # Check that the internal client's sign method was called
        self.mock_internal_client.sign.assert_called_once()

    def test_call_without_body(self):
        """Test __call__ method without a request body."""
        # Create a mock request
        mock_request = MagicMock()
        mock_request.url = f"{self.base_url}/api/v1/metadata"
        mock_request.method = "GET"
        mock_request.body = None
        mock_request.headers = {}

        # Call the interceptor
        result = self.interceptor(mock_request)

        # Check that the timestamp header was added
        self.assertIn("X-edgeX-Api-Timestamp", result.headers)

        # Check that the signature header was added
        self.assertIn("X-edgeX-Api-Signature", result.headers)
        self.assertEqual(result.headers["X-edgeX-Api-Signature"], "rs")

        # Check that the internal client's get_value method was not called
        self.mock_internal_client.get_value.assert_not_called()

        # Check that the internal client's sign method was called
        self.mock_internal_client.sign.assert_called_once()

    def test_call_with_query_params(self):
        """Test __call__ method with query parameters."""
        # Create a mock request
        mock_request = MagicMock()
        mock_request.url = f"{self.base_url}/api/v1/metadata?param1=value1&param2=value2"
        mock_request.method = "GET"
        mock_request.body = None
        mock_request.headers = {}

        # Call the interceptor
        result = self.interceptor(mock_request)

        # Check that the timestamp header was added
        self.assertIn("X-edgeX-Api-Timestamp", result.headers)

        # Check that the signature header was added
        self.assertIn("X-edgeX-Api-Signature", result.headers)
        self.assertEqual(result.headers["X-edgeX-Api-Signature"], "rs")

        # Check that the internal client's get_value method was not called
        self.mock_internal_client.get_value.assert_not_called()

        # Check that the internal client's sign method was called
        self.mock_internal_client.sign.assert_called_once()


if __name__ == '__main__':
    unittest.main()


## tests/test_starkex_signing_adapter.py
"""
Unit tests for the StarkEx signing adapter.
"""

import unittest
import binascii
import hashlib

from edgex_sdk.internal.starkex_signing_adapter import StarkExSigningAdapter


class TestStarkExSigningAdapter(unittest.TestCase):
    """Test cases for the StarkEx signing adapter."""

    def setUp(self):
        """Set up test fixtures."""
        self.adapter = StarkExSigningAdapter()

        # Test private key (32 bytes)
        self.private_key_hex = "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"

        # Test message hash (32 bytes)
        self.message_hash_hex = "0000000000000000000000000000000000000000000000000000000000000001"
        self.message_hash = binascii.unhexlify(self.message_hash_hex)

    def test_sign_and_verify(self):
        """Test sign and verify methods."""
        # Sign the message
        r, s = self.adapter.sign(self.message_hash, self.private_key_hex)

        # Check that r and s are hex strings of length 64
        self.assertIsInstance(r, str)
        self.assertIsInstance(s, str)
        self.assertEqual(len(r), 64)
        self.assertEqual(len(s), 64)

        # Check that r and s are valid hex strings
        try:
            int(r, 16)
            int(s, 16)
        except ValueError:
            self.fail("r or s is not a valid hex string")

        # Get the public key
        public_key = self.adapter.get_public_key(self.private_key_hex)

        # Check that the public key is a hex string of length 64
        self.assertIsInstance(public_key, str)
        self.assertEqual(len(public_key), 64)

        # Verify the signature
        result = self.adapter.verify(self.message_hash, (r, s), public_key)

        # Check that the signature is valid
        self.assertTrue(result)

    def test_sign_different_messages(self):
        """Test signing different messages produces different signatures."""
        # Sign the first message
        r1, s1 = self.adapter.sign(self.message_hash, self.private_key_hex)

        # Create a different message hash
        message_hash2 = hashlib.sha256(b"different message").digest()

        # Sign the second message
        r2, s2 = self.adapter.sign(message_hash2, self.private_key_hex)

        # Check that the signatures are different
        self.assertNotEqual((r1, s1), (r2, s2))

    def test_sign_different_keys(self):
        """Test signing the same message with different keys produces different signatures."""
        # Sign with the first key
        r1, s1 = self.adapter.sign(self.message_hash, self.private_key_hex)

        # Create a different private key
        private_key2 = "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210"

        # Sign with the second key
        r2, s2 = self.adapter.sign(self.message_hash, private_key2)

        # Check that the signatures are different
        self.assertNotEqual((r1, s1), (r2, s2))

    def test_verify_invalid_signature(self):
        """Test verifying an invalid signature."""
        # Sign the message
        r, s = self.adapter.sign(self.message_hash, self.private_key_hex)

        # Get the public key
        public_key = self.adapter.get_public_key(self.private_key_hex)

        # Modify the signature
        r_invalid = format(int(r, 16) + 1, '064x')

        # Verify the invalid signature
        result = self.adapter.verify(self.message_hash, (r_invalid, s), public_key)

        # Check that the signature is invalid
        self.assertFalse(result)

    def test_verify_wrong_message(self):
        """Test verifying a signature with the wrong message."""
        # Sign the message
        r, s = self.adapter.sign(self.message_hash, self.private_key_hex)

        # Get the public key
        public_key = self.adapter.get_public_key(self.private_key_hex)

        # Create a different message hash
        message_hash2 = hashlib.sha256(b"different message").digest()

        # Verify the signature with the wrong message
        result = self.adapter.verify(message_hash2, (r, s), public_key)

        # Check that the signature is invalid
        self.assertFalse(result)

    def test_verify_wrong_public_key(self):
        """Test verifying a signature with the wrong public key."""
        # Sign the message
        r, s = self.adapter.sign(self.message_hash, self.private_key_hex)

        # Create a different private key
        private_key2 = "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210"

        # Get the wrong public key
        wrong_public_key = self.adapter.get_public_key(private_key2)

        # Verify the signature with the wrong public key
        result = self.adapter.verify(self.message_hash, (r, s), wrong_public_key)

        # Check that the signature is invalid
        self.assertFalse(result)

    def test_invalid_private_key(self):
        """Test signing with an invalid private key."""
        # Invalid hex string
        with self.assertRaises(ValueError):
            self.adapter.sign(self.message_hash, "not a hex string")

        # Private key with value 0 should be handled
        try:
            self.adapter.sign(self.message_hash, "0" * 64)
        except ValueError:
            self.fail("sign() raised ValueError unexpectedly with private key of all zeros")

    def test_invalid_message_hash(self):
        """Test signing with an invalid message hash."""
        # Message hash out of range should be handled
        huge_hash = b"\xff" * 32
        try:
            self.adapter.sign(huge_hash, self.private_key_hex)
        except ValueError:
            self.fail("sign() raised ValueError unexpectedly with large message hash")


if __name__ == '__main__':
    unittest.main()


Passer au contenu principal
 2025 Python Packaging Survey is now live!  Take the survey now
PyPI
Chercher dans PyPI
Type '/' to search projects
Rechercher
Aide Docs Sponsors Se connecter S'inscrire
edgex-python-sdk 0.1.0
pip install edgex-python-sdkCopier les instructions pip

Dernière version
Dernière version : 30 mai 2025

A Python SDK for interacting with the EdgeX Exchange API

Navigation
 Description du projet
 Historique des versions
 Téléchargement des fichiers
Détails vérifiés 
These details have been verified by PyPI
Maintenu par
Avatar de edgex_exchange via gravatar.com edgex_exchange
Détails non vérifiés
Ces détails n'ont pas été vérifiés par PyPi
Liens du projet
Homepage
Bug Reports
Documentation
Repository
Métadonnées
Licence : MIT License (MIT)
Créé par : EdgeX Tech
Maintenu par : EdgeX Tech
 Étiquettesedgex , exchange , trading , api , sdk , cryptocurrency
Nécessite : Python >=3.7
Fournit-Extra : dev
Classifieurs
Development Status
3 - Alpha
Intended Audience
Developers
License
OSI Approved :: MIT License
Programming Language
Python :: 3
Python :: 3.7
Python :: 3.8
Python :: 3.9
Python :: 3.10
Python :: 3.11
Topic
Internet :: WWW/HTTP :: Dynamic Content
Office/Business :: Financial
Software Development :: Libraries :: Python Modules
Sponsored: Python Software Foundation
Capital One is a Maintaining sponsor of the Python Software Foundation.
PSF Sponsor · Served ethically
Signaler le projet comme malware
Description du projet
EdgeX Python SDK
A Python SDK for interacting with the EdgeX Exchange API. This SDK provides a comprehensive interface to the EdgeX API, allowing you to easily integrate EdgeX functionality into your Python applications.

Features
Complete API Coverage: Access all EdgeX API endpoints
WebSocket Support: Real-time data streaming
Async/Await: Modern Python async interface
Type Hints: Comprehensive type annotations for better IDE support
Error Handling: Proper error handling and validation
Pagination: Support for paginated API endpoints
Authentication: Automatic request signing
Installation
From PyPI
pip install edgex-python-sdk
From Source
git clone https://github.com/edgex-Tech/edgex-python-sdk.git
cd edgex-python-sdk/python_sdk
pip install -e .
Using Requirements Files
For production use:

pip install -r requirements.txt
For development (includes testing and linting tools):

pip install -r requirements-dev.txt
Virtual Environment (Recommended)
It's recommended to use a virtual environment:

# Create virtual environment
python3 -m venv venv

# Activate virtual environment
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Or install in development mode
pip install -e .
Quick Start
import asyncio
import os
from edgex_sdk import Client, OrderSide

async def main():
    # Create a new client
    client = Client(
        base_url="https://testnet.edgex.exchange",
        account_id=542069824235241782,  # Your account ID
        stark_private_key="your-stark-private-key"  # Your private key
    )

    # Get server time
    server_time = await client.get_server_time()
    print(f"Server Time: {server_time}")

    # Get exchange metadata
    metadata = await client.get_metadata()
    print(f"Available contracts: {len(metadata.get('data', {}).get('contractList', []))}")

    # Get account assets
    assets = await client.get_account_asset()
    print(f"Account Assets: {assets}")

    # Get account positions
    positions = await client.get_account_positions()
    print(f"Account Positions: {positions}")

    # Get 24-hour market data for BNBUSDT (contract ID: 10000004)
    quote = await client.get_24_hour_quote("10000004")
    print(f"BNBUSDT Price: {quote}")

    # Create a limit order (uncomment to place real order)
    # order = await client.create_limit_order(
    #     contract_id="10000004",  # BNBUSDT
    #     size="0.01",
    #     price="600.00",
    #     side=OrderSide.BUY
    # )
    # print(f"Order created: {order}")

# Run the async function
asyncio.run(main())
Architecture
The SDK is organized into modules that correspond to the EdgeX API structure:

edgex_sdk/
├── __init__.py
├── client.py           # Main client
├── account/            # Account API
├── asset/              # Asset API
├── funding/            # Funding API
├── internal/           # Internal utilities
├── metadata/           # Metadata API
├── order/              # Order API
├── quote/              # Quote API
├── transfer/           # Transfer API
└── ws/                 # WebSocket API
Available APIs
The SDK currently supports the following API modules:

Account API: Manage account positions, retrieve position transactions, and handle collateral transactions

Get account positions
Get position by contract ID
Get position transaction history
Get collateral transaction details
Update leverage settings
Asset API: Handle asset management and withdrawals

Get asset orders with pagination
Get coin rates
Manage withdrawals (normal, cross-chain, and fast)
Get withdrawal records and sign information
Check withdrawable amounts
Funding API: Manage funding operations and account balance

Handle funding transactions
Manage funding accounts
Get funding transaction history
Metadata API: Access exchange system information

Get server time
Get exchange metadata (trading pairs, contracts, etc.)
Order API: Comprehensive order management

Create and cancel orders
Get active orders
Get order fill transactions
Calculate maximum order sizes
Manage order history
Quote API: Access market data and pricing

Get multi-contract K-line data
Get order book depth
Access real-time market quotes
Get 24-hour ticker data
Transfer API: Handle asset transfers

Create transfer out orders
Get transfer records (in/out)
Check available withdrawal amounts
Manage transfer history
WebSocket API: Real-time data streaming

Market data (tickers, K-lines, order book, trades)
Account updates
Order updates
Position updates
WebSocket Support
The SDK provides a WebSocket manager for handling real-time data:

import asyncio
from edgex_sdk import WebSocketManager

async def main():
    # Create a WebSocket manager
    ws_manager = WebSocketManager(
        base_url="wss://quote-testnet.edgex.exchange",
        account_id=542069824235241782,
        stark_pri_key="your-stark-private-key"
    )

    # Define message handlers
    def ticker_handler(message):
        print(f"Ticker Update: {message}")

    def kline_handler(message):
        print(f"K-line Update: {message}")

    # Connect to public WebSocket for market data
    ws_manager.connect_public()

    # Subscribe to real-time updates for BNBUSDT (contract ID: 10000004)
    ws_manager.subscribe_ticker("10000004", ticker_handler)
    ws_manager.subscribe_kline("10000004", "1m", kline_handler)

    # Connect to private WebSocket for account updates
    ws_manager.connect_private()

    # Wait for updates
    await asyncio.sleep(30)

    # Disconnect all connections
    ws_manager.disconnect_all()

asyncio.run(main())
Signing Adapters
The SDK provides a flexible signing mechanism through signing adapters. StarkExSigningAdapter is used by default, so you don't need to explicitly create one:

from edgex_sdk import Client

# Create a client (uses StarkExSigningAdapter by default)
client = Client(
    base_url="https://testnet.edgex.exchange",
    account_id=12345,
    stark_private_key="your-stark-private-key"
)
If you need to use a custom signing adapter, you can still provide one:

from edgex_sdk import Client, StarkExSigningAdapter

# Create a custom signing adapter (optional)
signing_adapter = StarkExSigningAdapter()

# Create a client with a custom signing adapter
client = Client(
    base_url="https://testnet.edgex.exchange",
    account_id=12345,
    stark_private_key="your-stark-private-key",
    signing_adapter=signing_adapter
)
The SDK includes the following signing adapters:

StarkExSigningAdapter (default): Full implementation using StarkWare cryptographic operations for production use
You can also create your own signing adapter by implementing the SigningAdapter interface if you need custom cryptographic operations.

Error Handling
The SDK provides proper error handling for API requests:

import asyncio
from edgex_sdk import Client, OrderSide

async def main():
    client = Client(
        base_url="https://testnet.edgex.exchange",
        account_id=542069824235241782,
        stark_private_key="your-stark-private-key"
    )

    try:
        # Create a limit order for BNBUSDT
        order = await client.create_limit_order(
            contract_id="10000004",  # BNBUSDT
            size="0.01",
            price="600.00",
            side=OrderSide.BUY
        )
        print(f"Order created: {order}")

        # Cancel the order
        from edgex_sdk import CancelOrderParams
        cancel_params = CancelOrderParams(
            order_id=order.get("data", {}).get("orderId")
        )
        cancel_result = await client.cancel_order(cancel_params)
        print(f"Order cancelled: {cancel_result}")

    except ValueError as e:
        print(f"Failed to create/cancel order: {str(e)}")
    except Exception as e:
        print(f"Unexpected error: {str(e)}")

asyncio.run(main())
Pagination
Many API endpoints support pagination:

import asyncio
from edgex_sdk import Client, GetActiveOrderParams

async def main():
    client = Client(
        base_url="https://testnet.edgex.exchange",
        account_id=542069824235241782,
        stark_private_key="your-stark-private-key"
    )

    # Create pagination parameters
    params = GetActiveOrderParams(
        size="10",
        offset_data=""
    )

    # Get active orders
    orders = await client.get_active_orders(params)
    print(f"Active orders: {orders}")

    # Get next page if available
    if orders.get("data", {}).get("hasNext"):
        params.offset_data = orders.get("data", {}).get("offsetData")
        next_page = await client.get_active_orders(params)
        print(f"Next page: {next_page}")

asyncio.run(main())
API Examples
Market Data
from edgex_sdk import Client, GetKLineParams, GetOrderBookDepthParams

# Get 24-hour market quotes for BNBUSDT (contract ID: 10000004)
quote = await client.get_24_hour_quote("10000004")
print(f"Current price: {quote}")

# Get K-line data for BTCUSDT (contract ID: 10000001)
kline_params = GetKLineParams(
    contract_id="10000001",  # BTCUSDT
    interval="1m",
    size="10"
)
klines = await client.quote.get_k_line(kline_params)
print(f"K-lines: {klines}")

# Get order book depth for ETHUSDT (contract ID: 10000002)
depth_params = GetOrderBookDepthParams(
    contract_id="10000002",  # ETHUSDT
    limit=10
)
depth = await client.quote.get_order_book_depth(depth_params)
print(f"Order book: {depth}")
Account Management
# Get account assets
assets = await client.get_account_asset()
print(f"Account assets: {assets}")

# Get account positions
positions = await client.get_account_positions()
print(f"Positions: {positions}")

# Get position transactions
from edgex_sdk import GetPositionTransactionPageParams
tx_params = GetPositionTransactionPageParams(
    size="10",
    offset_data=""
)
transactions = await client.account.get_position_transaction_page(tx_params)
print(f"Transactions: {transactions}")
Order Management
from edgex_sdk import OrderSide, CreateOrderParams, CancelOrderParams

# Create a limit order for BNBUSDT
order = await client.create_limit_order(
    contract_id="10000004",  # BNBUSDT
    size="0.01",
    price="600.00",
    side=OrderSide.BUY
)
print(f"Order created: {order}")

# Get maximum order size for BNBUSDT
max_size = await client.get_max_order_size("10000004", 600.00)
print(f"Max order size: {max_size}")

# Cancel an order
cancel_params = CancelOrderParams(
    order_id=order.get("data", {}).get("orderId")
)
cancel_result = await client.cancel_order(cancel_params)
print(f"Order cancelled: {cancel_result}")
Contract IDs
EdgeX uses numeric contract IDs instead of symbol-based identifiers. Here are some common contract mappings:

Contract ID	Symbol	Name	Tick Size
10000001	BTCUSDT	Bitcoin	0.1
10000002	ETHUSDT	Ethereum	0.01
10000003	SOLUSDT	Solana	0.001
10000004	BNBUSDT	BNB	0.01
10000005	LTCUSDT	Litecoin	0.01
10000006	LINKUSDT	Chainlink	0.001
10000007	AVAX2USDT	Avalanche	0.001
10000008	MATICUSDT	Polygon	0.0001
10000009	XRPUSDT	XRP	0.0001
10000010	DOGEUSDT	Dogecoin	0.00001
To get the complete list of available contracts:

metadata = await client.get_metadata()
contracts = metadata.get("data", {}).get("contractList", [])
for contract in contracts:
    print(f"ID: {contract['contractId']} - {contract['contractName']}")
For more detailed examples, please refer to the examples directory.

Testing
The SDK includes comprehensive test coverage with multiple test suites:

Unit Tests
# Run unit tests (no API credentials required)
python -m pytest tests/test_client.py tests/test_starkex_signing_adapter.py -v
Public API Tests
# Run public endpoint tests (no authentication required)
python run_public_tests.py
Mock Integration Tests
# Run mock tests (test structure without real API calls)
python run_mock_tests.py
Full Integration Tests
# Run full integration tests (requires real API credentials)
python run_integration_tests.py
All Tests
# Run all available tests
python run_tests.py
For more testing information, see TESTING.md.

Environment Variables
For testing and development, you can set the following environment variables or create a .env file:

# API Configuration
EDGEX_BASE_URL=https://testnet.edgex.exchange
EDGEX_WS_URL=wss://quote-testnet.edgex.exchange

# Account Credentials
EDGEX_ACCOUNT_ID=542069824235241782
EDGEX_STARK_PRIVATE_KEY=your-stark-private-key

# Signing Configuration
EDGEX_SIGNING_ADAPTER=starkex
Then load them in your code:

import os
from dotenv import load_dotenv
from edgex_sdk import Client

# Load environment variables from .env file
load_dotenv()

client = Client(
    base_url=os.getenv("EDGEX_BASE_URL"),
    account_id=int(os.getenv("EDGEX_ACCOUNT_ID")),
    stark_private_key=os.getenv("EDGEX_STARK_PRIVATE_KEY")
)
Documentation
For detailed API documentation, please refer to the EdgeX API documentation.

Contributing
Fork the repository
Create your feature branch (git checkout -b feature/my-new-feature)
Commit your changes (git commit -am 'Add some feature')
Push to the branch (git push origin feature/my-new-feature)
Create a new Pull Request
License
This project is licensed under the MIT License - see the LICENSE file for details.


Aide
Installation de paquets
Publier de paquets
Guide d'utilisation
Nom du projet réservé
FAQ
À propos de PyPI
Blog de PyPI
Tableau de bord de l'infrastructure
Statistiques
Logos et marques
Nos sponsors
Contribuer à PyPI
Bugs et commentaires
Contribuer sur GitHub
Traduire PyPI
Sponsor pypi
Liste des développeurs et développeuses
Utilisation de PyPI
Terms of Service
Signaler un problème de sécurité
Code de conduite
Notice de confidentialité
Politique d'utilisation acceptable
Statut : All Systems Operational

Développé est maintenu par la communauté Python, pour la communauté Python.
Faites un don aujourd'hui !

"PyPI", "Python Package Index", and the Blocks logos are registered Trademarks of the Python Software Foundation .

© 2025 Python Software Foundation
Plan du site

English español français 日本語 português (Brasil) українська Ελληνικά Deutsch 中文 (简体) 中文 (繁體) русский עברית Esperanto 한국어

